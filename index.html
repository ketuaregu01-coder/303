
<!DOCTYPE html>
<html lang="id">
<head>
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#00fff7">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="/icons/icon-192.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>303 Pro</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
        }
        header {
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            padding: 12px;
            gap: 10px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 999;
        }
        button.nav-btn {
            background: rgba(0,0,0,0.6);
            color: #fff;
            border: 2px solid #fff;
            border-radius: 8px;
            padding: 8px 14px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        button.nav-btn:hover {
            background: #fff;
            color: #000;
        }
        button.nav-btn.active {
            background: #00ffff;
            color: #000;
        }
        .spa-page {
            width: 100%;
            height: 100vh;
            position: absolute;
            top: 60px;
            left: 0;
        }
        iframe {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <header>
        <button class="nav-btn active" onclick="showPage('pagePolaBK', this)">Pola BK</button>
        <button class="nav-btn" onclick="showPage('pageGPTPro', this)">GPT Pro</button>
        <button class="nav-btn" onclick="showPage('pageMatrixPro', this)">Matrix Pro</button>
    </header>

    
    <section id="pagePolaBK" class="spa-page" style="display:none;">
        <iframe srcdoc='<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistem Analisis Prediksi</title>
    <style>
        /* [START] PERBAIKAN DESAIN FUTURISTIK & NEON GLOW */
        
        /* CSS Variables for Dynamic Colors and Transitions */
        :root {
            /* Warna default (Manajemen Data) */
            --base-bg-color: #0a0a1a; 
            --secondary-bg-color: #1a1a3a;
            --active-neon-color: #00ffff;
            /* SVG grid pattern menggunakan warna neon aktif */
            --grid-bg-url: url(&apos;data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(0,255,255,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>&apos;);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: &apos;Segoe UI&apos;, Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            /* Latar Belakang Gradien dengan Transisi Warna (1.0s) */
            background: linear-gradient(135deg, var(--base-bg-color) 0%, var(--secondary-bg-color) 100%);
            transition: background 1.0s ease-in-out; 
            color: #ffffff;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: &apos;&apos;;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Latar Belakang Kisi (Grid) dengan Transisi Warna */
            background: var(--grid-bg-url);
            transition: background 1.0s ease-in-out; 
            z-index: -1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            /* Multi-color Neon Glow yang lebih berwarna */
            text-shadow: 0 0 5px #ff00ff, 0 0 10px #00ffff, 0 0 15px #ff00ff, 0 0 20px #00ffff;
            animation: colorfulGlow 3s ease-in-out infinite alternate;
        }

        @keyframes colorfulGlow {
            0% { text-shadow: 0 0 5px #ff00ff, 0 0 10px #00ffff; }
            50% { text-shadow: 0 0 10px #00ff00, 0 0 20px #ff00ff; }
            100% { text-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff; }
        }

        .card {
            /* Efek Glassmorphism yang ditingkatkan */
            background: rgba(20, 20, 40, 0.9);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            backdrop-filter: blur(15px); 
            border: 1px solid rgba(0, 255, 255, 0.5); 
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.3);
            transition: all 0.5s ease; /* Transisi lebih halus */
        }

        .card:hover {
            /* Dual color hover glow yang dramatis */
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6), 0 0 60px rgba(255, 0, 255, 0.2); 
            transform: translateY(-5px);
        }

        .card-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            /* Menggunakan warna neon aktif */
            color: var(--active-neon-color); 
            text-shadow: 0 0 5px var(--active-neon-color);
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            background: transparent;
            border: none;
            color: #ffffff;
            font-size: 1rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .tab:hover {
            color: var(--active-neon-color);
        }

        .tab.active {
            /* Dynamic active color */
            color: var(--active-neon-color); 
            text-shadow: 0 0 5px var(--active-neon-color); 
        }

        .tab.active::after {
            content: &apos;&apos;;
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100%;
            height: 2px;
            /* Dynamic active color underline */
            background: var(--active-neon-color); 
            box-shadow: 0 0 10px var(--active-neon-color), 0 0 20px var(--active-neon-color); 
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .btn {
            background: linear-gradient(45deg, #0066cc, #00ccff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            margin: 5px;
            transition: all 0.5s ease; 
            box-shadow: 0 0 12px rgba(0, 204, 255, 0.7), 0 0 5px rgba(255, 255, 255, 0.5) inset; 
        }

        .btn:hover {
            transform: translateY(-3px); 
            box-shadow: 0 0 20px rgba(0, 204, 255, 1), 0 0 10px rgba(255, 255, 255, 0.8) inset;
        }
        
        .btn:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: linear-gradient(45deg, #cc0000, #ff3366);
            box-shadow: 0 0 12px rgba(255, 51, 102, 0.7), 0 0 5px rgba(255, 255, 255, 0.5) inset;
        }

        .btn-danger:hover {
            box-shadow: 0 0 20px rgba(255, 51, 102, 1), 0 0 10px rgba(255, 255, 255, 0.8) inset;
        }

        .btn-success {
            background: linear-gradient(45deg, #00aa00, #00ff00);
            box-shadow: 0 0 12px rgba(0, 255, 0, 0.7), 0 0 5px rgba(255, 255, 255, 0.5) inset;
        }

        .btn-success:hover {
            box-shadow: 0 0 20px rgba(0, 255, 0, 1), 0 0 10px rgba(255, 255, 255, 0.8) inset;
        }
        
        .btn-tarung {
            background: linear-gradient(45deg, #ff8c00, #ff4500);
            box-shadow: 0 0 12px rgba(255, 140, 0, 0.7), 0 0 5px rgba(255, 255, 255, 0.5) inset;
        }

        .btn-tarung:hover {
            box-shadow: 0 0 20px rgba(255, 69, 0, 1), 0 0 10px rgba(255, 255, 255, 0.8) inset;
        }


        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-top: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        /* ... (CSS lainnya dipertahankan) ... */
        
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.95rem;
        }

        .history-table th, .history-table td {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px;
            text-align: center;
        }

        .history-table th {
            background-color: rgba(0, 255, 255, 0.1);
            color: var(--active-neon-color);
        }
        
        .history-table.tarung th {
            background-color: rgba(255, 140, 0, 0.1);
            color: #ff8c00;
        }
        
        .history-table.rebound th {
            background-color: rgba(0, 255, 0, 0.1);
            color: #00ff00;
        }

        .highlight-new {
            background-color: rgba(255, 255, 0, 0.1);
            color: #ff0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #00ffff;
            text-shadow: 0 0 3px #00ffff;
        }

        .form-group select, .form-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ffff;
            background-color: #1a1a3a;
            color: #ffffff;
            font-size: 1rem;
            appearance: none; /* Hide default arrow */
            transition: border-color 0.3s;
        }

        .form-group select:focus, .form-group input[type="number"]:focus {
            outline: none;
            border-color: #ff00ff;
        }

        .prediction-box {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            margin-top: 15px;
            border-radius: 10px;
            border-left: 3px solid var(--active-neon-color);
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }
        
        /* HEATMAP STYLES */
        .heatmap-container {
            overflow-x: auto;
            margin-bottom: 20px;
            padding: 10px 0;
        }

        .heatmap {
            display: grid;
            grid-template-columns: repeat(10, 50px); /* 0-9 digits */
            grid-template-rows: auto;
            gap: 1px;
            background-color: #0a0a1a;
            padding: 5px;
            border-radius: 5px;
        }
        
        .heatmap-cell {
            background-color: #1a1a3a;
            color: #fff;
            padding: 5px;
            text-align: center;
            font-size: 0.8rem;
            transition: background-color 0.5s ease;
            border-radius: 3px;
            cursor: pointer;
            border: 1px solid transparent;
        }

        .heatmap-cell.header {
            font-weight: bold;
            color: var(--active-neon-color);
            background-color: #111;
        }

        .heatmap-high { /* Rebound < 3 hari (Critical) */
            background-color: #ff3300 !important;
            box-shadow: 0 0 5px #ff3300;
        }
        .heatmap-medium { /* Rebound 3-6 hari (Sedang) */
            background-color: #ffcc00 !important;
            box-shadow: 0 0 5px #ffcc00;
        }
        .heatmap-low { /* Rebound 7+ hari (Good) */
            background-color: #00ff00 !important;
            box-shadow: 0 0 5px #00ff00;
        }
        
        .legend {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border-radius: 50%;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                flex: 1 0 50%;
                text-align: center;
                padding: 10px 15px;
            }

            .modal-content {
                width: 95%; 
                padding: 20px;
            }

            .pattern-card {
                width: 100%;
            }
        }
        /* [END] CSS LENGKAP */
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>SISTEM ANALISIS PREDIKSI</h1>
            <p style="color: var(--active-neon-color); opacity: 0.8;">Sistem Prediksi Cerdas dengan Analisis Data Historis Harian</p>
        </header>

        <div class="card">
            <div class="tabs">
                <button class="tab active" onclick="switchMainTab(&apos;data-tab&apos;)">Manajemen Data</button>
                <button class="tab" onclick="switchMainTab(&apos;prediction-tab&apos;)">Prediksi</button>
                <button class="tab" onclick="switchMainTab(&apos;rebound-tab&apos;)">Analisis Pola BK</button>
                <button class="tab" onclick="switchMainTab(&apos;map-tab&apos;)">Map Pola BK</button>
                <button class="tab" onclick="switchMainTab(&apos;tarung-tab&apos;)">Angka Tarung</button>
            </div>

            <div id="data-tab" class="tab-content active">
                <div class="card-title">Manajemen Data Historis</div>
                
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".txt" onchange="handleFileUpload(event)">
                    <label for="fileInput" class="file-input-label">Pilih File Text</label>
                </div>
                
                <div style="margin-top: 20px;">
                    <p style="opacity: 0.7;">*Format file: dd/mm/yyyy,1,2,3,4 (4D) atau dd/mm/yyyy,1,2,3,4,5 (5D)</p>
                </div>

                <div class="file-list" id="fileList">
                    <div class="card-title">File Tersimpan</div>
                    <div id="savedFiles"></div>
                </div>

                <div class="card-title">10 History Terakhir</div>
                <div id="recentHistory">
                    <p style="text-align: center; opacity: 0.7;">Belum ada data yang dimuat</p>
                </div>
            </div>

            <div id="prediction-tab" class="tab-content">
                <div class="card-title">Prediksi Angka</div>
                
                <div class="form-group">
                    <label for="poolSelect">Pilih POOL</label>
                    <select id="poolSelect">
                        <option value="">-- Pilih POOL --</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="daySelect">Pilih Hari Prediksi</label>
                    <select id="daySelect">
                        <option value="senin">Senin</option>
                        <option value="selasa">Selasa</option>
                        <option value="rabu">Rabu</option>
                        <option value="kamis">Kamis</option>
                        <option value="jumat">Jumat</option>
                        <option value="sabtu">Sabtu</option>
                        <option value="minggu">Minggu</option>
                    </select>
                </div>

                <button class="btn btn-success" onclick="generatePrediction()">Generate Prediksi</button>

                <div id="predictionResults" style="margin-top: 30px; display: none;">
                    <div class="card-title">Hasil Analisis Hari Ini</div>
                    <div id="poolInfo" style="margin-bottom: 15px; opacity: 0.8;"></div>

                    <h3 style="color: #00ff00; margin-top: 20px;">Angka Dominan (Top 5 Paling Sering Muncul)</h3>
                    <div id="dominantNumbers" class="prediction-box"></div>

                    <h3 style="color: #ffcc00; margin-top: 20px;">Angka Lemah & Mati (Bottom 5 Paling Jarang Muncul)</h3>
                    <div id="weakDeadNumbers" class="prediction-box"></div>

                    <h3 style="color: #00ccff; margin-top: 20px;">Prediksi 2D (Ekor x Kepala)</h3>
                    <div id="prediction2D" class="prediction-box"></div>

                    <h3 style="color: #ff00ff; margin-top: 20px;">BBFS Rekomendasi</h3>
                    <div id="bbfs" class="prediction-box"></div>

                    <h3 style="color: #ffff00; margin-top: 20px;">Ganjil/Genap & Besar/Kecil</h3>
                    <div id="oddEvenNumbers" class="prediction-box"></div>
                </div>
            </div>

            <div id="rebound-tab" class="tab-content">
                <div class="card-title">Analisis Pola BK</div>
                
                <div class="form-group">
                    <label for="reboundPoolSelect">Pilih POOL</label>
                    <select id="reboundPoolSelect">
                        <option value="">-- Pilih POOL --</option>
                    </select>
                </div>

                <button class="btn btn-success" onclick="analyzeRebound()">Analisis Data</button>

                <div id="reboundResults" style="margin-top: 30px; display: none;">
                    <div class="result-header">
                        <h2>Hasil Analisis Pola BK</h2>
                        <div class="file-info" id="reboundFileInfo"></div>
                    </div>
                
                    <div id="reboundResultsContainer">
                        <p style="text-align: center; opacity: 0.7; margin-top: 20px;">Klik Analisis Data untuk memulai</p>
                    </div>
                
                    <div class="summary" id="reboundSummarySection">
                        <h3>Rangkuman Pola Rebound</h3>
                        <div id="reboundSummaryContent">
                        </div>
                    </div>
                </div>
            </div>

            <div id="map-tab" class="tab-content">
                <div class="card-title">Map Pola BK</div>

                <div class="form-group">
                    <label for="mapPoolSelect">Pilih POOL</label>
                    <select id="mapPoolSelect">
                        <option value="">-- Pilih POOL --</option>
                    </select>
                </div>
                
                <button class="btn btn-success" onclick="analyzeMap()">Analisis Map</button>

                <div id="mapResults" style="margin-top: 30px; display: none;">
                    <div class="result-header">
                        <h2>Map Pola BK</h2>
                        <div class="file-info" id="mapFileInfo"></div>
                    </div>

                    <div class="sub-tabs">
                        <button class="sub-tab active" data-subtab="heatmap-subtab">Heatmap & Rangkuman</button>
                        <button class="sub-tab" data-subtab="details-subtab">Detail Harian</button>
                    </div>

                    <div class="sub-tab-content active" id="heatmap-subtab">
                        <p style="opacity: 0.7; margin-bottom: 15px;">Heatmap menunjukkan hari keterlambatan pola (sejak terakhir muncul) relatif terhadap rata-rata waktu reboundnya.</p>
                        <div class="legend">
                            <div class="legend-item"><span class="legend-color heatmap-high"></span> <span style="color:#ff3300;">KRITIS</span> (Days Since Last > Avg * 1.5)</div>
                            <div class="legend-item"><span class="legend-color heatmap-medium"></span> <span style="color:#ffcc00;">TINGGI</span> (Days Since Last > Avg * 0.8)</div>
                            <div class="legend-item"><span class="legend-color heatmap-low"></span> <span style="color:#00ff00;">NORMAL</span> (Days Since Last < Avg * 0.8)</div>
                        </div>
                        
                        <div class="heatmap-container">
                            <div class="heatmap" id="heatmap">
                                </div>
                        </div>

                        <div class="summary">
                            <h3>Pola dengan Kemungkinan Rebound Tertinggi (Kritis/Tinggi)</h3>
                            <div id="topReboundPatterns">
                                <p style="text-align: center; opacity: 0.7; margin-top: 20px;">Analisis Map belum dijalankan.</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="sub-tab-content" id="details-subtab">
                        <h3>Detail Analisis Harian Pola BK</h3>
                        <div id="detailedResults">
                            </div>
                    </div>
                </div>
            </div>
            
            <div id="tarung-tab" class="tab-content">
                <div class="card-title">Generator Angka Tarung</div>

                <div class="form-group">
                    <label for="tarungPoolSelect">Pilih POOL</label>
                    <select id="tarungPoolSelect">
                        <option value="">-- Pilih POOL --</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="tarungDaySelect">Pilih Hari Prediksi</label>
                    <select id="tarungDaySelect">
                        <option value="senin">Senin</option>
                        <option value="selasa">Selasa</option>
                        <option value="rabu">Rabu</option>
                        <option value="kamis">Kamis</option>
                        <option value="jumat">Jumat</option>
                        <option value="sabtu">Sabtu</option>
                        <option value="minggu">Minggu</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="topNSelect">Angka Tarung Top N (3-7)</label>
                    <input type="number" id="topNSelect" value="5" min="3" max="7">
                </div>

                <button class="btn btn-tarung" onclick="generateAngkaTarungTable()">1. Generate Tabel Angka Tarung</button>

                <div id="tarungTableResults" style="margin-top: 30px; display: none;">
                    </div>

                <div id="tarungPermutationSection" style="margin-top: 30px; display: none;">
                    <div class="card-title" style="color: var(--active-neon-color);">2. Generate Pola Angka & Permutasi</div>
                    <p style="opacity: 0.8; margin-bottom: 15px;">Permutasi angka akan dicocokkan dengan Pola BK yang direkomendasikan untuk hari ini.</p>
                    <button class="btn btn-tarung" onclick="generateAngkaTarungPermutations()">GENERATE POLA ANGKA</button>
                    <button class="btn btn-tarung" style="margin-left: 10px;" onclick="copyAngkaTarung()">Salin Angka Tarung</button>
                    <button class="btn btn-tarung" onclick="saveAngkaTarung()">Simpan File Text</button>
                </div>

                <div id="tarungPermutationsOutput" class="prediction-box" style="margin-top: 20px; display: none; white-space: pre-wrap; word-wrap: break-word; font-family: monospace;">
                    </div>
            </div>
        </div>

        <div id="editModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Edit Data</h2>
                    <button class="close-modal" onclick="closeEditModal()">&times;</button>
                </div>
                <textarea id="dataEditor" class="data-editor"></textarea>
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn" onclick="saveEditedData()">Simpan</button>
                    <button class="btn btn-danger" onclick="closeEditModal()">Batal</button>
                </div>
            </div>
        </div>
        
        <div class="loading" id="loading" style="display: none;">
            <div class="spinner"></div>
            <p>Sedang memproses...</p>
        </div>

        <div class="error" id="errorMessage"></div>

        <script>
            // [START] KONFIGURASI WARNA DINAMIS UNTUK TRANSISI MENU
            const TAB_COLORS = {
                &apos;data-tab&apos;: { 
                    base: &apos;#0a0a1a&apos;, 
                    secondary: &apos;#1a1a3a&apos;, 
                    neon: &apos;#00ffff&apos; 
                }, // Cyan/Blue
                &apos;prediction-tab&apos;: { 
                    base: &apos;#1a0a1a&apos;, 
                    secondary: &apos;#3a1a3a&apos;, 
                    neon: &apos;#ff00ff&apos; 
                }, // Magenta/Purple
                &apos;rebound-tab&apos;: { 
                    base: &apos;#0a1a0a&apos;, 
                    secondary: &apos;#1a3a1a&apos;, 
                    neon: &apos;#00ff00&apos; 
                }, // Green
                &apos;map-tab&apos;: { 
                    base: &apos;#1a1a0a&apos;, 
                    secondary: &apos;#3a3a1a&apos;, 
                    neon: &apos;#ffff00&apos; 
                },  // Yellow/Gold
                &apos;tarung-tab&apos;: { 
                    base: &apos;#1a0a0a&apos;, 
                    secondary: &apos;#3a1a1a&apos;, 
                    neon: &apos;#ff8c00&apos; 
                }  // Orange/Red for Tarung
            };
            // [END] KONFIGURASI WARNA DINAMIS UNTUK TRANSISI MENU

            // Global variables 
            let currentData = {};
            let currentPool = &apos;&apos;;
            let editingFileName = &apos;&apos;;
            
            // Global storage for Angka Tarung (to be used by permutation step)
            let currentTarungData = {};
            let currentPermutationsOutput = &apos;&apos;;
            
            // Global storage for Rebound/Map Analysis
            let lastReboundResults = {};

            // Initialize the app
            document.addEventListener(&apos;DOMContentLoaded&apos;, function() {
                loadSavedFiles();
                updatePoolSelects();
                // Set initial colors and active tab (Manajemen Data)
                switchMainTab(&apos;data-tab&apos;);

                // Add event listeners for sub-tabs
                document.querySelectorAll(&apos;.sub-tab&apos;).forEach(tab => {
                    tab.addEventListener(&apos;click&apos;, function() {
                        // Remove active class from all sub-tabs
                        document.querySelectorAll(&apos;.sub-tab&apos;).forEach(t => t.classList.remove(&apos;active&apos;));
                        // Add active class to clicked sub-tab
                        this.classList.add(&apos;active&apos;);
                        // Hide all sub-tab contents
                        document.querySelectorAll(&apos;.sub-tab-content&apos;).forEach(content => {
                            content.classList.remove(&apos;active&apos;);
                        });
                        // Show the corresponding sub-tab content
                        const subTabId = this.getAttribute(&apos;data-subtab&apos;);
                        document.getElementById(subTabId).classList.add(&apos;active&apos;);
                    });
                });
            });

            // Main tab switching function with dynamic color change
            function switchMainTab(tabId) {
                // Remove active class from all main tabs and contents
                document.querySelectorAll(&apos;.tab&apos;).forEach(t => t.classList.remove(&apos;active&apos;));
                document.querySelectorAll(&apos;.tab-content&apos;).forEach(content => content.classList.remove(&apos;active&apos;));

                // Add active class to the selected tab and content
                const activeTabButton = document.querySelector(`.tab[onclick="switchMainTab(&apos;${tabId}&apos;)"]`);
                if (activeTabButton) {
                    activeTabButton.classList.add(&apos;active&apos;);
                }
                document.getElementById(tabId).classList.add(&apos;active&apos;);

                // --- DYNAMIC COLOR CHANGE LOGIC ---
                const colors = TAB_COLORS[tabId];
                if (colors) {
                    const root = document.documentElement;
                    // Update background gradient colors
                    root.style.setProperty(&apos;--base-bg-color&apos;, colors.base);
                    root.style.setProperty(&apos;--secondary-bg-color&apos;, colors.secondary);
                    // Update active tab neon color for titles and underlines
                    root.style.setProperty(&apos;--active-neon-color&apos;, colors.neon);
                    
                    // Update body::before grid color
                    const r = parseInt(colors.neon.substring(1, 3), 16);
                    const g = parseInt(colors.neon.substring(3, 5), 16);
                    const b = parseInt(colors.neon.substring(5, 7), 16);
                    
                    const gridColor = `rgba(${r}, ${g}, ${b}, 0.1)`;
                    const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="${gridColor}" stroke-width="0.5"/></pattern></defs><rect width="100" height="100" fill="url(%23grid)"/></svg>`;
                    root.style.setProperty(&apos;--grid-bg-url&apos;, `url(&apos;data:image/svg+xml,${encodeURIComponent(svg)}&apos;)`);

                    // Also update card-title and related elements if needed (already using --active-neon-color)
                    document.querySelectorAll(&apos;.card-title&apos;).forEach(title => {
                        title.style.color = colors.neon;
                        title.style.textShadow = `0 0 5px ${colors.neon}`;
                    });
                }
                // --- END DYNAMIC COLOR CHANGE LOGIC ---
            }

            // --- PREDITION FUNCTIONS (DILENGKAPI) ---

            function generatePrediction() {
                const poolName = document.getElementById(&apos;poolSelect&apos;).value;
                const day = document.getElementById(&apos;daySelect&apos;).value;

                if (!poolName) {
                    showNotification(&apos;Silakan pilih POOL terlebih dahulu!&apos;, &apos;error&apos;);
                    return;
                }

                showLoading();

                setTimeout(() => {
                    const allData = currentData[poolName];
                    const filteredData = getFilteredData(poolName, day);
                    const dataToUse = filteredData.length > 5 ? filteredData : allData;

                    if (!dataToUse || dataToUse.length < 10) {
                        hideLoading();
                        showNotification(&apos;Data tidak cukup untuk analisis (Min 10 baris data)!&apos;, &apos;error&apos;);
                        return;
                    }
                    
                    // Display pool info
                    document.getElementById(&apos;poolInfo&apos;).textContent = 
                        `Analisis menggunakan ${dataToUse.length} data historis untuk hari ${day.toUpperCase()} (${poolName}).`;

                    // Run predictions
                    generateDominantNumbers(dataToUse);
                    generateWeakDeadNumbers(dataToUse); // Now fixed and complete
                    generatePrediction2D(dataToUse);
                    generateBBFS(dataToUse);
                    generateOddEvenNumbers(dataToUse);

                    document.getElementById(&apos;predictionResults&apos;).style.display = &apos;block&apos;;
                    hideLoading();
                    showNotification(&apos;Prediksi berhasil di-generate!&apos;, &apos;success&apos;);
                }, 500);
            }

            function generateDominantNumbers(data) {
                const digitCount = data[0].numbers.length;
                const positions = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;];
                let resultHTML = &apos;&apos;;

                for (let pos = 0; pos < digitCount; pos++) {
                    const frequency = {};
                    for (const item of data) {
                        const digit = item.numbers[pos];
                        frequency[digit] = (frequency[digit] || 0) + 1;
                    }

                    const sortedDigits = Object.keys(frequency)
                        .sort((a, b) => frequency[b] - frequency[a])
                        .slice(0, 5)
                        .map(d => parseInt(d));

                    resultHTML += `<div style="margin-bottom: 5px;"><span style="font-weight: bold; color: #00ff00;">Posisi ${positions[pos]} (Top 5):</span> `;
                    resultHTML += sortedDigits.map(d => `<span class="number-box" style="display: inline-block; margin: 0 3px; padding: 3px 6px; border: 1px solid #00ff00; border-radius: 3px;">${d}</span>`).join(&apos;&apos;);
                    resultHTML += &apos;</div>&apos;;
                }

                document.getElementById(&apos;dominantNumbers&apos;).innerHTML = resultHTML;
            }

            function getWeakDeadNumbers(data, pos) {
                const frequency = {};
                for (const item of data) {
                    const digit = item.numbers[pos];
                    frequency[digit] = (frequency[digit] || 0) + 1;
                }

                const sortedDigits = Object.keys(frequency)
                    .sort((a, b) => frequency[a] - frequency[b])
                    .map(d => parseInt(d));
                
                return {
                    weak: sortedDigits.slice(0, 3), // Top 3 Least Frequent
                    dead: sortedDigits.slice(3, 5)  // Next 2 Least Frequent
                };
            }

            function generateWeakDeadNumbers(data) {
                const resultDiv = document.getElementById(&apos;weakDeadNumbers&apos;);
                resultDiv.innerHTML = &apos;&apos;;
                if (data.length === 0) return;

                const digitCount = data[0].numbers.length;
                const positions = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]; // Max 5D
                let resultHTML = &apos;&apos;;

                for (let pos = 0; pos < digitCount; pos++) {
                    const positionLetter = positions[pos];
                    const { weak, dead } = getWeakDeadNumbers(data, pos);

                    resultHTML += `<div style="padding: 10px; margin-bottom: 10px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 5px;">
                        <span style="font-weight: bold; color: #ffcc00;">Posisi ${positionLetter}:</span> 
                        <br/>
                        <span style="color: #ffcc00; font-weight: 500;">Lemah (3):</span> ${weak.map(d => `<span style="display: inline-block; margin: 0 3px; color: #000; background: #ffcc00; padding: 2px 5px; border-radius: 3px;">${d}</span>`).join(&apos;&apos;)}
                        <br/>
                        <span style="color: #ff3366; font-weight: 500;">Mati (2):</span> ${dead.map(d => `<span style="display: inline-block; margin: 0 3px; color: #fff; background: #ff3366; padding: 2px 5px; border-radius: 3px;">${d}</span>`).join(&apos;&apos;)}
                    </div>`;
                }
                resultDiv.innerHTML = resultHTML;
            }

            function generatePrediction2D(data) {
                if (data.length === 0 || data[0].numbers.length < 2) {
                    document.getElementById(&apos;prediction2D&apos;).textContent = "Data tidak cukup (minimal 2D).";
                    return;
                }
                
                const kepalaFrequencies = {}; // Posisi ke-3 (C)
                const ekorFrequencies = {};    // Posisi ke-4 (D)

                // Jika data 5D, kita tetap fokus pada 2D terakhir (D dan E)
                const kepalaPos = data[0].numbers.length === 5 ? 3 : 2; // D (index 3) atau C (index 2)
                const ekorPos = data[0].numbers.length - 1; // E (index 4) atau D (index 3)

                for (const item of data) {
                    const kepala = item.numbers[kepalaPos];
                    const ekor = item.numbers[ekorPos];
                    
                    kepalaFrequencies[kepala] = (kepalaFrequencies[kepala] || 0) + 1;
                    ekorFrequencies[ekor] = (ekorFrequencies[ekor] || 0) + 1;
                }

                const sortedKepala = Object.keys(kepalaFrequencies).sort((a, b) => kepalaFrequencies[b] - kepalaFrequencies[a]).slice(0, 5).map(d => parseInt(d));
                const sortedEkor = Object.keys(ekorFrequencies).sort((a, b) => ekorFrequencies[b] - ekorFrequencies[a]).slice(0, 5).map(d => parseInt(d));

                let resultHTML = `<p>Kepala ${data[0].numbers.length === 5 ? &apos;D&apos; : &apos;C&apos;} (Top 5): <span style="color: #00ccff; font-weight: bold;">${sortedKepala.join(&apos;, &apos;)}</span></p>`;
                resultHTML += `<p>Ekor ${data[0].numbers.length === 5 ? &apos;E&apos; : &apos;D&apos;} (Top 5): <span style="color: #00ccff; font-weight: bold;">${sortedEkor.join(&apos;, &apos;)}</span></p>`;

                // Generate Top 10 Kombinasi
                const combinations = [];
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 2; j++) { // Ambil 2 teratas dari Ekor
                         combinations.push(`${sortedKepala[i]}${sortedEkor[j]}`);
                    }
                }
                
                resultHTML += `<h4 style="margin-top: 10px; color: #fff;">Kombinasi 2D (Top 10):</h4>`;
                resultHTML += `<div style="font-size: 1.1rem; font-weight: bold; color: #ff00ff;">${combinations.slice(0, 10).join(&apos; | &apos;)}</div>`;

                document.getElementById(&apos;prediction2D&apos;).innerHTML = resultHTML;
            }

            function generateBBFS(data) {
                if (data.length === 0) return;

                const globalFrequency = {};
                for (const item of data) {
                    for (const digit of item.numbers) {
                        globalFrequency[digit] = (globalFrequency[digit] || 0) + 1;
                    }
                }

                // Ambil 6 digit paling sering muncul
                const sortedDigits = Object.keys(globalFrequency)
                    .sort((a, b) => globalFrequency[b] - globalFrequency[a])
                    .slice(0, 6)
                    .map(d => parseInt(d));
                
                const bbfs5 = sortedDigits.slice(0, 5).join(&apos;&apos;);
                const bbfs6 = sortedDigits.join(&apos;&apos;);

                let resultHTML = `<p>BBFS 5 Digit: <span style="color: #ff00ff; font-weight: bold;">${bbfs5}</span></p>`;
                resultHTML += `<p>BBFS 6 Digit: <span style="color: #ff00ff; font-weight: bold;">${bbfs6}</span></p>`;

                document.getElementById(&apos;bbfs&apos;).innerHTML = resultHTML;
            }

            function generateOddEvenNumbers(data) {
                if (data.length === 0) return;
                
                const counts = { odd: 0, even: 0, big: 0, small: 0 };
                const totalDigits = data.length * data[0].numbers.length;

                for (const item of data) {
                    for (const digit of item.numbers) {
                        if (digit % 2 === 0) counts.even++; else counts.odd++;
                        if (digit >= 5) counts.big++; else counts.small++;
                    }
                }

                const oddPercentage = ((counts.odd / totalDigits) * 100).toFixed(1);
                const evenPercentage = ((counts.even / totalDigits) * 100).toFixed(1);
                const bigPercentage = ((counts.big / totalDigits) * 100).toFixed(1);
                const smallPercentage = ((counts.small / totalDigits) * 100).toFixed(1);

                let resultHTML = `<p style="color: #ffff00; font-weight: bold;">Ganjil/Genap:</p>`;
                resultHTML += `<p>Ganjil: ${counts.odd} (${oddPercentage}%) | Genap: ${counts.even} (${evenPercentage}%)</p>`;
                resultHTML += `<p style="color: #ffff00; font-weight: bold; margin-top: 10px;">Besar/Kecil:</p>`;
                resultHTML += `<p>Besar (5-9): ${counts.big} (${bigPercentage}%) | Kecil (0-4): ${counts.small} (${smallPercentage}%)</p>`;

                // Rekomendasi 
                const oeRec = counts.odd > counts.even ? &apos;Ganjil&apos; : &apos;Genap&apos;;
                const bsRec = counts.big > counts.small ? &apos;Besar&apos; : &apos;Kecil&apos;;
                resultHTML += `<h4 style="margin-top: 15px; color: #fff;">Rekomendasi Utama: <span style="color: #00ff00;">${oeRec} | ${bsRec}</span></h4>`;
                
                document.getElementById(&apos;oddEvenNumbers&apos;).innerHTML = resultHTML;
            }

            // --- REBOUND ANALYSIS FUNCTIONS (DILENGKAPI) ---

            function getBKPattern(numbers) {
                return numbers.map(num => num >= 5 ? &apos;B&apos; : &apos;K&apos;).join(&apos;&apos;);
            }

            function analyzeRebound() {
                const poolName = document.getElementById(&apos;reboundPoolSelect&apos;).value;
                if (!poolName) {
                    showNotification(&apos;Silakan pilih POOL terlebih dahulu!&apos;, &apos;error&apos;);
                    return;
                }

                const allData = currentData[poolName];
                if (!allData || allData.length < 50) {
                    showNotification(&apos;Data historis minimal 50 baris diperlukan untuk analisis Pola BK!&apos;, &apos;error&apos;);
                    return;
                }

                showLoading();

                setTimeout(() => {
                    const results = analyzeReboundData(allData);
                    lastReboundResults = results; // Store globally for Map Tab
                    displayReboundResults(results, poolName);
                    hideLoading();
                    showNotification(&apos;Analisis Pola BK berhasil diselesaikan!&apos;, &apos;success&apos;);
                }, 1000);
            }

            function analyzeReboundData(data) {
                const results = {}; // { day: { pattern: { count, dates, reboundTimes, avgRebound, daysSinceLast } } }
                const today = new Date();
                
                // Group all records by day of the week
                data.forEach(record => {
                    const date = parseDate(record.date);
                    if (!date) return;
                    
                    const dayName = getDayOfWeek(date).toLowerCase();
                    const pattern = getBKPattern(record.numbers);

                    if (!results[dayName]) {
                        results[dayName] = {};
                    }
                    if (!results[dayName][pattern]) {
                        results[dayName][pattern] = { 
                            count: 0, 
                            dates: [], 
                            reboundTimes: [], 
                            avgRebound: 0,
                            lastAppearance: null,
                            daysSinceLast: 0
                        };
                    }

                    results[dayName][pattern].count++;
                    results[dayName][pattern].dates.push(record.date);
                });

                // Calculate Rebound Time and Days Since Last
                Object.keys(results).forEach(day => {
                    Object.keys(results[day]).forEach(pattern => {
                        const patternData = results[day][pattern];
                        
                        // Sort dates chronologically
                        const sortedDates = patternData.dates.map(d => parseDate(d)).sort((a, b) => a - b);
                        
                        // 1. Calculate Rebound Times
                        for (let i = 1; i < sortedDates.length; i++) {
                            const diffTime = sortedDates[i] - sortedDates[i-1];
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                            if (diffDays > 0) {
                                patternData.reboundTimes.push(diffDays);
                            }
                        }
                        
                        // 2. Calculate Average Rebound
                        if (patternData.reboundTimes.length > 0) {
                            const sum = patternData.reboundTimes.reduce((a, b) => a + b, 0);
                            patternData.avgRebound = parseFloat((sum / patternData.reboundTimes.length).toFixed(1));
                        } else {
                            // If it only appeared once or twice, cannot calculate rebound.
                            patternData.avgRebound = 0;
                        }
                        
                        // 3. Calculate Days Since Last Appearance
                        if (sortedDates.length > 0) {
                            patternData.lastAppearance = sortedDates[sortedDates.length - 1];
                            const diffTime = today - patternData.lastAppearance;
                            patternData.daysSinceLast = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                            
                            // 4. Calculate Rebound Probability
                            if (patternData.avgRebound > 0) {
                                const ratio = patternData.daysSinceLast / patternData.avgRebound;
                                if (ratio >= 1.5) {
                                    patternData.probability = &apos;KRITIS&apos;;
                                } else if (ratio >= 0.8) {
                                    patternData.probability = &apos;TINGGI&apos;;
                                } else {
                                    patternData.probability = &apos;NORMAL&apos;;
                                }
                            } else {
                                patternData.probability = &apos;BARU&apos;;
                            }
                        }
                    });
                });
                
                return results;
            }

            function displayReboundResults(results, poolName) {
                const resultsContainer = document.getElementById(&apos;reboundResultsContainer&apos;);
                const summaryContent = document.getElementById(&apos;reboundSummaryContent&apos;);
                document.getElementById(&apos;reboundResults&apos;).style.display = &apos;block&apos;;
                document.getElementById(&apos;reboundFileInfo&apos;).textContent = `Pool: ${poolName}`;
                resultsContainer.innerHTML = &apos;&apos;;
                summaryContent.innerHTML = &apos;&apos;;

                const patternsToWatch = [];

                Object.keys(results).sort((a, b) => getDayIndex(a) - getDayIndex(b)).forEach(day => {
                    const dayData = results[day];
                    let dayHTML = `<h3 style="color: #00ff00; margin-top: 20px;">${day.toUpperCase()}</h3>`;
                    
                    const patterns = Object.keys(dayData).map(p => ({ pattern: p, ...dayData[p] }));
                    patterns.sort((a, b) => {
                        // Sort by probability (Kritis > Tinggi > Normal/Baru), then by count
                        const probOrder = { &apos;KRITIS&apos;: 3, &apos;TINGGI&apos;: 2, &apos;NORMAL&apos;: 1, &apos;BARU&apos;: 0 };
                        return probOrder[b.probability] - probOrder[a.probability] || b.count - a.count;
                    });

                    dayHTML += `<table class="history-table rebound">
                        <thead><tr><th>Pola</th><th>Frekuensi</th><th>Avg Rebound (Hari)</th><th>Hari Terakhir Muncul</th><th>Probabilitas Rebound</th></tr></thead><tbody>`;

                    patterns.forEach(item => {
                        let rowClass = &apos;&apos;;
                        if (item.probability === &apos;KRITIS&apos;) {
                            rowClass = &apos;style="background-color: rgba(255, 51, 0, 0.4);"&apos;;
                            patternsToWatch.push({ day: day, ...item });
                        } else if (item.probability === &apos;TINGGI&apos;) {
                            rowClass = &apos;style="background-color: rgba(255, 204, 0, 0.4);"&apos;;
                            patternsToWatch.push({ day: day, ...item });
                        }
                        
                        dayHTML += `<tr ${rowClass}>
                            <td>${item.pattern}</td>
                            <td>${item.count}</td>
                            <td>${item.avgRebound.toFixed(1)}</td>
                            <td>${item.daysSinceLast} Hari lalu</td>
                            <td style="font-weight: bold; color: ${item.probability === &apos;KRITIS&apos; ? &apos;#ff3300&apos; : (item.probability === &apos;TINGGI&apos; ? &apos;#ffcc00&apos; : &apos;#00ff00&apos;)}">${item.probability}</td>
                        </tr>`;
                    });

                    dayHTML += &apos;</tbody></table>&apos;;
                    resultsContainer.innerHTML += dayHTML;
                });
                
                // Display Summary
                patternsToWatch.sort((a, b) => {
                    const probOrder = { &apos;KRITIS&apos;: 3, &apos;TINGGI&apos;: 2 };
                    return probOrder[b.probability] - probOrder[a.probability] || b.daysSinceLast - a.daysSinceLast;
                });
                
                if (patternsToWatch.length > 0) {
                    let summaryHTML = `<ul style="list-style: none; padding-left: 0;">`;
                    patternsToWatch.slice(0, 10).forEach(item => {
                        summaryHTML += `<li style="margin-bottom: 8px; border-left: 3px solid ${item.probability === &apos;KRITIS&apos; ? &apos;#ff3300&apos; : &apos;#ffcc00&apos;}; padding-left: 10px;">
                            <strong>${item.pattern}</strong> (${item.day.toUpperCase()}): 
                            <span style="color: ${item.probability === &apos;KRITIS&apos; ? &apos;#ff3300&apos; : &apos;#ffcc00&apos;}; font-weight: bold;">${item.probability}</span>.
                            Sudah ${item.daysSinceLast} hari lalu (Avg: ${item.avgRebound.toFixed(1)} hari).
                        </li>`;
                    });
                    summaryHTML += `</ul>`;
                    summaryContent.innerHTML = summaryHTML;
                } else {
                    summaryContent.innerHTML = &apos;<p style="color: #00ff00;">Semua pola berada dalam batas normal (Normal/Baru).</p>&apos;;
                }
            }


            // --- MAP ANALYSIS FUNCTIONS (DILENGKAPI) ---

            function analyzeMap() {
                const poolName = document.getElementById(&apos;mapPoolSelect&apos;).value;
                if (!poolName) {
                    showNotification(&apos;Silakan pilih POOL terlebih dahulu!&apos;, &apos;error&apos;);
                    return;
                }

                showLoading();

                setTimeout(() => {
                    // Reuse results from analyzeRebound if available, otherwise run it
                    if (!lastReboundResults || Object.keys(lastReboundResults).length === 0) {
                        const allData = currentData[poolName];
                        if (!allData || allData.length < 50) {
                            hideLoading();
                            showNotification(&apos;Data historis minimal 50 baris diperlukan untuk Map Pola BK!&apos;, &apos;error&apos;);
                            return;
                        }
                        lastReboundResults = analyzeReboundData(allData);
                    }
                    
                    document.getElementById(&apos;mapResults&apos;).style.display = &apos;block&apos;;
                    displayMapResults(lastReboundResults, poolName);
                    hideLoading();
                    showNotification(&apos;Map Pola BK berhasil diselesaikan!&apos;, &apos;success&apos;);
                }, 1000);
            }

            function displayMapResults(results, poolName) {
                document.getElementById(&apos;mapFileInfo&apos;).textContent = `Pool: ${poolName}`;
                const heatmapDiv = document.getElementById(&apos;heatmap&apos;);
                const detailedResultsDiv = document.getElementById(&apos;detailedResults&apos;);
                const topReboundPatternsDiv = document.getElementById(&apos;topReboundPatterns&apos;);
                
                heatmapDiv.innerHTML = &apos;&apos;;
                detailedResultsDiv.innerHTML = &apos;&apos;;
                topReboundPatternsDiv.innerHTML = &apos;&apos;;

                const patternsToWatch = [];
                const daysOfWeek = [&apos;senin&apos;, &apos;selasa&apos;, &apos;rabu&apos;, &apos;kamis&apos;, &apos;jumat&apos;, &apos;sabtu&apos;, &apos;minggu&apos;];
                
                const allPatterns = new Set();
                daysOfWeek.forEach(day => {
                    if (results[day]) {
                        Object.keys(results[day]).forEach(p => allPatterns.add(p));
                    }
                });
                const sortedPatterns = Array.from(allPatterns).sort();

                // 1. Build Heatmap Header (Days)
                let headerHTML = `<div class="heatmap-cell header">Pola\\Hari</div>`;
                daysOfWeek.forEach(day => {
                    headerHTML += `<div class="heatmap-cell header" style="width: 100px;">${day.toUpperCase()}</div>`;
                });
                heatmapDiv.style.gridTemplateColumns = `120px repeat(${daysOfWeek.length}, 100px)`;
                heatmapDiv.innerHTML += headerHTML;
                
                // 2. Build Heatmap Body
                sortedPatterns.forEach(pattern => {
                    let rowHTML = `<div class="heatmap-cell header">${pattern}</div>`;
                    daysOfWeek.forEach(day => {
                        const data = results[day] && results[day][pattern];
                        let cellContent = &apos;N/A&apos;;
                        let cellClass = &apos;&apos;;
                        let cellTitle = &apos;&apos;;
                        
                        if (data && data.avgRebound > 0) {
                            const ratio = data.daysSinceLast / data.avgRebound;
                            cellContent = data.daysSinceLast;
                            cellTitle = `Avg: ${data.avgRebound.toFixed(1)} hari, Terakhir: ${data.daysSinceLast} hari lalu.`;

                            if (data.probability === &apos;KRITIS&apos;) {
                                cellClass = &apos;heatmap-high&apos;;
                                patternsToWatch.push({ pattern: pattern, day: day, ...data });
                            } else if (data.probability === &apos;TINGGI&apos;) {
                                cellClass = &apos;heatmap-medium&apos;;
                                patternsToWatch.push({ pattern: pattern, day: day, ...data });
                            } else {
                                cellClass = &apos;heatmap-low&apos;;
                            }
                        } else if (data) {
                            cellContent = &apos;BARU&apos;;
                        }

                        rowHTML += `<div class="heatmap-cell ${cellClass}" title="${cellTitle}">${cellContent}</div>`;
                    });
                    heatmapDiv.innerHTML += rowHTML;
                });
                
                // 3. Build Detailed Results
                let detailHTML = &apos;&apos;;
                daysOfWeek.forEach(day => {
                    detailHTML += `<h4 style="color: #00ff00; margin-top: 15px;">Detail ${day.toUpperCase()}</h4>`;
                    const dayData = results[day];
                    if (dayData) {
                        const patterns = Object.keys(dayData).map(p => ({ pattern: p, ...dayData[p] }));
                        patterns.sort((a, b) => b.count - a.count); // Sort by frequency
                        
                        detailHTML += `<ul style="list-style: none; padding-left: 10px;">`;
                        patterns.forEach(item => {
                             let color = item.probability === &apos;KRITIS&apos; ? &apos;#ff3300&apos; : (item.probability === &apos;TINGGI&apos; ? &apos;#ffcc00&apos; : &apos;#00ff00&apos;);
                             detailHTML += `<li style="margin-bottom: 5px;">
                                 <span style="font-weight: bold;">${item.pattern}</span>: Freq ${item.count}x, 
                                 <span style="color: ${color};">Rebound ${item.probability}</span> 
                                 (Avg ${item.avgRebound.toFixed(1)} hari, Terlambat ${item.daysSinceLast} hari)
                             </li>`;
                        });
                        detailHTML += `</ul>`;
                    } else {
                        detailHTML += &apos;<p>Tidak ada data untuk hari ini.</p>&apos;;
                    }
                });
                detailedResultsDiv.innerHTML = detailHTML;

                // 4. Build Top Rebound Patterns Summary (Same logic as Rebound Tab)
                patternsToWatch.sort((a, b) => {
                    const probOrder = { &apos;KRITIS&apos;: 3, &apos;TINGGI&apos;: 2 };
                    return probOrder[b.probability] - probOrder[a.probability] || b.daysSinceLast - a.daysSinceLast;
                });
                
                if (patternsToWatch.length > 0) {
                    let summaryHTML = `<ul style="list-style: none; padding-left: 0;">`;
                    patternsToWatch.slice(0, 10).forEach(item => {
                        summaryHTML += `<li style="margin-bottom: 8px; border-left: 3px solid ${item.probability === &apos;KRITIS&apos; ? &apos;#ff3300&apos; : &apos;#ffcc00&apos;}; padding-left: 10px;">
                            <strong>${item.pattern}</strong> (${item.day.toUpperCase()}): 
                            <span style="color: ${item.probability === &apos;KRITIS&apos; ? &apos;#ff3300&apos; : &apos;#ffcc00&apos;}; font-weight: bold;">${item.probability}</span>.
                            Sudah ${item.daysSinceLast} hari lalu (Avg: ${item.avgRebound.toFixed(1)} hari).
                        </li>`;
                    });
                    summaryHTML += `</ul>`;
                    topReboundPatternsDiv.innerHTML = summaryHTML;
                } else {
                    topReboundPatternsDiv.innerHTML = &apos;<p style="color: #00ff00;">Semua pola berada dalam batas normal.</p>&apos;;
                }
            }


            // --- Angka Tarung Functions (SUDAH LENGKAP) ---
            // (Semua fungsi Angka Tarung dipertahankan seperti pada jawaban sebelumnya)

            function calculateTopN(data, pos, N, weakNumbers, deadNumbers) {
                const frequency = {};
                for (const item of data) {
                    const digit = item.numbers[pos];
                    frequency[digit] = (frequency[digit] || 0) + 1;
                }

                const excludedNumbers = new Set([...weakNumbers, ...deadNumbers]);

                const sortedDigits = Object.keys(frequency)
                    .filter(digitStr => !excludedNumbers.has(parseInt(digitStr))) // Filter out weak/dead
                    .sort((a, b) => frequency[b] - frequency[a]); // Sort by highest frequency

                return sortedDigits.slice(0, N).map(d => parseInt(d));
            }

            function generateAngkaTarungTable() {
                const poolName = document.getElementById(&apos;tarungPoolSelect&apos;).value;
                const day = document.getElementById(&apos;tarungDaySelect&apos;).value;
                const N = parseInt(document.getElementById(&apos;topNSelect&apos;).value);

                if (!poolName || !day) {
                    showNotification(&apos;Silakan pilih POOL dan Hari terlebih dahulu!&apos;, &apos;error&apos;);
                    return;
                }
                if (isNaN(N) || N < 3 || N > 7) {
                    showNotification(&apos;Top N harus antara 3 hingga 7!&apos;, &apos;error&apos;);
                    return;
                }
                
                showLoading();
                
                setTimeout(() => {
                    const allData = currentData[poolName];
                    const filteredData = getFilteredData(poolName, day);
                    const dataToUse = filteredData.length > 5 ? filteredData : allData;

                    if (!dataToUse || dataToUse.length < 10) {
                        hideLoading();
                        showNotification(&apos;Data tidak cukup untuk analisis (Min 10 baris data)!&apos;, &apos;error&apos;);
                        return;
                    }

                    const digitCount = dataToUse[0].numbers.length;
                    const positions = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;];
                    const tableData = [];
                    currentTarungData = {}; // Reset global storage
                    currentTarungData.pool = poolName;
                    currentTarungData.day = day;
                    currentTarungData.date = new Date().toLocaleDateString(&apos;id-ID&apos;); // Today&apos;s date
                    currentTarungData.topN = N;
                    currentTarungData.positions = [];

                    for (let pos = 0; pos < digitCount; pos++) {
                        const posLetter = positions[pos];
                        const { weak, dead } = getWeakDeadNumbers(dataToUse, pos);
                        const topN = calculateTopN(dataToUse, pos, N, weak, dead);

                        tableData.push({
                            pos: posLetter + (pos === 4 ? &apos; Opt 5D&apos; : &apos;&apos;),
                            topN: topN.join(&apos;&apos;),
                            weak: weak.join(&apos;&apos;),
                            dead: dead.join(&apos;&apos;)
                        });
                        
                        currentTarungData.positions.push({
                            pos: posLetter,
                            topN: topN
                        });
                    }

                    // Display table
                    const resultDiv = document.getElementById(&apos;tarungTableResults&apos;);
                    resultDiv.style.display = &apos;block&apos;;
                    
                    const today = new Date();
                    const tableTitle = `<div class="card-title" style="color: #ff8c00; font-size: 1.2rem; margin-bottom: 10px;">Angka Tarung Untuk Pool: ${poolName} (${digitCount}D) - ${getDayOfWeek(today)} ${today.toLocaleDateString(&apos;id-ID&apos;)}</div>`;

                    const tableHTML = `
                        <table class="history-table tarung">
                            <thead>
                                <tr>
                                    <th>Posisi</th>
                                    <th>Top ${N}</th>
                                    <th>Angka Lemah (3)</th>
                                    <th>Angka Mati (2)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableData.map(row => `
                                    <tr>
                                        <td>${row.pos}</td>
                                        <td>${row.topN}</td>
                                        <td style="color: #ffcc00;">${row.weak}</td>
                                        <td style="color: #ff3366;">${row.dead}</td>
                                    </tr>
                                `).join(&apos;&apos;)}
                            </tbody>
                        </table>
                    `;
                    
                    resultDiv.innerHTML = tableTitle + tableHTML;
                    
                    // Show permutation button section
                    document.getElementById(&apos;tarungPermutationSection&apos;).style.display = &apos;block&apos;;
                    document.getElementById(&apos;tarungPermutationsOutput&apos;).style.display = &apos;none&apos;;

                    hideLoading();
                    showNotification(&apos;Tabel Angka Tarung berhasil di-generate!&apos;, &apos;success&apos;);
                }, 500);
            }

            function generateAngkaTarungPermutations() {
                if (!currentTarungData.pool) {
                    showNotification(&apos;Harap generate Tabel Angka Tarung terlebih dahulu!&apos;, &apos;error&apos;);
                    return;
                }
                
                showLoading();
                
                setTimeout(() => {
                    const poolName = currentTarungData.pool;
                    const day = currentTarungData.day;
                    const topNumbersByPos = currentTarungData.positions.map(p => p.topN);
                    const digitCount = topNumbersByPos.length;
                    
                    // 1. Dapatkan pola BK yang direkomendasikan
                    const recommendedPatterns = getRecommendedBKPattens(poolName, day);
                    if (recommendedPatterns.length === 0) {
                        hideLoading();
                        document.getElementById(&apos;tarungPermutationsOutput&apos;).textContent = `Pool: ${poolName} ${day}\n\nTidak ada pola BK yang sangat direkomendasikan (probabilitas rebound Tinggi/Sedang) untuk hari ini.`;
                        document.getElementById(&apos;tarungPermutationsOutput&apos;).style.display = &apos;block&apos;;
                        currentPermutationsOutput = document.getElementById(&apos;tarungPermutationsOutput&apos;).textContent;
                        return;
                    }
                    
                    let output = `Pool: ${poolName} ${day} ${currentTarungData.date}\n`;
                    let allNumbers = &apos;&apos;;
                    
                    // 2. Loop melalui pola yang direkomendasikan dan generate permutasi
                    for (const pattern of recommendedPatterns) {
                        // Hanya proses pola yang memiliki jumlah digit yang sama
                        if (pattern.pattern.length !== digitCount) continue;
                        
                        output += `\n======================================================\n`;
                        output += `Pola BK Rebound: ${pattern.pattern} (Probabilitas ${pattern.probability})\n`;
                        output += `------------------------------------------------------\n`;
                        
                        // Fungsi untuk menghasilkan angka tarung yang difilter pola BK
                        const combinations = generateCombinations(topNumbersByPos, pattern.pattern, 50); // Batasi 50 kombinasi per pola

                        if (combinations.length === 0) {
                            output += `Tidak ada kombinasi angka Top N yang cocok dengan pola BK ${pattern.pattern}.\n`;
                        } else {
                            output += combinations.join(&apos;*&apos;) + &apos;...\n&apos;;
                            allNumbers += combinations.join(&apos;*&apos;) + &apos;\n&apos;;
                        }
                    }

                    currentPermutationsOutput = output;
                    document.getElementById(&apos;tarungPermutationsOutput&apos;).textContent = output;
                    document.getElementById(&apos;tarungPermutationsOutput&apos;).style.display = &apos;block&apos;;
                    
                    hideLoading();
                    showNotification(&apos;Permutasi Angka Tarung berhasil di-generate!&apos;, &apos;success&apos;);
                }, 1000);
            }

            // Helper: Generate combinations matching BK pattern
            function generateCombinations(topNumbersByPos, pattern, limit) {
                const result = [];
                const len = topNumbersByPos.length;
                if (len !== pattern.length) return [];
                
                // Max 1000 iterations to prevent freezing
                let attempts = 0;
                while (result.length < limit && attempts < 1000) {
                    let combination = &apos;&apos;;
                    let matches = true;
                    
                    for (let i = 0; i < len; i++) {
                        const numbers = topNumbersByPos[i];
                        if (numbers.length === 0) {
                            matches = false;
                            break;
                        }
                        
                        // Pilih angka acak dari Top N
                        const selectedDigit = numbers[Math.floor(Math.random() * numbers.length)];
                        
                        // Cek apakah digit cocok dengan pola BK
                        const isBig = selectedDigit >= 5;
                        const requiredPattern = pattern[i];

                        if ((requiredPattern === &apos;B&apos; && !isBig) || (requiredPattern === &apos;K&apos; && isBig)) {
                            // Coba lagi dengan angka Top N lainnya (jika ada)
                            let found = false;
                            for (const digit of numbers) {
                                const checkBig = digit >= 5;
                                if ((requiredPattern === &apos;B&apos; && checkBig) || (requiredPattern === &apos;K&apos; && !checkBig)) {
                                    combination += digit.toString();
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                matches = false;
                                break;
                            }
                        } else {
                             combination += selectedDigit.toString();
                        }
                    }
                    
                    if (matches && combination.length === len && !result.includes(combination)) {
                        result.push(combination);
                    }
                    
                    attempts++;
                }

                return result;
            }

            // Helper: Get Recommended BK Patterns (Simplified Rebound Analysis)
            function getRecommendedBKPattens(poolName, day) {
                const allData = currentData[poolName];
                const targetDayIndex = getDayIndex(day);
                const today = new Date();
                
                if (!allData || allData.length < 50) return []; // Minimal 50 data untuk analisis rebound

                // 1. Hitung frekuensi pola, rebound time, dan tanggal terakhir muncul
                const patternsData = {}; // { pattern: { count, dates: [], avg, lastAppearance } }

                allData.forEach(record => {
                    const date = parseDate(record.date);
                    if (!date || date.getDay() !== targetDayIndex) return; // Hanya data hari yang sama

                    const pattern = getBKPattern(record.numbers);
                    const dateStr = record.date;

                    if (!patternsData[pattern]) {
                        patternsData[pattern] = { count: 0, dates: [], avg: 0 };
                    }
                    patternsData[pattern].count++;
                    patternsData[pattern].dates.push(dateStr);
                });
                
                const patternsToAnalyze = Object.keys(patternsData);
                const results = [];

                patternsToAnalyze.forEach(pattern => {
                    const dates = patternsData[pattern].dates.map(d => parseDate(d)).sort((a, b) => a - b);
                    patternsData[pattern].lastAppearance = dates.length > 0 ? dates[dates.length - 1] : null;

                    let reboundTimes = [];
                    for (let i = 1; i < dates.length; i++) {
                        const prevDate = dates[i-1];
                        const currDate = dates[i];
                        const diffTime = Math.abs(currDate - prevDate);
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        if (diffDays > 0) {
                            reboundTimes.push(diffDays);
                        }
                    }

                    const avgRebound = reboundTimes.length > 0 ? reboundTimes.reduce((a, b) => a + b, 0) / reboundTimes.length : 0;
                    patternsData[pattern].avg = avgRebound;

                    if (avgRebound > 0 && patternsData[pattern].lastAppearance) {
                        const lastDate = patternsData[pattern].lastAppearance;
                        const diffTime = Math.abs(today - lastDate);
                        const daysSinceLast = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                        const ratio = daysSinceLast / avgRebound;
                        let probability = &apos;rendah&apos;;

                        if (ratio >= 1.5) {
                            probability = &apos;KRITIS&apos;;
                        } else if (ratio >= 0.8) {
                            probability = &apos;TINGGI&apos;;
                        }

                        if (probability !== &apos;rendah&apos;) {
                            results.push({
                                pattern: pattern,
                                probability: probability,
                                avgRebound: avgRebound,
                                daysSinceLast: daysSinceLast
                            });
                        }
                    }
                });

                // Urutkan: Kritis -> Tinggi, kemudian yang paling lama belum muncul
                results.sort((a, b) => {
                    const probOrder = { &apos;KRITIS&apos;: 3, &apos;TINGGI&apos;: 2 };
                    return probOrder[b.probability] - probOrder[a.probability] || b.daysSinceLast - a.daysSinceLast;
                });

                return results;
            }

            function copyAngkaTarung() {
                if (!currentPermutationsOutput) {
                    showNotification(&apos;Tidak ada hasil permutasi untuk disalin!&apos;, &apos;error&apos;);
                    return;
                }
                
                navigator.clipboard.writeText(currentPermutationsOutput).then(() => {
                    showNotification(&apos;Hasil Angka Tarung berhasil disalin ke clipboard!&apos;, &apos;success&apos;);
                }).catch(err => {
                    showError(&apos;Gagal menyalin: &apos; + err);
                });
            }

            function saveAngkaTarung() {
                if (!currentPermutationsOutput) {
                    showNotification(&apos;Tidak ada hasil permutasi untuk disimpan!&apos;, &apos;error&apos;);
                    return;
                }
                
                const poolName = currentTarungData.pool;
                const day = currentTarungData.day;
                const date = currentTarungData.date.replace(/\//g, &apos;-&apos;);
                const filename = `AngkaTarung_${poolName}_${day}_${date}.txt`;
                
                const blob = new Blob([currentPermutationsOutput], { type: &apos;text/plain&apos; });
                const url = URL.createObjectURL(blob);
                const a = document.createElement(&apos;a&apos;);
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showNotification(&apos;Hasil Angka Tarung berhasil disimpan sebagai file text!&apos;, &apos;success&apos;);
            }
            
            // --- UTILITY & DATA MANAGEMENT FUNCTIONS (DIJAGA KONSISTEN) ---

            function handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result;
                    processFileContent(file.name, content);
                };
                reader.readAsText(file);
            }

            function processFileContent(fileName, content) {
                showLoading();
                setTimeout(() => {
                    const lines = content.trim().split(&apos;\n&apos;);
                    const data = [];
                    let dataType = 0; // 0=unknown, 4=4D, 5=5D
                    let firstError = null;

                    for (const [index, line] of lines.entries()) {
                        const parts = line.split(&apos;,&apos;);
                        if (parts.length < 2) continue; // Skip empty or invalid lines

                        const datePart = parts[0].trim();
                        const numberParts = parts.slice(1).map(n => parseInt(n.trim(), 10)).filter(n => !isNaN(n));
                        
                        // Basic date validation (d/m/y format with slashes)
                        const dateRegex = /^\d{1,2}\/\d{1,2}\/\d{4}$/;
                        if (!dateRegex.test(datePart)) {
                            firstError = `Baris ${index + 1}: Format tanggal (${datePart}) tidak valid (harus dd/mm/yyyy).`;
                            continue;
                        }

                        if (numberParts.length < 4) {
                            firstError = `Baris ${index + 1} tidak memiliki minimal 4 angka.`;
                            continue;
                        }
                        
                        if (dataType === 0) {
                            dataType = numberParts.length;
                        } else if (dataType !== numberParts.length) {
                             firstError = `Baris ${index + 1} memiliki jumlah angka berbeda dari baris sebelumnya (${numberParts.length}D vs ${dataType}D).`;
                             continue;
                        }

                        data.push({
                            date: datePart,
                            numbers: numberParts
                        });
                    }

                    if (firstError) {
                        hideLoading();
                        showError(&apos;Gagal memproses file: &apos; + firstError);
                        return;
                    }
                    
                    if (data.length === 0) {
                         hideLoading();
                         showError(&apos;Gagal memproses file: Tidak ada data valid ditemukan.&apos;);
                         return;
                    }

                    const poolName = fileName.replace(&apos;.txt&apos;, &apos;&apos;).replace(&apos;.TXT&apos;, &apos;&apos;).replace(/ /g, &apos;_&apos;);
                    localStorage.setItem(`pool_${poolName}`, JSON.stringify(data));
                    currentData[poolName] = data;
                    currentPool = poolName;

                    loadSavedFiles();
                    updatePoolSelects();
                    displayRecentHistory(poolName);

                    hideLoading();
                    showNotification(`File ${fileName} berhasil diimpor dan disimpan sebagai POOL: ${poolName}`, &apos;success&apos;);
                }, 500);
            }

            function loadSavedFiles() {
                const savedFilesDiv = document.getElementById(&apos;savedFiles&apos;);
                savedFilesDiv.innerHTML = &apos;&apos;;

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith(&apos;pool_&apos;)) {
                        const fileName = key.replace(&apos;pool_&apos;, &apos;&apos;);
                        const data = JSON.parse(localStorage.getItem(key));
                        currentData[fileName] = data; // Ensure currentData is populated
                        
                        const fileItem = document.createElement(&apos;div&apos;);
                        fileItem.className = &apos;file-item&apos;;
                        fileItem.innerHTML = `
                            <div class="file-name">${fileName} (${data.length} baris)</div>
                            <div class="file-actions">
                                <button class="btn mini-btn" onclick="loadFile(&apos;${fileName}&apos;)">Load</button>
                                <button class="btn mini-btn" onclick="editFile(&apos;${fileName}&apos;)">Edit</button>
                                <button class="btn mini-btn btn-danger" onclick="deleteFile(&apos;${fileName}&apos;)">Hapus</button>
                            </div>
                        `;
                        savedFilesDiv.appendChild(fileItem);
                    }
                }

                if (savedFilesDiv.children.length === 0) {
                    savedFilesDiv.innerHTML = &apos;<p style="text-align: center; opacity: 0.7;">Belum ada file tersimpan</p>&apos;;
                }
            }

            function loadFile(fileName) {
                const data = JSON.parse(localStorage.getItem(`pool_${fileName}`));
                if (data) {
                    currentData[fileName] = data;
                    currentPool = fileName;
                    displayRecentHistory(fileName);
                    updatePoolSelects();
                    showNotification(`File ${fileName} berhasil dimuat!`, &apos;success&apos;);
                }
            }

            function editFile(fileName) {
                const data = JSON.parse(localStorage.getItem(`pool_${fileName}`));
                if (data) {
                    editingFileName = fileName;
                    let textContent = &apos;&apos;;
                    for (const item of data) {
                        textContent += `${item.date},${item.numbers.join(&apos;,&apos;)}\n`;
                    }
                    document.getElementById(&apos;dataEditor&apos;).value = textContent;
                    document.getElementById(&apos;editModal&apos;).style.display = &apos;flex&apos;;
                }
            }

            function closeEditModal() {
                document.getElementById(&apos;editModal&apos;).style.display = &apos;none&apos;;
            }

            function saveEditedData() {
                const textContent = document.getElementById(&apos;dataEditor&apos;).value;
                const lines = textContent.trim().split(&apos;\n&apos;);
                const data = [];
                let dataType = 0;
                let firstError = null;

                for (const [index, line] of lines.entries()) {
                    const parts = line.split(&apos;,&apos;);
                    if (parts.length < 2) continue;

                    const datePart = parts[0].trim();
                    const numberParts = parts.slice(1).map(n => parseInt(n.trim(), 10)).filter(n => !isNaN(n));
                    
                    const dateRegex = /^\d{1,2}\/\d{1,2}\/\d{4}$/;
                    if (!dateRegex.test(datePart)) {
                        firstError = `Baris ${index + 1}: Format tanggal (${datePart}) tidak valid (harus dd/mm/yyyy).`;
                        continue;
                    }

                    if (numberParts.length < 4) {
                        firstError = `Baris ${index + 1} tidak memiliki minimal 4 angka.`;
                        continue;
                    }
                    
                    if (dataType === 0) {
                        dataType = numberParts.length;
                    } else if (dataType !== numberParts.length) {
                            firstError = `Baris ${index + 1} memiliki jumlah angka berbeda dari baris sebelumnya.`;
                            continue;
                    }

                    data.push({
                        date: datePart,
                        numbers: numberParts
                    });
                }
                
                if (firstError) {
                    showError(&apos;Gagal menyimpan data: &apos; + firstError);
                    return;
                }

                if (data.length === 0) {
                    showError(&apos;Gagal menyimpan data: Tidak ada data valid ditemukan.&apos;);
                    return;
                }

                localStorage.setItem(`pool_${editingFileName}`, JSON.stringify(data));
                currentData[editingFileName] = data;
                currentPool = editingFileName;
                displayRecentHistory(editingFileName);
                loadSavedFiles(); // Refresh list count
                closeEditModal();
                showNotification(`Data untuk ${editingFileName} berhasil disimpan!`, &apos;success&apos;);
            }

            function deleteFile(fileName) {
                if (confirm(`Yakin ingin menghapus file POOL: ${fileName}?`)) {
                    localStorage.removeItem(`pool_${fileName}`);
                    delete currentData[fileName];
                    if (currentPool === fileName) {
                        currentPool = &apos;&apos;;
                        document.getElementById(&apos;recentHistory&apos;).innerHTML = &apos;<p style="text-align: center; opacity: 0.7;">Belum ada data yang dimuat</p>&apos;;
                    }
                    loadSavedFiles();
                    updatePoolSelects();
                    showNotification(`File ${fileName} berhasil dihapus!`, &apos;info&apos;);
                }
            }

            function displayRecentHistory(poolName) {
                const data = currentData[poolName];
                const recentHistoryDiv = document.getElementById(&apos;recentHistory&apos;);
                
                if (!data || data.length === 0) {
                    recentHistoryDiv.innerHTML = &apos;<p style="text-align: center; opacity: 0.7;">Belum ada data yang dimuat</p>&apos;;
                    return;
                }

                const table = document.createElement(&apos;table&apos;);
                table.className = &apos;history-table&apos;;

                const header = document.createElement(&apos;thead&apos;);
                header.innerHTML = &apos;<tr><th>Tanggal</th>&apos;;
                const maxDigits = data[0].numbers.length || 4;
                for (let i = 0; i < maxDigits; i++) {
                    const letter = String.fromCharCode(65 + i);
                    header.innerHTML += `<th>${letter}</th>`;
                }
                header.innerHTML += &apos;</tr>&apos;;
                table.appendChild(header);

                // Sort data by date to get the most recent entries
                const sortedData = [...data].sort((a, b) => parseDate(b.date) - parseDate(a.date));

                // Get the 10 most recent entries
                const recentData = sortedData.slice(0, 10);
                
                const currentYear = new Date().getFullYear();
                const body = document.createElement(&apos;tbody&apos;);

                for (const item of recentData) {
                    const row = document.createElement(&apos;tr&apos;);
                    
                    const parts = item.date.split(&apos;/&apos;);
                    const year = parseInt(parts[2]);

                    const isNewData = year >= currentYear;
                    if (isNewData) {
                        row.className = &apos;highlight-new&apos;;
                    }

                    row.innerHTML = `<td>${item.date}</td>`;
                    for (const num of item.numbers) {
                        row.innerHTML += `<td class="pattern-cell">${num}</td>`;
                    }
                    body.appendChild(row);
                }

                table.appendChild(body);
                recentHistoryDiv.innerHTML = &apos;&apos;;
                recentHistoryDiv.appendChild(table);

                // Add a note about the data
                const note = document.createElement(&apos;p&apos;);
                note.style.marginTop = &apos;10px&apos;;
                note.style.fontSize = &apos;0.9rem&apos;;
                note.style.opacity = &apos;0.7&apos;;
                note.textContent = `Pool: ${poolName} (${data[0].numbers.length}D) - Total data: ${data.length} baris`;
                recentHistoryDiv.appendChild(note);
            }

            function updatePoolSelects() {
                const selects = document.querySelectorAll(&apos;#poolSelect, #reboundPoolSelect, #mapPoolSelect, #tarungPoolSelect&apos;);
                const poolNames = Object.keys(currentData);

                selects.forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = &apos;<option value="">-- Pilih POOL --</option>&apos;;
                    poolNames.forEach(poolName => {
                        const option = document.createElement(&apos;option&apos;);
                        option.value = poolName;
                        option.textContent = poolName;
                        select.appendChild(option);
                    });
                    // Restore previously selected value if it still exists
                    if (poolNames.includes(currentValue)) {
                        select.value = currentValue;
                    } else if (currentPool && poolNames.includes(currentPool)) {
                        select.value = currentPool;
                    }
                });
            }

            function parseDate(dateString) {
                const parts = dateString.split(&apos;/&apos;);
                if (parts.length !== 3) return null;
                // Date format is DD/MM/YYYY, JavaScript Date expects YYYY, MM-1, DD. Use UTC to prevent timezone issues.
                const date = new Date(Date.UTC(parts[2], parts[1] - 1, parts[0]));
                // Check if the date is actually valid
                return isNaN(date.getTime()) ? null : date;
            }

            function getDayOfWeek(dateObj) {
                const dayIndex = dateObj.getDay(); // 0 is Sunday, 6 is Saturday
                const days = [&apos;Minggu&apos;, &apos;Senin&apos;, &apos;Selasa&apos;, &apos;Rabu&apos;, &apos;Kamis&apos;, &apos;Jumat&apos;, &apos;Sabtu&apos;];
                return days[dayIndex];
            }

            function getDayIndex(dayName) {
                const days = {
                    &apos;minggu&apos;: 0, &apos;senin&apos;: 1, &apos;selasa&apos;: 2, &apos;rabu&apos;: 3, &apos;kamis&apos;: 4, &apos;jumat&apos;: 5, &apos;sabtu&apos;: 6
                };
                return days[dayName.toLowerCase()];
            }

            function getFilteredData(poolName, day) {
                const allData = currentData[poolName];
                if (!allData) return [];

                if (!day || day === &apos;all&apos;) return allData;

                const targetDayIndex = getDayIndex(day);

                return allData.filter(item => {
                    const dateObj = parseDate(item.date);
                    if (!dateObj) {
                        return false;
                    }
                    return dateObj.getDay() === targetDayIndex;
                });
            }

            function showLoading() {
                document.getElementById(&apos;loading&apos;).style.display = &apos;flex&apos;;
                document.getElementById(&apos;errorMessage&apos;).style.display = &apos;none&apos;;
            }

            function hideLoading() {
                document.getElementById(&apos;loading&apos;).style.display = &apos;none&apos;;
            }

            function showError(message) {
                const errorElement = document.getElementById(&apos;errorMessage&apos;);
                errorElement.textContent = message;
                errorElement.style.display = &apos;block&apos;;
            }

            function showNotification(message, type) {
                const notification = document.createElement(&apos;div&apos;);
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.opacity = &apos;0&apos;;
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 300);
                }, 3000);
            }
            
        </script>
</body>
</html>' frameborder="0" style="width:100%;height:calc(100vh - 80px);border:none;"></iframe>
    </section>
    
    
    <section id="pageGPTPro" class="spa-page" style="display:none;">
        <iframe srcdoc='<!DOCTYPE html>
<html lang="id">
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#b36ff6">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPT Pro V1.6</title>
    <!-- Font Orbitron untuk tema futuristic -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* =================================================================
           GLOBAL STYLES & CSS VARIABLES
        ================================================================= */
        :root {
            --bg-color: #0a0a0a;
            --container-bg: rgba(15, 15, 25, 0.9);
            --text-color: #e0e0e0;
            --neon-cyan: #00ffff;
            --neon-magenta: #ff00ff;
            --neon-yellow: #ffff00;
            --input-bg: rgba(10, 10, 20, 0.7);
            --border-color: #333;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: &apos;Orbitron&apos;, sans-serif;
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 0, 255, 0.1) 0%, transparent 50%);
            color: var(--text-color);
            min-height: 100vh;
        }

        /* =================================================================
           LAYOUT & NAVIGATION
        ================================================================= */
        .main-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background: var(--container-bg);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding: 20px;
            text-align: center;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.2);
        }

        header h1 {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan), 0 0 20px var(--neon-cyan), 0 0 30px var(--neon-cyan);
            letter-spacing: 3px;
            margin-bottom: 20px;
        }

        nav {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: transparent;
            border: 2px solid var(--neon-magenta);
            color: var(--neon-magenta);
            padding: 10px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-family: &apos;Orbitron&apos;, sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            color: var(--bg-color);
            background: var(--neon-magenta);
            box-shadow: 0 0 20px var(--neon-magenta);
            transform: scale(1.05);
        }

        .nav-btn.active {
            color: var(--bg-color);
            background: var(--neon-cyan);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px var(--neon-cyan);
        }

        main {
            flex-grow: 1;
            padding: 20px;
        }

        .page-content {
            display: none; /* Semua halaman disembunyikan secara default */
        }

        .page-content.active {
            display: block; /* Hanya halaman aktif yang ditampilkan */
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* =================================================================
           REUSABLE COMPONENT STYLES
        ================================================================= */
        .card {
            background: var(--container-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.2), inset 0 0 15px rgba(0, 255, 255, 0.05);
        }

        h2, h3, h4 {
            font-weight: 700;
            margin-bottom: 10px;
        }

        h2 {
            color: var(--neon-magenta);
            text-shadow: 0 0 8px var(--neon-magenta);
            font-size: 1.5rem;
        }

        h3 {
            color: var(--neon-magenta);
            text-shadow: 0 0 8px var(--neon-magenta);
            border-bottom: 2px solid rgba(255, 0, 255, 0.2);
            padding-bottom: 5px;
        }

        h4 {
            color: var(--neon-yellow);
            text-shadow: 0 0 8px var(--neon-yellow);
        }

        label {
            display: block;
            margin: 10px 0 5px 0;
            color: var(--neon-yellow);
            font-weight: 700;
            text-shadow: 0 0 5px var(--neon-yellow);
        }

        input[type="file"], select, input[type="date"], input[type="number"], textarea {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.4);
            background: var(--input-bg);
            color: #ffffff;
            font-family: &apos;Courier New&apos;, monospace;
            transition: all 0.3s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--neon-yellow);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.4);
        }

        button {
            background: transparent;
            border: 2px solid var(--neon-cyan);
            color: var(--neon-cyan);
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-family: &apos;Orbitron&apos;, sans-serif;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            margin-right: 6px;
        }

        button:hover {
            color: var(--bg-color);
            background: var(--neon-cyan);
            box-shadow: 0 0 20px var(--neon-cyan);
            transform: scale(1.05);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        button:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        button.ghost {
            border-color: var(--neon-magenta);
            color: var(--neon-magenta);
        }
        button.ghost:hover {
            background: var(--neon-magenta);
            box-shadow: 0 0 20px var(--neon-magenta);
        }

        button.warn {
            border-color: var(--neon-yellow);
            color: var(--neon-yellow);
        }
        button.warn:hover {
            background: var(--neon-yellow);
            box-shadow: 0 0 20px var(--neon-yellow);
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        pre.small {
            white-space: pre-wrap;
            word-break: break-word;
            background: var(--input-bg);
            padding: 12px;
            border-radius: 8px;
            color: var(--neon-cyan);
            border: 1px solid rgba(0, 255, 255, 0.2);
            font-family: &apos;Courier New&apos;, monospace;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 8px;
        }

        th, td {
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: left;
            font-size: 13px;
        }

        th {
            background: rgba(0, 255, 255, 0.1);
            color: var(--neon-cyan);
            font-weight: 700;
        }

        .ok {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
            font-weight: 600;
            text-shadow: 0 0 5px #00ff00;
        }

        .bad {
            background: rgba(255, 0, 0, 0.2);
            color: #ff4d4d;
            font-weight: 600;
            text-shadow: 0 0 5px #ff4d4d;
        }

        .badge {
            display: inline-block;
            padding: 6px 10px;
            border-radius: 20px;
            background: rgba(255, 0, 255, 0.2);
            color: var(--neon-magenta);
            margin-right: 6px;
            border: 1px solid var(--neon-magenta);
        }

        .smallmuted, .muted {
            color: #93b5d1;
            font-size: 13px;
        }

        .file-list {
            max-height: 200px;
            overflow: auto;
            padding: 10px;
            border-radius: 8px;
            border: 1px dashed rgba(0, 255, 255, 0.3);
            background: var(--input-bg);
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 900px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        #editModal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(2, 6, 12, 0.9);
            padding: 20px;
            z-index: 9999;
            backdrop-filter: blur(5px);
        }

        #editModal > div {
            max-width: 900px;
            margin: 40px auto;
            background: var(--container-bg);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid var(--neon-cyan);
        }

        #editModal h3 {
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        
        /* Style for Analisa Page */
        #status-analisa {
            margin-top: 10px;
            color: var(--neon-yellow);
            font-weight: 700;
        }

        /* =================================================================
           DASHBOARD PAGE SPECIFIC STYLES
        ================================================================= */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .chart-container {
            background: var(--input-bg);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        .bar-chart {
            list-style: none;
            padding: 0;
        }

        .bar-chart li {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .bar-chart .label {
            width: 25px;
            font-weight: bold;
            color: var(--neon-yellow);
        }

        .bar-chart .bar-wrapper {
            flex-grow: 1;
            background: rgba(255, 255, 255, 0.05);
            height: 20px;
            border-radius: 10px;
            margin: 0 10px;
            position: relative;
            overflow: hidden;
        }

        .bar-chart .bar {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-magenta));
            border-radius: 10px;
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px var(--neon-cyan);
        }

        .bar-chart .value {
            font-size: 0.8rem;
            color: #fff;
        }

        .heatmap-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            font-family: monospace;
            font-size: 0.8rem;
            max-width: 400px; /* Ukuran maksimal responsif */
            aspect-ratio: 1; /* Menjaga bentuk persegi */
            margin: 0 auto; /* Menengahkan */
        }

        .heatmap-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .heatmap-cell:hover {
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 0 10px #fff;
        }

    
/* MATRIX BACKGROUND CANVAS */
#matrixBg{
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    mix-blend-mode: screen;
    pointer-events: none;
    opacity: 0.9;
    filter: blur(0.6px) saturate(1.2);
}

/* Neon background transition and glow */
:root {
    --menu-bg-color: #0a0a0a;
    --glow-color: rgba(179,111,246,0.12);
}
.main-container, body {
    transition: background 1.5s ease, box-shadow 1.5s ease;
    background: radial-gradient(circle at 30% 30%, rgba(0,0,0,0.35), transparent 30%), var(--menu-bg-color);
    box-shadow: 0 0 80px var(--glow-color) inset;
}

/* additional subtle overlay to emphasize glow */
#matrixOverlayGlow {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    mix-blend-mode: screen;
    opacity: 0.12;
    transition: background 1.5s ease, opacity 1.5s ease;
}

/* ensure app content is above */
.main-container { position: relative; z-index: 1; }

/* nav button highlight uses glow color variable */
.nav-btn {
    transition: transform .25s ease, box-shadow .6s ease, background .4s ease, color .4s ease;
}

</style>
</head>
<body>
    <canvas id="matrixBg"></canvas>
    <div id="matrixOverlayGlow"></div>

    <div class="main-container">
        <header>
            <h1>GPT Pro V1.4</h1>
            <nav>
                <button class="nav-btn active" data-target="pageDashboard">DASHBOARD</button>
                <button class="nav-btn" data-target="pageAnalisa">ANALISA</button>
                <button class="nav-btn" data-target="pagePermutasi">PERMUTASI</button>
                <button class="nav-btn" data-target="pageAtar">ATAR</button>
                <button class="nav-btn" data-target="pagePrediksi">PREDIKSI</button>
            </nav>
        </header>

        <main>
            <!-- =================================================================
                 PAGE 0: DASHBOARD GLOBAL
            ================================================================= -->
            <div id="pageDashboard" class="page-content active">
                <div class="card">
                    <h2> Dashboard Global</h2>
                    <p class="muted">Gambaran umum dari semua data POOL yang tersimpan. Klik "Refresh Data" untuk memperbarui.</p>
                    <button id="refreshDashboardBtn" class="ghost">Refresh Data</button>
                </div>

                <div class="dashboard-grid">
                    <div class="card">
                        <h3>Statistik Pool</h3>
                        <div id="poolStatsContainer">
                            <p class="muted">Memuat data...</p>
                        </div>
                    </div>
                    <div class="card">
                        <h3>Frekuensi Digit Global (0-9)</h3>
                        <div id="digitFreqContainer" class="chart-container">
                            <p class="muted">Memuat data...</p>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>Peta Panas 2D Global (00-99)</h3>
                    <p class="muted">Semakin terang, semakin sering muncul. Hover untuk melihat detail.</p>
                    <div id="heatmap2DContainer" class="chart-container">
                        <p class="muted">Memuat data...</p>
                    </div>
                </div>
            </div>

            <!-- =================================================================
                 PAGE 1: ANALISA
            ================================================================= -->
            <div id="pageAnalisa" class="page-content">
                <div class="card">
                    <h2> Analisis Data POOL Harian</h2>
                    <p>Pilih POOL yang sudah di-upload di menu ATAR untuk dianalisis. Sistem akan otomatis mengidentifikasi 4D/5D.</p>
                    
                    <label for="poolSelectAnalisa">Pilih POOL untuk dianalisis:</label>
                    <select id="poolSelectAnalisa">
                        <option value="">-- Pilih Pool --</option>
                    </select>
                    
                    <button id="prosesFilesAnalisaBtn">Mulai Analisis</button>
                    <p id="status-analisa"></p>
                </div>
                <div class="card">
                    <h2>Hasil Analisis Gabungan</h2>
                    <div id="outputAnalisa">Hasil akan ditampilkan di sini setelah proses selesai...</div>
                </div>
            </div>

            <!-- =================================================================
                 PAGE 2: PERMUTASI
            ================================================================= -->
            <div id="pagePermutasi" class="page-content">
                <div class="card">
                    <h2>PERMUTASI 4D</h2>
                    <div class="row" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); display: grid;">
                        <div class="input-group">
                            <label for="inputAB">
                                <input type="checkbox" id="checkAB" checked>
                                AB
                            </label>
                            <textarea id="inputAB" placeholder="Contoh: 30*14*26*42*59*60*62*69*70*76*80*88*90*96"></textarea>
                        </div>
                        <div class="input-group">
                            <label for="inputCD">
                                <input type="checkbox" id="checkCD" checked>
                                CD/DE
                            </label>
                            <textarea id="inputCD" placeholder="Contoh: 12*13*17*50*61*62*63*74*75*76*77*83*84*88*00"></textarea>
                        </div>
                        <div class="input-group">
                            <label for="inputBK">
                                <input type="checkbox" id="checkBK">
                                2D Belum Keluar
                            </label>
                            <textarea id="inputBK" placeholder="Contoh: 07*08*22*25*31*32*48*49*51*64*86"></textarea>
                        </div>
                    </div>
                    <div class="row" style="justify-content: center; margin-top: 20px;">
                        <button id="generateBtn">Hasilkan 4D</button>
                        <button id="bbfsBtn" class="ghost">4D BBFS</button>
                    </div>
                </div>
                <div class="card">
                    <h2>HASIL</h2>
                    <textarea id="outputPermutasi" readonly placeholder="Hasil akan ditampilkan di sini..."></textarea>
                    <div class="row" style="justify-content: center; margin-top: 15px;">
                        <button id="copyBtn" class="ghost">Salin</button>
                        <button id="exportBtn" class="ghost">Eksport ke Text</button>
                    </div>
                </div>
            </div>

            <!-- =================================================================
                 PAGE 3: ATAR
            ================================================================= -->
            <div id="pageAtar" class="page-content">
                <div class="card">
                    <h1>DATA ANALISIS</h1>
                    <div class="smallmuted">Upload file .txt (format dd/mm/yyyy,<em>digits</em>). File disimpan ke <strong>localStorage</strong>.</div>
                </div>

                <div class="grid">
                    <div class="card">
                        <h2>1) Data Management</h2>
                        <label>Upload file .txt (bisa banyak sekaligus)</label>
                        <input id="fileInputAtar" type="file" multiple accept=".txt" />
                        <div style="margin-top:8px" class="row">
                            <button id="btnRefresh">Refresh Daftar</button>
                            <button id="btnClearAll" class="warn">Hapus Semua Data (localStorage)</button>
                        </div>

                        <label style="margin-top:12px">File tersimpan:</label>
                        <div id="fileListAtar" class="file-list"></div>
                        <small class="muted">Gunakan tombol <em>Load</em> untuk aktifkan (dipakai di bagian Prediksi), <em>Edit</em> untuk ubah/simpan, <em>Hapus</em> untuk menghapus file.</small>
                    </div>

                    <div class="card">
                        <h2>2) Pilih Basis & Pool</h2>
                        <label>Basis prediksi</label>
                        <div class="row">
                            <select id="basisSelect">
                                <option value="atar">Gunakan ATAR.txt (upload ATAR.txt dulu)</option>
                                <option value="topn">Hitung Top-N dari history (pilih N)</option>
                            </select>
                            <label style="margin:0 0 0 6px">TopN:</label>
                            <input id="topN" type="number" value="9" min="4" max="9" style="width:78px"/>
                        </div>

                        <label style="margin-top:8px">Pilih Pool (file yang sudah di-load)</label>
                        <div class="row">
                            <select id="poolSelect" style="min-width:240px"></select>
                            <button id="btnDetect4or5" class="ghost">Deteksi 4D/5D</button>
                        </div>

                        <label style="margin-top:10px">Rentang tanggal (untuk menghitung TopN atau cek akurasi)</label>
                        <div class="row">
                            <input id="dateFrom" type="date" /> <input id="dateTo" type="date" />
                            <button id="btnShowPattern">Tampilkan Pola</button>
                            <button id="btnCheckAccuracy">Cek Akurasi</button>
                            <button id="btnAnalyze" class="ghost">Analisa Pola</button>
                        </div>
                        <div id="patternArea" style="margin-top:12px"></div>
                    </div>
                </div>

                <div class="card">
                    <h2>3) Hasil Cek Akurasi  Detail Per Tanggal</h2>
                    <div id="resultSummary" class="smallmuted"></div>
                    <div id="resultTableArea"></div>
                    <div id="rekapArea" style="margin-top:12px"></div>
                </div>

                <div class="card">
                    <h2>4) Edit / Import Basis ATAR atau TOP8</h2>
                    <div class="row">
                        <label>Upload ATAR.txt (opsional)</label>
                        <input id="atarUpload" type="file" accept=".txt" />
                        <label style="margin-left:6px">Atau import TOP8_ALL.txt</label>
                        <input id="top8Upload" type="file" accept=".txt" />
                    </div>
                    <p class="muted">Jika Anda pilih "ATAR" sebagai basis, upload ATAR.txt terlebih dahulu. Jika pilih "TopN" basis, sistem akan menghitung TopN dari history sesuai rentang tanggal.</p>
                </div>

                <div class="card">
                    <h2>5) History Akurasi (Saved)</h2>
                    <div class="row">
                        <button id="btnSaveHistory">Simpan Hasil Cek Akurasi ke localStorage</button>
                        <button id="btnShowHistory" class="ghost">Tampilkan History Tersimpan</button>
                        <button id="btnClearHistory" class="warn">Hapus History</button>
                    </div>
                    <div id="historyArea" style="margin-top:8px"></div>
                </div>

                <!-- Edit modal (simple) -->
                <div id="editModal">
                    <div>
                        <h3 style="margin:6px 0">Edit & Simpan File</h3>
                        <div><strong id="editFileName"></strong></div>
                        <textarea id="editTextarea"></textarea>
                        <div style="text-align:right;margin-top:8px">
                            <button id="btnSaveEdit">Simpan</button>
                            <button id="btnCloseEdit" class="ghost">Batal</button>
                        </div>
                    </div>
                </div>
            </div>
        
                <!-- =================================================================
                     PAGE X: PREDIKSI  (Ditambahkan)
                ================================================================= -->
                <div id="pagePrediksi" class="page-content">
                    <div class="card">
                        <h2> PREDIKSI</h2>
                        <p class="muted">Pilih pool & tanggal prediksi, lalu tekan tombol prediksi. Sistem akan mendeteksi otomatis 4D/5D dan menyesuaikan output. Jika terjadi masalah, pesan akan muncul di area hasil.</p>

                        <label>Pilih Pool (dari file yang tersimpan)</label>
                        <select id="predPoolSelect"><option value="">-- Pilih Pool --</option></select>

                        <label style="margin-top:8px">Tanggal Prediksi</label>
                        <input id="predDate" type="date" />
                        <div id="predDayInfo" class="muted" style="margin-top:6px"></div>

                        <label style="margin-top:8px">Pengaturan</label>
<div style="margin:8px 0;"><label>Jumlah Top N: </label><input id="predTopNValue" type="number" min="1" max="20" value="9" style="width:60px;text-align:center;"></div>
                        <div class="row">
                            <label style="margin:0"><input id="predTopNCheck" type="checkbox" checked /> Prediksi Top N</label>
                            <label style="margin:0"><input id="predBkGeCheck" type="checkbox" checked /> BK &amp; GE</label>
                            <label style="margin:0"><input id="pred2DCheck" type="checkbox" checked /> 2D Depan-Belakang</label>
                            <label style="margin:0"><input id="predBbfsCheck" type="checkbox" checked /> BBFS</label>
                            <label style="margin:0"><input id="predMatiCheck" type="checkbox" checked /> Angka Mati</label>
                        </div>

                        <div class="row" style="margin-top:12px">
                            <button id="runPredBtn">Jalankan Prediksi</button>
                            <button id="savePredBtn" class="ghost">Simpan ke TXT</button>
                            <button id="clearPredBtn" class="warn">Hapus Hasil</button>
                        </div>

                        <div style="margin-top:12px">
                            <h3>Hasil Prediksi</h3>
                            <textarea id="outputPrediksi" readonly style="width:100%;height:180px;font-family:Courier New, monospace;"></textarea>
                        </div>
                    </div>
                </div>

        </main>
    </div>

<script>
// =================================================================
// GLOBAL UTILITY FUNCTIONS (Moved here to be accessible by all modules)
// =================================================================
const STORAGE_PREFIX = "POOLFILE_";
const HISTORY_KEY = "AKURASI_HISTORY";
let activePoolName = null; // Global variable to track active pool

function saveFileToStorage(filename, text) {
    localStorage.setItem(STORAGE_PREFIX + filename, text);
}

function loadFileFromStorage(filename) {
    return localStorage.getItem(STORAGE_PREFIX + filename);
}

function removeFileFromStorage(filename) {
    localStorage.removeItem(STORAGE_PREFIX + filename);
}

function listStoredFiles() {
    const keys = Object.keys(localStorage).filter(k => k.startsWith(STORAGE_PREFIX));
    return keys.map(k => k.substring(STORAGE_PREFIX.length)).sort();
}

function parsePoolText(txt) {
    const rows = [];
    const lines = txt.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    for (const l of lines) {
        const parts = l.split(",").map(p => p.trim());
        if (parts.length < 2) continue;
        const date = parts[0];
        if (!/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(date)) continue;
        const digits = parts.slice(1).map(x => x.replace(/\s+/g, &apos;&apos;)).filter(x => /^\d+$/.test(x));
        if (digits.length === 0) continue;
        rows.push({ date, digits });
    }
    rows.sort((a, b) => {
        const da = a.date.split("/").reverse().join("-");
        const db = b.date.split("/").reverse().join("-");
        return da.localeCompare(db);
    });
    return rows;
}

function formatDateInputToDDMM(dateStrIso) {
    if (!dateStrIso) return "";
    const d = new Date(dateStrIso);
    const dd = String(d.getDate()).padStart(2, "0");
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const yyyy = d.getFullYear();
    return `${dd}/${mm}/${yyyy}`;
}

function isoFromDDMM(dateDDMM) {
    const parts = dateDDMM.split("/");
    if (parts.length !== 3) return null;
    const [dd, mm, yyyy] = parts;
    return `${yyyy}-${String(mm).padStart(2, &apos;0&apos;)}-${String(dd).padStart(2, &apos;0&apos;)}`;
}

function weekdayBahasaFromDDMM(dateDDMM) {
    const iso = isoFromDDMM(dateDDMM);
    if (!iso) return null;
    const d = new Date(iso + "T00:00:00");
    const map = ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"];
    return map[d.getDay()];
}

function parseATAR(text) {
    const out = {};
    const re = /POOL\s+([A-Z0-9]+)[\s\S]*?Hari\s*:\s*([A-Za-z]+)[\s\S]*?POSISI\s+ANGKA TARUNG([\s\S]*?)(?=POOL\s+[A-Z0-9]+|$)/gi;
    let m;
    while ((m = re.exec(text)) !== null) {
        const pool = m[1].toUpperCase();
        const hari = m[2].charAt(0).toUpperCase() + m[2].slice(1).toLowerCase();
        const block = m[3];
        if (!out[pool]) out[pool] = {};
        if (!out[pool][hari]) out[pool][hari] = {};
        const lines = block.split(/\r?\n/);
        for (const line of lines) {
            const mm = line.trim().match(/^([A-Ea-e])\.\s*([\d,\s]+)/);
            if (mm) {
                const pos = mm[1].toUpperCase();
                const vals = mm[2].split(",").map(x => x.trim()).filter(x => /^\d+$/.test(x));
                out[pool][hari][pos] = vals;
            }
        }
    }
    return out;
}

function computeTopN(historyRows, posCount, topN, dateFromDDMM, dateToDDMM) {
    const weekdays = ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"];
    const counters = {};
    for (const h of weekdays) {
        counters[h] = {};
        for (let i = 0; i < posCount; i++) {
            counters[h][["A", "B", "C", "D", "E"][i]] = {};
        }
    }
    const fromISO = dateFromDDMM ? isoFromDDMM(dateFromDDMM) : null;
    const toISO = dateToDDMM ? isoFromDDMM(dateToDDMM) : null;

    for (const r of historyRows) {
        const iso = isoFromDDMM(r.date);
        if (!iso) continue;
        if (fromISO && iso < fromISO) continue;
        if (toISO && iso > toISO) continue;
        const dateObj = new Date(iso + "T00:00:00");
        const w = weekdays[dateObj.getDay()];
        for (let i = 0; i < posCount && i < r.digits.length; i++) {
            const pos = ["A", "B", "C", "D", "E"][i];
            const d = r.digits[i];
            counters[w][pos][d] = (counters[w][pos][d] || 0) + 1;
        }
    }
    const topResult = {};
    for (const h of Object.keys(counters)) {
        topResult[h] = {};
        for (const pos of Object.keys(counters[h])) {
            const items = Object.entries(counters[h][pos]);
            items.sort((a, b) => b[1] - a[1] || parseInt(a[0]) - parseInt(b[0]));
            const top = items.slice(0, topN).map(x => x[0]);
            if (top.length < topN) {
                for (let d = 0; d <= 9 && top.length < topN; d++) {
                    if (!top.includes(String(d))) top.push(String(d));
                }
            }
            topResult[h][pos] = top;
        }
    }
    return topResult;
}

function evaluateResultAgainstPred(predictedPerPos, resultDigits) {
    const L = resultDigits.length;
    if (L === 4) {
        const A = resultDigits[0], B = resultDigits[1], C = resultDigits[2], D = resultDigits[3];
        const okA = predictedPerPos["A"] && predictedPerPos["A"].includes(String(A));
        const okB = predictedPerPos["B"] && predictedPerPos["B"].includes(String(B));
        const okC = predictedPerPos["C"] && predictedPerPos["C"].includes(String(C));
        const okD = predictedPerPos["D"] && predictedPerPos["D"].includes(String(D));
        if (okA && okB && okC && okD) return { label: "Menang 4D", match: [okA, okB, okC, okD] };
        if (okB && okC && okD) return { label: "Menang 3D", match: [okA, okB, okC, okD] };
        return { label: "Kalah", match: [okA, okB, okC, okD] };
    } else if (L === 5) {
        const ok = (i, pos) => predictedPerPos[pos] && predictedPerPos[pos].includes(String(resultDigits[i]));
        const okA = ok(0, "A"), okB = ok(1, "B"), okC = ok(2, "C"), okD = ok(3, "D"), okE = ok(4, "E");
        if (okA && okB && okC && okD && okE) return { label: "Menang 5D", match: [okA, okB, okC, okD, okE] };
        if (okB && okC && okD && okE) return { label: "Menang 4D", match: [okA, okB, okC, okD, okE] };
        if (okC && okD && okE) return { label: "Menang 3D", match: [okA, okB, okC, okD, okE] };
        return { label: "Kalah", match: [okA, okB, okC, okD, okE] };
    } else {
        return { label: "Unknown", match: [] };
    }
}


// =================================================================
// MAIN INITIALIZATION & NAVIGATION
// =================================================================
document.addEventListener(&apos;DOMContentLoaded&apos;, () => {
    const navButtons = document.querySelectorAll(&apos;.nav-btn&apos;);
    const pages = document.querySelectorAll(&apos;.page-content&apos;);

    function showPage(targetId) {
        pages.forEach(page => page.classList.remove(&apos;active&apos;));
        navButtons.forEach(btn => btn.classList.remove(&apos;active&apos;));
        document.getElementById(targetId).classList.add(&apos;active&apos;);
        document.querySelector(`[data-target="${targetId}"]`).classList.add(&apos;active&apos;);
    }

    navButtons.forEach(button => {
        button.addEventListener(&apos;click&apos;, () => {
            const targetId = button.getAttribute(&apos;data-target&apos;);
            showPage(targetId);
            if (targetId === &apos;pageDashboard&apos;) {
                loadDashboardData();
            }
        });
    });

    // --- INITIALIZE ALL MODULES ---
    initDashboard();
    initAnalisa();
    initPermutasi();
    initAtar();
    initPrediksi();
});


// =================================================================
// SCRIPT FOR PAGE 0: DASHBOARD GLOBAL
// =================================================================
function initDashboard() {
    const refreshBtn = document.getElementById(&apos;refreshDashboardBtn&apos;);
    if (refreshBtn) {
        refreshBtn.addEventListener(&apos;click&apos;, loadDashboardData);
    }
    // Load data on initial page load if dashboard is active
    if (document.getElementById(&apos;pageDashboard&apos;).classList.contains(&apos;active&apos;)) {
        loadDashboardData();
    }
}

function loadDashboardData() {
    const poolStatsContainer = document.getElementById(&apos;poolStatsContainer&apos;);
    const digitFreqContainer = document.getElementById(&apos;digitFreqContainer&apos;);
    const heatmap2DContainer = document.getElementById(&apos;heatmap2DContainer&apos;);

    // Show loading state
    if (poolStatsContainer) poolStatsContainer.innerHTML = &apos;<p class="muted">Memuat data...</p>&apos;;
    if (digitFreqContainer) digitFreqContainer.innerHTML = &apos;<p class="muted">Memuat data...</p>&apos;;
    if (heatmap2DContainer) heatmap2DContainer.innerHTML = &apos;<p class="muted">Memuat data...</p>&apos;;

    const files = listStoredFiles();
    if (files.length === 0) {
        if (poolStatsContainer) poolStatsContainer.innerHTML = &apos;<p class="muted">Tidak ada file POOL yang tersimpan. Silakan upload file terlebih dahulu di menu ATAR.</p>&apos;;
        if (digitFreqContainer) digitFreqContainer.innerHTML = &apos;<p class="muted">Data tidak tersedia.</p>&apos;;
        if (heatmap2DContainer) heatmap2DContainer.innerHTML = &apos;<p class="muted">Data tidak tersedia.</p>&apos;;
        return;
    }

    let globalDigitCount = {};
    let global2DCount = {};
    let poolStats = [];

    for (let i = 0; i < 10; i++) globalDigitCount[i] = 0;
    for (let i = 0; i < 100; i++) global2DCount[String(i).padStart(2, &apos;0&apos;)] = 0;

    files.forEach(filename => {
        const content = loadFileFromStorage(filename);
        if (!content) return;

        const rows = parsePoolText(content);
        if (rows.length === 0) return;

        const lastRow = rows[rows.length - 1];
        const numDigits = lastRow.digits.length;
        const type = numDigits === 5 ? &apos;5D&apos; : &apos;4D&apos;;

        poolStats.push({
            name: filename.replace(&apos;.txt&apos;, &apos;&apos;),
            type: type,
            lastResult: lastRow.date,
            totalRecords: rows.length
        });

        rows.forEach(row => {
            row.digits.forEach(digit => {
                globalDigitCount[digit] = (globalDigitCount[digit] || 0) + 1;
            });
            if (row.digits.length >= 2) {
                const ab = row.digits[0] + row.digits[1];
                global2DCount[ab] = (global2DCount[ab] || 0) + 1;
            }
            if (row.digits.length >= 4) {
                const cd = row.digits[2] + row.digits[3];
                global2DCount[cd] = (global2DCount[cd] || 0) + 1;
            }
            if (row.digits.length >= 5) {
                const de = row.digits[3] + row.digits[4];
                global2DCount[de] = (global2DCount[de] || 0) + 1;
            }
        });
    });

    // Render Pool Statistics
    if (poolStatsContainer) {
        let statsHtml = `<table><thead><tr><th>Pool Name</th><th>Type</th><th>Total Records</th><th>Last Result</th></tr></thead><tbody>`;
        poolStats.sort((a, b) => a.name.localeCompare(b.name)).forEach(stat => {
            statsHtml += `<tr><td>${stat.name}</td><td>${stat.type}</td><td>${stat.totalRecords}</td><td>${stat.lastResult}</td></tr>`;
        });
        statsHtml += `</tbody></table>`;
        poolStatsContainer.innerHTML = statsHtml;
    }

    // Render Digit Frequency Bar Chart
    if (digitFreqContainer) {
        const maxDigitCount = Math.max(...Object.values(globalDigitCount));
        let digitChartHtml = `<ul class="bar-chart">`;
        for (let i = 0; i <= 9; i++) {
            const count = globalDigitCount[i];
            const percentage = maxDigitCount > 0 ? (count / maxDigitCount) * 100 : 0;
            digitChartHtml += `
                <li>
                    <span class="label">${i}</span>
                    <div class="bar-wrapper"><div class="bar" style="width: ${percentage}%;"></div></div>
                    <span class="value">${count}</span>
                </li>
            `;
        }
        digitChartHtml += `</ul>`;
        digitFreqContainer.innerHTML = digitChartHtml;
    }

    // Render 2D Heatmap
    if (heatmap2DContainer) {
        const max2DCount = Math.max(...Object.values(global2DCount));
        let heatmapHtml = `<div class="heatmap-grid">`;
        for (let i = 0; i < 100; i++) {
            const key = String(i).padStart(2, &apos;0&apos;);
            const count = global2DCount[key];
            const intensity = max2DCount > 0 ? count / max2DCount : 0;
            let color = `rgba(0, 255, 255, ${intensity})`;
            if (intensity > 0.75) color = `rgba(255, 255, 0, ${intensity})`;
            if (intensity > 0.9) color = `rgba(255, 0, 255, ${intensity})`;
            
            heatmapHtml += `<div class="heatmap-cell" style="background-color: ${color};" title="${key}: ${count} kali">${key}</div>`;
        }
        heatmapHtml += `</div>`;
        heatmap2DContainer.innerHTML = heatmapHtml;
    }
}


// =================================================================
// SCRIPT FOR PAGE 1: ANALISA
// =================================================================
function initAnalisa() {
    const poolSelect = document.getElementById(&apos;poolSelectAnalisa&apos;);
    const prosesBtn = document.getElementById(&apos;prosesFilesAnalisaBtn&apos;);
    const statusEl = document.getElementById(&apos;status-analisa&apos;);

    if (!poolSelect || !prosesBtn) return;

    function populatePoolDropdown() {
        const files = listStoredFiles();
        poolSelect.innerHTML = &apos;<option value="">-- Pilih Pool --</option>&apos;;
        files.forEach(file => {
            const option = document.createElement(&apos;option&apos;);
            option.value = file;
            option.textContent = file;
            poolSelect.appendChild(option);
        });

        // Set default to active pool if available
        if (activePoolName && files.includes(activePoolName)) {
            poolSelect.value = activePoolName;
        }
        updateProsesButtonState();
    }

    function updateProsesButtonState() {
        prosesBtn.disabled = !poolSelect.value;
    }

    prosesBtn.addEventListener(&apos;click&apos;, prosesFilesAnalisa);
    poolSelect.addEventListener(&apos;change&apos;, updateProsesButtonState);

    // Populate dropdown when the page is shown
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.target.id === &apos;pageAnalisa&apos; && mutation.target.classList.contains(&apos;active&apos;)) {
                populatePoolDropdown();
            }
        });
    });
    observer.observe(document.getElementById(&apos;pageAnalisa&apos;), { attributes: true, attributeFilter: [&apos;class&apos;] });

    // Initial population in case it&apos;s the first page loaded
    if (document.getElementById(&apos;pageAnalisa&apos;).classList.contains(&apos;active&apos;)) {
        populatePoolDropdown();
    }
}

const FILES_4D_NAMES_ANALISA = [
    "ATH.txt", "BEI.txt", "BOM.txt", "BRU.txt", "BUL.txt", "BUR.txt", "BUS.txt",
    "CAL.txt", "CDAY.txt", "CEVE.txt", "COL.txt", "DDAY.txt", "DEVE.txt",
    "DUB.txt", "TOK.txt", "PPL.txt", "CHI.txt", "SYD.txt", "HKG.txt", "SEO.txt"
];
const FILES_5D_NAMES_ANALISA = ["T15.txt", "T21.txt"];
const LIMIT_HARI_ANALISA = 100;
const HARI_INDONESIA_ANALISA = { 0: "Senin", 1: "Selasa", 2: "Rabu", 3: "Kamis", 4: "Jumat", 5: "Sabtu", 6: "Minggu" };
const SEMUA_2D_ANALISA = new Set(Array.from({ length: 100 }, (_, i) => String(i).padStart(2, &apos;0&apos;)));

function prosesFilesAnalisa() {
    const poolSelect = document.getElementById(&apos;poolSelectAnalisa&apos;);
    const selectedFile = poolSelect.value;
    if (!selectedFile) { alert("Harap pilih POOL terlebih dahulu."); return; }

    const statusEl = document.getElementById(&apos;status-analisa&apos;);
    const outputEl = document.getElementById(&apos;outputAnalisa&apos;);

    statusEl.textContent = "Memulai analisis...";
    outputEl.textContent = "Memproses data, mohon tunggu...";

    const content = loadFileFromStorage(selectedFile);
    if (!content) {
        statusEl.textContent = `Gagal memuat data untuk ${selectedFile}.`;
        outputEl.textContent = "Data tidak ditemukan.";
        return;
    }

    let numDigits;
    if (FILES_4D_NAMES_ANALISA.map(n => n.toUpperCase()).includes(selectedFile.toUpperCase())) {
        numDigits = 4;
    } else if (FILES_5D_NAMES_ANALISA.map(n => n.toUpperCase()).includes(selectedFile.toUpperCase())) {
        numDigits = 5;
    } else {
        // Fallback: try to detect from content
        const rows = parsePoolText(content);
        if (rows.length > 0) {
            numDigits = rows[0].digits.length;
        } else {
            statusEl.textContent = `Tidak dapat mengidentifikasi dimensi untuk ${selectedFile}.`;
            outputEl.textContent = "Format file tidak didukung.";
            return;
        }
    }
    
    const poolData = { name: selectedFile.replace(&apos;.TXT&apos;, &apos;&apos;), digits: numDigits, content: content };
    const analysisResult = analyzePoolAnalisa(poolData.content, poolData.digits, poolData.name);
    const output = formatCombinedOutputAnalisa(analysisResult, poolData.name, poolData.digits);
    
    outputEl.innerHTML = output;
    statusEl.textContent = `Analisis selesai untuk POOL: ${poolData.name}.`;
}

function analyzePoolAnalisa(content, numDigits, poolName) {
    const lines = content.trim().split(&apos;\n&apos;).filter(l => l.trim() !== &apos;&apos;);
    let dataSortir = [];
    for (const line of lines) {
        const parts = line.trim().split(&apos;,&apos;);
        if (parts.length < numDigits + 1) continue;
        try {
            const dateStr = parts[0];
            const date = parseDateAnalisa(dateStr);
            const numbers = parts.slice(1, numDigits + 1).map(n => n.trim());
            if (numbers.some(n => !/^\d$/.test(n))) continue;
            dataSortir.push({ date: date, numbers: numbers.map(n => parseInt(n)), numbersStr: numbers });
        } catch (e) { continue; }
    }
    dataSortir.sort((a, b) => b.date.getTime() - a.date.getTime());
    const dataTerbaru = dataSortir.slice(0, LIMIT_HARI_ANALISA);
    dataTerbaru.sort((a, b) => a.date.getTime() - b.date.getTime());

    const transisiHarian = {};
    const frekuensiHarian2D = {};
    const semua2DKeluar100Hari = new Set();
    let angkaSebelumnya = {};
    const positions = numDigits === 4 ? [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;] : [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;];
    positions.forEach(pos => angkaSebelumnya[pos] = null);

    for (let i = 0; i < dataTerbaru.length; i++) {
        const data = dataTerbaru[i];
        const day = data.date.getDay() === 0 ? 6 : data.date.getDay() - 1;
        if (!transisiHarian[day]) transisiHarian[day] = {};
        if (!frekuensiHarian2D[day]) frekuensiHarian2D[day] = {};
        for (let j = 0; j < data.numbers.length; j++) {
            const pos = positions[j];
            const currentNum = data.numbers[j];
            const prevNum = angkaSebelumnya[pos];
            if (prevNum !== null) {
                if (!transisiHarian[day][pos]) transisiHarian[day][pos] = {};
                if (!transisiHarian[day][pos][prevNum]) transisiHarian[day][pos][prevNum] = {};
                transisiHarian[day][pos][prevNum][currentNum] = (transisiHarian[day][pos][prevNum][currentNum] || 0) + 1;
            }
            angkaSebelumnya[pos] = currentNum;
        }
        const positions2D = numDigits === 4 ? { &apos;AB&apos;: [0, 1], &apos;CD&apos;: [2, 3] } : { &apos;AB&apos;: [0, 1], &apos;DE&apos;: [3, 4] };
        for (const pos2D in positions2D) {
            const [idx1, idx2] = positions2D[pos2D];
            const kombinasi2D = data.numbersStr[idx1] + data.numbersStr[idx2];
            if (!frekuensiHarian2D[day][pos2D]) frekuensiHarian2D[day][pos2D] = {};
            frekuensiHarian2D[day][pos2D][kombinasi2D] = (frekuensiHarian2D[day][pos2D][kombinasi2D] || 0) + 1;
            semua2DKeluar100Hari.add(kombinasi2D);
        }
    }
    const duaDBelumKeluar = new Set([...SEMUA_2D_ANALISA].filter(x => !semua2DKeluar100Hari.has(x)));

    dataSortir.sort((a, b) => a.date.getTime() - b.date.getTime());
    const frekuensiAngkaDominan = {};
    for (const data of dataSortir) {
        const day = data.date.getDay() === 0 ? 6 : data.date.getDay() - 1;
        if (!frekuensiAngkaDominan[day]) frekuensiAngkaDominan[day] = {};
        for (let j = 0; j < data.numbers.length; j++) {
            const pos = positions[j];
            const currentNum = data.numbers[j];
            if (!frekuensiAngkaDominan[day][pos]) frekuensiAngkaDominan[day][pos] = {};
            frekuensiAngkaDominan[day][pos][currentNum] = (frekuensiAngkaDominan[day][pos][currentNum] || 0) + 1;
        }
    }
    return { transisiHarian, frekuensiAngkaDominan, frekuensiHarian2D, duaDBelumKeluar };
}

function formatCombinedOutputAnalisa(results, poolName, numDigits) {
    const days = Object.keys(HARI_INDONESIA_ANALISA).map(Number).sort();
    const positions = numDigits === 4 ? [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;] : [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;];
    const outputParts = [];
    outputParts.push(`<div class="pool-section"><h3>POOL ${poolName} (${numDigits}D)</h3>`);
    for (const day of days) {
        const dayName = HARI_INDONESIA_ANALISA[day];
        const hasDayData = results.frekuensiAngkaDominan[day] || results.transisiHarian[day] || results.frekuensiHarian2D[day];
        if (!hasDayData) {
             outputParts.push(`<br><h4>-- Hari: ${dayName} --</h4><p>(Tidak ada data di 100 hari terakhir)</p>`);
             continue;
        }
        outputParts.push(`<br><h4>1. Pola Frekuensi Angka Dominan (Seluruh Sejarah) - Hari: ${dayName}</h4>`);
        let freqOutput = &apos;POSISI\tANGKA TARUNG\n&apos;;
        let hasFreqData = false;
        for (const pos of positions) {
            const counter = (results.frekuensiAngkaDominan[day] && results.frekuensiAngkaDominan[day][pos]) || {};
            if (Object.keys(counter).length > 0) hasFreqData = true;
            const sorted = Object.entries(counter).sort((a, b) => b[1] - a[1]).slice(0, 7).map(a => a[0]);
            freqOutput += `${pos}.\t${sorted.join(&apos;,&apos;)}\n`;
        }
        outputParts.push(hasFreqData ? `<pre>${freqOutput}</pre>` : `(Tidak ada data frekuensi per posisi untuk hari ${dayName})`);
        outputParts.push(`<h4>2. Pola Transisi Angka (100 Hari Terbaru) - Hari: ${dayName}</h4>`);
        let transisiOutput = &apos;Angka\tPosisi\t&apos; + positions.join(&apos;\t&apos;) + &apos;\n&apos;;
        transisiOutput += &apos;\tTransisi\n&apos;;
        let hasTransisiData = false;
        for (let prevNum = 0; prevNum <= 9; prevNum++) {
            let line = `${prevNum}\t`;
            for (const pos of positions) {
                const counter = (((results.transisiHarian[day] || {})[pos] || {})[prevNum]) || {};
                if (Object.keys(counter).length > 0) hasTransisiData = true;
                const sorted = Object.entries(counter).sort((a, b) => b[1] - a[1]).slice(0, 8).map(a => a[0]);
                line += sorted.join(&apos;, &apos;) + &apos;\t&apos;;
            }
            transisiOutput += line.trim() + &apos;\n&apos;;
        }
        outputParts.push(hasTransisiData ? `<pre>${transisiOutput}</pre>` : `(Tidak ada data transisi untuk hari ${dayName})`);
        outputParts.push(`<h4>3. Pola Frekuensi 2D (100 Hari Terbaru) - Hari: ${dayName}</h4>`);
        const pos2DLabel = numDigits === 4 ? &apos;CD&apos; : &apos;DE&apos;;
        let frek2DOutput = &apos;Posisi\n&apos;;
        const positions2D = { &apos;AB&apos;: &apos;AB&apos;, [pos2DLabel]: pos2DLabel };
        let has2DData = false;
        for (const pos2D in positions2D) {
            const counter = (results.frekuensiHarian2D[day] && results.frekuensiHarian2D[day][pos2D]) || {};
            if (Object.keys(counter).length > 0) has2DData = true;
            const sorted = Object.entries(counter).sort((a, b) => b[1] - a[1]).map(a => a[0]);
            frek2DOutput += `${pos2D}\t:${sorted.join(&apos;*&apos;)}\n`;
        }
        const missing2D = Array.from(results.duaDBelumKeluar).sort();
        frek2DOutput += `2D Belum keluar\t:${missing2D.join(&apos;*&apos;)}\n`;
        outputParts.push(has2DData ? `<pre>${frek2DOutput}</pre>` : `(Tidak ada data 2D untuk hari ${dayName})`);
    }
    outputParts.push(&apos;</div>&apos;);
    return outputParts.join(&apos;&apos;);
}
function parseDateAnalisa(dateStr) {
    const parts = dateStr.split(&apos;/&apos;);
    return new Date(parts[2], parts[1] - 1, parts[0]);
}


// =================================================================
// SCRIPT FOR PAGE 2: PERMUTASI
// =================================================================
function initPermutasi() {
    const checkAB = document.getElementById(&apos;checkAB&apos;);
    const checkCD = document.getElementById(&apos;checkCD&apos;);
    const checkBK = document.getElementById(&apos;checkBK&apos;);
    const inputAB = document.getElementById(&apos;inputAB&apos;);
    const inputCD = document.getElementById(&apos;inputCD&apos;);
    const inputBK = document.getElementById(&apos;inputBK&apos;);
    const generateBtn = document.getElementById(&apos;generateBtn&apos;);
    const bbfsBtn = document.getElementById(&apos;bbfsBtn&apos;);
    const outputArea = document.getElementById(&apos;outputPermutasi&apos;);
    const copyBtn = document.getElementById(&apos;copyBtn&apos;);
    const exportBtn = document.getElementById(&apos;exportBtn&apos;);

    if (!generateBtn || !bbfsBtn || !outputArea || !copyBtn || !exportBtn) return;

    function parseInput(text) {
        return text.split(&apos;*&apos;).map(s => s.trim()).filter(s => s !== &apos;&apos;);
    }

    function getSelectedLists() {
        const selected = [];
        if (checkAB.checked) selected.push({ name: &apos;AB&apos;, data: parseInput(inputAB.value) });
        if (checkCD.checked) selected.push({ name: &apos;CD/DE&apos;, data: parseInput(inputCD.value) });
        if (checkBK.checked) selected.push({ name: &apos;2D Belum Keluar&apos;, data: parseInput(inputBK.value) });
        if (selected.length !== 2) { alert(&apos;Harap pilih tepat 2 kolom untuk diproses.&apos;); return null; }
        return selected;
    }

    function getPermutations(str) {
        if (str.length <= 1) return [str];
        const results = [];
        const chars = str.split(&apos;&apos;);
        const used = new Array(chars.length).fill(false);
        const currentPermutation = [];
        function backtrack() {
            if (currentPermutation.length === chars.length) { results.push(currentPermutation.join(&apos;&apos;)); return; }
            for (let i = 0; i < chars.length; i++) {
                if (used[i]) continue;
                used[i] = true;
                currentPermutation.push(chars[i]);
                backtrack();
                currentPermutation.pop();
                used[i] = false;
            }
        }
        backtrack();
        return [...new Set(results)];
    }

    generateBtn.addEventListener(&apos;click&apos;, () => {
        const lists = getSelectedLists();
        if (!lists) return;
        const list1 = lists[0].data;
        const list2 = lists[1].data;
        const minLength = Math.min(list1.length, list2.length);
        const results = [];
        for (let i = 0; i < minLength; i++) {
            const part1 = String(list1[i]).padStart(2, &apos;0&apos;);
            const part2 = String(list2[i]).padStart(2, &apos;0&apos;);
            if(part1.length === 2 && part2.length === 2) { results.push(part1 + part2); }
        }
        outputArea.value = results.join(&apos;*&apos;);
    });

    bbfsBtn.addEventListener(&apos;click&apos;, () => {
        const lists = getSelectedLists();
        if (!lists) return;
        const list1 = lists[0].data;
        const list2 = lists[1].data;
        const minLength = Math.min(list1.length, list2.length);
        const allPermutations = [];
        for (let i = 0; i < minLength; i++) {
            const part1 = String(list1[i]).padStart(2, &apos;0&apos;);
            const part2 = String(list2[i]).padStart(2, &apos;0&apos;);
            const fourDigitStr = part1 + part2;
            if (fourDigitStr.length === 4) {
                const perms = getPermutations(fourDigitStr);
                allPermutations.push(...perms);
            }
        }
        outputArea.value = allPermutations.join(&apos;*&apos;);
    });

    copyBtn.addEventListener(&apos;click&apos;, () => {
        if (!outputArea.value) { alert(&apos;Tidak ada hasil untuk disalin.&apos;); return; }
        navigator.clipboard.writeText(outputArea.value).then(() => {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = &apos;Tersalin!&apos;;
            copyBtn.style.background = &apos;var(--neon-cyan)&apos;;
            copyBtn.style.color = &apos;var(--bg-color)&apos;;
            setTimeout(() => {
                copyBtn.textContent = originalText;
                copyBtn.style.background = &apos;transparent&apos;;
                copyBtn.style.color = &apos;var(--text-color)&apos;;
            }, 2000);
        }).catch(err => { console.error(&apos;Gagal menyalin teks: &apos;, err); alert(&apos;Gagal menyalin teks.&apos;); });
    });

    exportBtn.addEventListener(&apos;click&apos;, () => {
        if (!outputArea.value) { alert(&apos;Tidak ada hasil untuk diekspor.&apos;); return; }
        const textToSave = outputArea.value;
        const blob = new Blob([textToSave], { type: &apos;text/plain;charset=utf-8&apos; });
        const url = URL.createObjectURL(blob);
        const link = document.createElement(&apos;a&apos;);
        link.href = url;
        link.download = `hasil_4d_${new Date().getTime()}.txt`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    });
}


// =================================================================
// SCRIPT FOR PAGE 3: ATAR
// =================================================================
function initAtar() {
    let cachedATAR = null;
    let cachedTop8All = null;

    const fileInput = document.getElementById("fileInputAtar");
    const fileListEl = document.getElementById("fileListAtar");
    const btnRefresh = document.getElementById("btnRefresh");
    const btnClearAll = document.getElementById("btnClearAll");
    const poolSelect = document.getElementById("poolSelect");
    const basisSelect = document.getElementById("basisSelect");
    const topNInput = document.getElementById("topN");
    const atarUpload = document.getElementById("atarUpload");
    const top8Upload = document.getElementById("top8Upload");
    const btnShowPattern = document.getElementById("btnShowPattern");
    const btnCheckAccuracy = document.getElementById("btnCheckAccuracy");
    const btnAnalyze = document.getElementById("btnAnalyze");
    const dateFrom = document.getElementById("dateFrom");
    const dateTo = document.getElementById("dateTo");
    const patternArea = document.getElementById("patternArea");
    const resultTableArea = document.getElementById("resultTableArea");
    const rekapArea = document.getElementById("rekapArea");
    const resultSummary = document.getElementById("resultSummary");
    const btnDetect4or5 = document.getElementById("btnDetect4or5");
    const editModal = document.getElementById("editModal");
    const editFileName = document.getElementById("editFileName");
    const editTextarea = document.getElementById("editTextarea");
    const btnSaveEdit = document.getElementById("btnSaveEdit");
    const btnCloseEdit = document.getElementById("btnCloseEdit");
    const btnSaveHistory = document.getElementById("btnSaveHistory");
    const btnShowHistory = document.getElementById("btnShowHistory");
    const btnClearHistory = document.getElementById("btnClearHistory");
    const historyArea = document.getElementById("historyArea");

    function refreshFileList() {
        const files = listStoredFiles();
        fileListEl.innerHTML = "";
        if (files.length === 0) {
            fileListEl.innerHTML = "<div class=&apos;muted&apos;>Belum ada file tersimpan.</div>";
        } else {
            for (const f of files) {
                const div = document.createElement("div");
                div.style.padding = "6px 4px";
                div.style.borderBottom = "1px dashed rgba(255,255,255,0.03)";
                div.innerHTML = `<strong style="color:#bde">${f}</strong>
                    <div class="row" style="margin-top:6px">
                    <button class="btnLoad" data-file="${f}">Load</button>
                    <button class="btnEdit" data-file="${f}">Edit</button>
                    <button class="btnDelete" data-file="${f}">Hapus</button>
                    </div>`;
                fileListEl.appendChild(div);
            }
        }
        refreshPoolSelect();
    }

    function refreshPoolSelect() {
        const sel = poolSelect;
        const prev = sel.value;
        sel.innerHTML = "<option value=&apos;&apos;>-- pilih pool --</option>";
        const files = listStoredFiles();
        for (const f of files) {
            const opt = document.createElement("option");
            opt.value = f;
            opt.textContent = f;
            sel.appendChild(opt);
        }
        if (prev && Array.from(sel.options).some(o => o.value === prev)) sel.value = prev;
    }

    function detect4or5FromFileContent(filename) {
        const txt = loadFileFromStorage(filename) || "";
        const rows = parsePoolText(txt);
        if (rows.length === 0) return null;
        const first = rows[0];
        const l = first.digits.length;
        if (l >= 5) return 5;
        return 4;
    }

    // --- EVENT LISTENERS ---
    fileInput.addEventListener("change", async (ev) => {
        const files = Array.from(ev.target.files || []);
        for (const file of files) {
            const txt = await file.text();
            saveFileToStorage(file.name, txt);
        }
        alert("File disimpan ke localStorage dengan nama file yang sama.");
        refreshFileList();
        ev.target.value = "";
    });

    btnRefresh.addEventListener("click", () => refreshFileList());

    btnClearAll.addEventListener("click", () => {
        if (!confirm("Hapus semua file POOL yang tersimpan di localStorage?")) return;
        const files = listStoredFiles();
        for (const f of files) removeFileFromStorage(f);
        refreshFileList();
        refreshPoolSelect();
    });

    fileListEl.addEventListener("click", (e) => {
        const btn = e.target;
        const file = btn.dataset && btn.dataset.file;
        if (!file) return;
        if (btn.classList.contains("btnLoad")) {
            window.activePoolName = file; // Use global variable
            poolSelect.value = file;
            alert("Pool aktif: " + file);
        } else if (btn.classList.contains("btnEdit")) {
            editFileName.textContent = file;
            editTextarea.value = loadFileFromStorage(file) || "";
            editModal.style.display = "block";
        } else if (btn.classList.contains("btnDelete")) {
            if (!confirm("Hapus file " + file + " dari localStorage?")) return;
            removeFileFromStorage(file);
            if (window.activePoolName === file) window.activePoolName = null;
            refreshFileList();
        }
    });

    btnCloseEdit.addEventListener("click", () => { editModal.style.display = "none"; });
    btnSaveEdit.addEventListener("click", () => {
        const file = editFileName.textContent;
        saveFileToStorage(file, editTextarea.value);
        editModal.style.display = "none";
        alert("Perubahan disimpan.");
        refreshFileList();
    });

    btnDetect4or5.addEventListener("click", () => {
        const f = poolSelect.value;
        if (!f) { alert("Pilih pool dulu."); return; }
        const det = detect4or5FromFileContent(f);
        alert(det ? `Pool ${f} terdeteksi ${det}D` : "Gagal mendeteksi (cek format file).");
    });

    atarUpload.addEventListener("change", async e => {
        const file = e.target.files[0];
        if (!file) return;
        const txt = await file.text();
        cachedATAR = parseATAR(txt);
        alert("ATAR.txt di-load ke memori.");
        e.target.value = "";
    });

    top8Upload.addEventListener("change", async e => {
        const file = e.target.files[0];
        if (!file) return;
        const txt = await file.text();
        cachedTop8All = txt;
        alert("TOP8_ALL.txt di-load ke memori.");
        e.target.value = "";
    });

    btnShowPattern.addEventListener("click", () => {
        patternArea.innerHTML = ""; resultTableArea.innerHTML = ""; rekapArea.innerHTML = ""; resultSummary.innerText = "";
        const poolFile = poolSelect.value;
        if (!poolFile) { alert("Pilih pool terlebih dahulu."); return; }
        const poolTxt = loadFileFromStorage(poolFile);
        if (!poolTxt) { alert("File pool tidak ditemukan di localStorage."); return; }
        const rows = parsePoolText(poolTxt);
        if (rows.length === 0) { alert("File pool tidak berisi baris valid."); return; }
        const detected = detect4or5FromFileContent(poolFile) || 4;
        const posCount = detected === 5 ? 5 : 4;
        const fromISO = dateFrom.value || null;
        const toISO = dateTo.value || null;
        const fromDDMM = fromISO ? formatDateInputToDDMM(fromISO) : null;
        const toDDMM = toISO ? formatDateInputToDDMM(toISO) : null;
        const basis = basisSelect.value;
        let predicted = {};
        if (basis === "atar") {
            if (!cachedATAR) { alert("ATAR belum di-load."); return; }
            const sampleDateDDMM = fromDDMM || rows[0].date;
            const hari = weekdayBahasaFromDDMM(sampleDateDDMM);
            predicted = (cachedATAR[poolFile.replace(".txt", "").toUpperCase()] || {})[hari] || {};
        } else {
            const topN = Math.max(4, Math.min(9, parseInt(topNInput.value) || 9));
            predicted = computeTopN(rows, posCount, topN, fromDDMM, toDDMM);
        }
        const sampleDay = fromDDMM || (rows.length ? rows[rows.length - 1].date : null);
        const hariSample = weekdayBahasaFromDDMM(sampleDay);
        let displayPred = {};
        if (basis === "atar") {
            const posKeys = ["A", "B", "C", "D", "E"].slice(0, posCount);
            for (const p of posKeys) {
                displayPred[p] = (predicted[p] && predicted[p].slice(0, 9)) || (Array.from({ length: 9 }, (_, i) => String(i)));
            }
        } else {
            displayPred = (predicted[hariSample] || {});
            const posKeys = ["A", "B", "C", "D", "E"].slice(0, posCount);
            for (const p of posKeys) {
                if (!displayPred[p]) displayPred[p] = Array.from({ length: 9 }, (_, i) => String(i));
            }
        }
        const poolLabel = poolFile.replace(".txt", "");
        const header = document.createElement("div");
        header.innerHTML = `<pre class="small">================================================================================
POOL ${poolLabel}   Hari : ${hariSample}
================================================================================
POSISI\tANGKA TARUNG</pre>`;
        patternArea.appendChild(header);
        const table = document.createElement("table");
        const thead = document.createElement("thead");
        thead.innerHTML = "<tr><th>POSISI</th><th>ANGKA TARUNG (Top)</th></tr>";
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        const posList = ["A", "B", "C", "D", "E"].slice(0, posCount);
        for (const pos of posList) {
            const tr = document.createElement("tr");
            const td1 = document.createElement("td"); td1.textContent = pos + ".";
            const td2 = document.createElement("td"); td2.textContent = (displayPred[pos] || []).join(",");
            tr.appendChild(td1); tr.appendChild(td2);
            tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        patternArea.appendChild(table);
        const note = document.createElement("div");
        note.className = "muted";
        note.style.marginTop = "8px";
        note.innerHTML = `Result dd/mm/yyyy : pilih rentang tanggal lalu klik <strong>Cek Akurasi</strong>.<br>
        Aturan: 4D -> ABCD = Menang 4D; BCD = Menang 3D; 5D -> A-E = Menang 5D; B-E=4D; C-E=3D.`;
        patternArea.appendChild(note);
    });

    btnCheckAccuracy.addEventListener("click", () => {
        resultTableArea.innerHTML = ""; rekapArea.innerHTML = ""; resultSummary.innerText = "";
        const poolFile = poolSelect.value;
        if (!poolFile) { alert("Pilih pool terlebih dahulu."); return; }
        const poolTxt = loadFileFromStorage(poolFile);
        if (!poolTxt) { alert("File pool tidak ditemukan di localStorage."); return; }
        const rows = parsePoolText(poolTxt);
        if (rows.length === 0) { alert("File pool tidak memiliki data valid."); return; }
        const detected = detect4or5FromFileContent(poolFile) || 4;
        const posCount = detected === 5 ? 5 : 4;
        const fromISO = dateFrom.value || null;
        const toISO = dateTo.value || null;
        let fromDDMM = fromISO ? formatDateInputToDDMM(fromISO) : null;
        let toDDMM = toISO ? formatDateInputToDDMM(toISO) : null;
        if (!fromDDMM || !toDDMM) {
            fromDDMM = rows[0].date;
            toDDMM = rows[rows.length - 1].date;
        }
        const fromISO2 = isoFromDDMM(fromDDMM);
        const toISO2 = isoFromDDMM(toDDMM);
        const filtered = rows.filter(r => {
            const iso = isoFromDDMM(r.date);
            return iso >= fromISO2 && iso <= toISO2;
        });
        if (filtered.length === 0) { alert("Tidak ada data result di rentang tanggal tersebut."); return; }
        const basis = basisSelect.value;
        let predictedPerWeekday = {};
        if (basis === "atar") {
            if (!cachedATAR) { alert("ATAR belum di-load."); return; }
            predictedPerWeekday = cachedATAR[poolFile.replace(".txt", "").toUpperCase()] || {};
            if (Object.keys(predictedPerWeekday).length === 0) {
                if (!confirm("Pola ATAR untuk pool ini tidak ditemukan. Lanjutkan dengan TopN computed?")) return;
            }
        } else {
            const allRows = parsePoolText(poolTxt);
            const topN = Math.max(4, Math.min(9, parseInt(topNInput.value) || 9));
            predictedPerWeekday = computeTopN(allRows, posCount, topN, fromDDMM, toDDMM);
        }
        const resultRows = [];
        const summaryCounts = { "Menang 5D": 0, "Menang 4D": 0, "Menang 3D": 0, "Kalah": 0, "Unknown": 0 };
        for (const r of filtered) {
            const hari = weekdayBahasaFromDDMM(r.date);
            const predictedForHari = predictedPerWeekday[hari] || {};
            if (Object.keys(predictedForHari).length === 0 && basis === "atar") {
                const allRows = parsePoolText(poolTxt);
                predictedPerWeekday = computeTopN(allRows, posCount, 9, fromDDMM, toDDMM);
            }
            const finalPredPerPos = {};
            const posKeys = ["A", "B", "C", "D", "E"].slice(0, posCount);
            for (const p of posKeys) {
                finalPredPerPos[p] = (predictedPerWeekday[hari] && predictedPerWeekday[hari][p]) || [];
                finalPredPerPos[p] = finalPredPerPos[p].map(x => String(x));
            }
            const evalRes = evaluateResultAgainstPred(finalPredPerPos, r.digits);
            resultRows.push({ date: r.date, result: r.digits.join(""), label: evalRes.label, matches: evalRes.match });
            if (summaryCounts.hasOwnProperty(evalRes.label)) summaryCounts[evalRes.label]++;
            else summaryCounts["Unknown"]++;
        }
        const tbl = document.createElement("table");
        const thead = document.createElement("thead");
        const headRow = ["Tanggal", "Result"].concat(["A", "B", "C", "D", "E"].slice(0, posCount)).concat(["Hasil"]);
        thead.innerHTML = "<tr>" + headRow.map(h => `<th>${h}</th>`).join("") + "</tr>";
        tbl.appendChild(thead);
        const tbody = document.createElement("tbody");
        for (const rr of resultRows) {
            const tr = document.createElement("tr");
            const tdDate = document.createElement("td"); tdDate.textContent = rr.date;
            const tdRes = document.createElement("td"); tdRes.textContent = rr.result;
            tr.appendChild(tdDate); tr.appendChild(tdRes);
            for (let i = 0; i < rr.matches.length; i++) {
                const td = document.createElement("td");
                td.textContent = rr.matches[i] ? "Y" : "X";
                td.className = rr.matches[i] ? "ok" : "bad";
                tr.appendChild(td);
            }
            const tdLabel = document.createElement("td"); tdLabel.textContent = rr.label;
            tr.appendChild(tdLabel);
            tbody.appendChild(tr);
        }
        tbl.appendChild(tbody);
        resultTableArea.appendChild(tbl);
        const total = resultRows.length;
        const rek = document.createElement("div");
        rek.innerHTML = `<div class="badge">Total: ${total} baris</div>
            <div style="margin-top:8px">
            Menang 5D: ${summaryCounts["Menang 5D"] || 0}<br>
            Menang 4D: ${summaryCounts["Menang 4D"] || 0}<br>
            Menang 3D: ${summaryCounts["Menang 3D"] || 0}<br>
            Kalah: ${summaryCounts["Kalah"] || 0}
            </div>`;
        rekapArea.appendChild(rek);
        resultSummary.innerText = `Pool: ${poolFile}  |  Basis: ${basis.toUpperCase()}  |  Rentang: ${fromDDMM}  ${toDDMM}`;
    });

    let lastAnalysisResult = "";
    btnAnalyze.addEventListener("click", () => {
        resultTableArea.innerHTML = ""; rekapArea.innerHTML = ""; resultSummary.innerText = "";
        const poolFile = poolSelect.value;
        if (!poolFile) { alert("Pilih pool terlebih dahulu."); return; }
        const poolTxt = loadFileFromStorage(poolFile);
        if (!poolTxt) { alert("File pool tidak ditemukan di localStorage."); return; }
        const rows = parsePoolText(poolTxt);
        if (rows.length === 0) { alert("File pool tidak memiliki data valid."); return; }
        const detected = detect4or5FromFileContent(poolFile) || 4;
        const posCount = detected === 5 ? 5 : 4;
        const fromISO = dateFrom.value || null;
        const toISO = dateTo.value || null;
        let fromDDMM = fromISO ? formatDateInputToDDMM(fromISO) : null;
        let toDDMM = toISO ? formatDateInputToDDMM(toISO) : null;
        if (!fromDDMM || !toDDMM) {
            fromDDMM = rows[0].date;
            toDDMM = rows[rows.length - 1].date;
        }
        const topN = Math.max(4, Math.min(9, parseInt(topNInput.value) || 9));
        const allRows = parsePoolText(poolTxt);
        const predicted = computeTopN(allRows, posCount, topN, fromDDMM, toDDMM);
        const sampleDay = fromDDMM;
        const hari = weekdayBahasaFromDDMM(sampleDay);
        const globalCount = {};
        for (let i = 0; i < posCount; i++) {
            const pos = ["A", "B", "C", "D", "E"][i];
            globalCount[pos] = {};
            for (const r of allRows) {
                if (r.digits.length <= i) continue;
                const d = r.digits[i];
                globalCount[pos][d] = (globalCount[pos][d] || 0) + 1;
            }
        }
        const result = {};
        const posKeys = ["A", "B", "C", "D", "E"].slice(0, posCount);
        for (const pos of posKeys) {
            const topList = (predicted[hari] && predicted[hari][pos]) ? predicted[hari][pos] : [];
            const top5 = topList.slice(0, 5);
            const top3 = topList.slice(0, 3);
            const freqObj = globalCount[pos] || {};
            const sortedAll = Object.entries(freqObj).sort((a, b) => a[1] - b[1] || parseInt(a[0]) - parseInt(b[0]));
            const weak = sortedAll.slice(0, 3).map(x => x[0]);
            const dead = sortedAll.slice(0, 2).map(x => x[0]);
            result[pos] = { top5, top3, weak, dead };
        }
        const combosAB = {}; const combosCD = {};
        for (const r of allRows) {
            if (r.digits.length < 4) continue;
            const ab = r.digits[0] + r.digits[1];
            const cd = r.digits[2] + r.digits[3];
            combosAB[ab] = (combosAB[ab] || 0) + 1;
            combosCD[cd] = (combosCD[cd] || 0) + 1;
            if (posCount === 5 && r.digits.length >= 5) {
                const de = r.digits[3] + r.digits[4];
                combosCD[de] = (combosCD[de] || 0) + 1;
            }
        }
        const top2D_AB = Object.entries(combosAB).sort((a, b) => b[1] - a[1]).slice(0, 10).map(x => x[0]);
        const top2D_CD = Object.entries(combosCD).sort((a, b) => b[1] - a[1]).slice(0, 10).map(x => x[0]);
        let html = "<pre class=&apos;small&apos;>===\n";
html += "POOL " + poolFile.replace(".txt", "") + "   Hari : " + hari + "\n";
html += "===\n";
html += "POSISI\tTOP 5\t\tTOP 3\t\tLEMAH 3D\tMATI 2D\n</pre>";

        for (const pos of posKeys) {
            const d = result[pos];
            const top5Html = d.top5.map(x => `<span class=&apos;color-top5&apos;>${x}</span>`).join(", ");
            const top3Html = d.top3.map(x => `<span class=&apos;color-top3&apos;>${x}</span>`).join(", ");
            const weakHtml = d.weak.map(x => `<span class=&apos;color-lemah&apos;>${x}</span>`).join(", ");
            const deadHtml = d.dead.map(x => `<span class=&apos;color-mati&apos;>${x}</span>`).join(", ");
            html += `<div style=&apos;margin:6px 0;&apos;>${pos}. &nbsp; ${top5Html} &nbsp;&nbsp; ${top3Html} &nbsp;&nbsp; ${weakHtml} &nbsp;&nbsp; ${deadHtml}</div>`;
        }
        html += `<div style=&apos;margin-top:8px&apos;><strong>Top 2D AB :</strong> ${top2D_AB.slice(0, 10).join("*")}<br>`;
html += `<strong>Top 2D ${posCount === 5 ? &apos;DE&apos; : &apos;CD&apos;} :</strong> ${top2D_CD.slice(0, 10).join("*")}</div>`;
        html += "<div class=&apos;muted&apos; style=&apos;margin-top:8px&apos;>Warna:  Top 3   Top 5   Lemah   Mati</div>";
        html += "<div style=&apos;margin-top:8px&apos;><button id=&apos;btnExportAnalisa&apos; class=&apos;ghost&apos;>Ekspor Hasil Analisa (.txt)</button></div>";
        resultTableArea.innerHTML = html;
        let txtOut = `POOL ${poolFile.replace(&apos;.txt&apos;, &apos;&apos;)} HARI: ${hari}\\n`;
        for (const pos of posKeys) {
            const d = result[pos];
            txtOut += `${pos}. TOP5:${d.top5.join(&apos;,&apos;)} TOP3:${d.top3.join(&apos;,&apos;)} Lemah:${d.weak.join(&apos;,&apos;)} Mati:${d.dead.join(&apos;,&apos;)}\\n`;
        }
        txtOut += `Top2D AB: ${top2D_AB.slice(0, 10).join(&apos;*&apos;)}\nTop2D ${posCount === 5 ? &apos;DE&apos; : &apos;CD&apos;}: ${top2D_CD.slice(0, 10).join(&apos;*&apos;)}\n`;
        lastAnalysisResult = txtOut;
        setTimeout(() => {
            const btnExp = document.getElementById(&apos;btnExportAnalisa&apos;);
            if (btnExp) {
                btnExp.onclick = function () {
                    const blob = new Blob([lastAnalysisResult], { type: &apos;text/plain&apos; });
                    const a = document.createElement(&apos;a&apos;);
                    a.href = URL.createObjectURL(blob);
                    a.download = &apos;Hasil_Analisa_&apos; + poolFile.replace(&apos;.txt&apos;, &apos;&apos;) + &apos;.txt&apos;;
                    a.click();
                };
            }
        }, 200);
    });
    btnSaveHistory.addEventListener("click", () => {
        const html = resultTableArea.innerHTML;
        const rekap = rekapArea.innerHTML;
        const meta = resultSummary.innerText || "Snapshot";
        if (!html) { alert("Tidak ada hasil untuk disimpan."); return; }
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
        history.push({ when: new Date().toISOString(), meta, html, rekap });
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        alert("Hasil disimpan ke history localStorage.");
    });
    btnShowHistory.addEventListener("click", () => {
        const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || "[]");
        if (history.length === 0) { historyArea.innerHTML = "<div class=&apos;muted&apos;>Belum ada history tersimpan.</div>"; return; }
        historyArea.innerHTML = "";
        for (const h of history.slice().reverse()) {
            const box = document.createElement("div");
            box.style.borderTop = "1px dashed rgba(255,255,255,0.03)";
            box.style.padding = "8px 0";
            box.innerHTML = `<div class="smallmuted">${h.when}  ${h.meta}</div>${h.html}<div style="margin-top:6px">${h.rekap}</div>`;
            historyArea.appendChild(box);
        }
    });
    btnClearHistory.addEventListener("click", () => {
        if (!confirm("Hapus semua history yang tersimpan?")) return;
        localStorage.removeItem(HISTORY_KEY);
        historyArea.innerHTML = "";
        alert("History dihapus.");
    });

    // --- Initial Load ---
    refreshFileList();
    refreshPoolSelect();
}


// ==============================
// MODULE: PREDIKSI (ditambahkan, robust fallback)
// ==============================
(function(){
    function weekdayFromISO(iso){
        if(!iso) return null;
        try {
            const d = new Date(iso + "T00:00:00");
            const map = ["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"];
            return map[d.getDay()];
        } catch(e){
            return null;
        }
    }

    function safeDetect4or5(filename){
        try {
            if(typeof detect4or5FromFileContent === &apos;function&apos;){
                return detect4or5FromFileContent(filename);
            }
        } catch(e){}
        // fallback: inspect content
        try {
            const txt = loadFileFromStorage(filename) || "";
            const rows = parsePoolText(txt);
            if(rows && rows.length>0) return (rows[rows.length-1].digits.length>=5)?5:4;
        } catch(e){}
        return 4;
    }

    // Local fallback for computeTopN if not present
    function localComputeTopN(historyRows, posCount, topN, dateFromDDMM, dateToDDMM){
        // very small, safe implementation mirroring earlier logic
        const weekdays = ["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"];
        const counters = {};
        for(const w of weekdays){ counters[w]={}; for(let i=0;i<posCount;i++){ counters[w][["A","B","C","D","E"][i]] = {}; } }
        const fromISO = dateFromDDMM? (isoFromDDMM ? isoFromDDMM(dateFromDDMM) : null) : null;
        const toISO = dateToDDMM? (isoFromDDMM ? isoFromDDMM(dateToDDMM) : null) : null;
        for(const r of historyRows){
            const iso = (typeof isoFromDDMM === &apos;function&apos;) ? isoFromDDMM(r.date) : (r.date.split(&apos;/&apos;).reverse().join(&apos;-&apos;));
            if(fromISO && iso < fromISO) continue;
            if(toISO && iso > toISO) continue;
            const d = new Date(iso + "T00:00:00");
            const w = weekdays[d.getDay()];
            for(let i=0;i<posCount && i<r.digits.length;i++){
                const pos = ["A","B","C","D","E"][i];
                const dgt = r.digits[i];
                counters[w][pos][dgt] = (counters[w][pos][dgt]||0)+1;
            }
        }
        const topResult = {};
        for(const w of Object.keys(counters)){
            topResult[w] = {};
            for(const pos of Object.keys(counters[w])){
                const items = Object.entries(counters[w][pos]);
                items.sort((a,b)=> b[1]-a[1] || parseInt(a[0]) - parseInt(b[0]));
                const top = items.slice(0,topN).map(x=>x[0]);
                if(top.length < topN){
                    for(let d=0; d<=9 && top.length<topN; d++){
                        if(!top.includes(String(d))) top.push(String(d));
                    }
                }
                topResult[w][pos] = top;
            }
        }
        return topResult;
    }

    // reuse some existing functions if present, otherwise define local helpers
    function freqPerPositionForWeekday(rows, posCount, weekdayName){
        if(typeof window.pred_freqPerPositionForWeekday === &apos;function&apos;) return window.pred_freqPerPositionForWeekday(rows,posCount,weekdayName);
        const counters = {};
        for(let i=0;i<posCount;i++) counters[["A","B","C","D","E"][i]] = {};
        for(const r of rows){
            const iso = (typeof isoFromDDMM === &apos;function&apos;) ? isoFromDDMM(r.date) : (r.date.split(&apos;/&apos;).reverse().join(&apos;-&apos;));
            const d = new Date(iso + "T00:00:00");
            const w = ["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"][d.getDay()];
            if(w !== weekdayName) continue;
            for(let i=0;i<posCount && i<r.digits.length;i++){
                const pos = ["A","B","C","D","E"][i];
                const dgt = r.digits[i];
                counters[pos][dgt] = (counters[pos][dgt]||0)+1;
            }
        }
        return counters;
    }

    function compute2DForWeekday(rows, is5D, weekdayName){
        const freq = { AB:{}, X:{} };
        for(const r of rows){
            const iso = (typeof isoFromDDMM === &apos;function&apos;) ? isoFromDDMM(r.date) : (r.date.split(&apos;/&apos;).reverse().join(&apos;-&apos;));
            const d = new Date(iso + "T00:00:00");
            const w = ["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"][d.getDay()];
            if(w !== weekdayName) continue;
            if(r.digits.length>=2){
                const ab = r.digits[0] + r.digits[1];
                freq.AB[ab] = (freq.AB[ab]||0)+1;
            }
            if(is5D){
                if(r.digits.length>=5){
                    const de = r.digits[3] + r.digits[4];
                    freq.X[de] = (freq.X[de]||0)+1;
                }
            } else {
                if(r.digits.length>=4){
                    const cd = r.digits[2] + r.digits[3];
                    freq.X[cd] = (freq.X[cd]||0)+1;
                }
            }
        }
        const sortTop = (obj,limit=30)=> Object.entries(obj).sort((a,b)=>b[1]-a[1]).slice(0,limit).map(x=>x[0]);
        return { AB: sortTop(freq.AB,30), X: sortTop(freq.X,30) };
    }

    function computeBBFS(rows, posCount, weekdayName){
        const counters = freqPerPositionForWeekday(rows,posCount,weekdayName);
        const tops = {};
        for(const pos of Object.keys(counters)){
            const arr = Object.entries(counters[pos]).sort((a,b)=>b[1]-a[1]).map(x=>x[0]);
            tops[pos] = arr.length? arr.slice(0,4) : ["0","1","2","3"];
        }
        const posList = Object.keys(tops).slice(0,posCount);
        const combos = new Set();
        function cart(i, acc){
            if(combos.size>=100) return;
            if(i===posList.length){ combos.add(acc.join("")); return; }
            const pos = posList[i];
            for(const d of tops[pos]){ cart(i+1, acc.concat([String(d).padStart(1,&apos;0&apos;)])); if(combos.size>=100) break; }
        }
        cart(0,[]);
        const combosArr = Array.from(combos);
        const selected6 = combosArr.slice(0,6);
        const totalCounter = {};
        for(const pos of Object.keys(counters)){ for(const [d,c] of Object.entries(counters[pos])) totalCounter[d]=(totalCounter[d]||0)+c; }
        const topDigitsAll = Object.entries(totalCounter).sort((a,b)=>b[1]-a[1]).map(x=>x[0]);
        const cb = topDigitsAll.slice(0,2);
        return { bbfs:selected6, cb };
    }

    function computeAngkaMati(rows,posCount,weekdayName){
        const counters = freqPerPositionForWeekday(rows,posCount,weekdayName);
        const out = {};
        for(const pos of Object.keys(counters)){
            const arr = Object.entries(counters[pos]);
            const map = {};
            for(const [d,c] of arr) map[d]=c;
            for(let d=0; d<=9; d++) if(map[String(d)]===undefined) map[String(d)] = 0;
            const least = Object.entries(map).sort((a,b)=>a[1]-b[1] || parseInt(a[0])-parseInt(b[0])).slice(0,2).map(x=>x[0]);
            out[pos] = least;
        }
        return out;
    }

    // init function
    window.initPrediksi = function(){
        try {
            const sel = document.getElementById(&apos;predPoolSelect&apos;);
            const predDate = document.getElementById(&apos;predDate&apos;);
            const predDayInfo = document.getElementById(&apos;predDayInfo&apos;);
            const runBtn = document.getElementById(&apos;runPredBtn&apos;);
            const saveBtn = document.getElementById(&apos;savePredBtn&apos;);
            const clearBtn = document.getElementById(&apos;clearPredBtn&apos;);
            const outArea = document.getElementById(&apos;outputPrediksi&apos;);

            if(!sel || !predDate || !runBtn || !outArea) return;

            function populate(){
                const files = listStoredFiles();
                const prev = sel.value;
                sel.innerHTML = "<option value=&apos;&apos;>-- Pilih Pool --</option>";
                for(const f of files){ const o = document.createElement(&apos;option&apos;); o.value=f; o.textContent=f; sel.appendChild(o); }
                if(prev && Array.from(sel.options).some(o=>o.value===prev)) sel.value = prev;
            }
            populate();

            predDate.addEventListener(&apos;change&apos;, ()=>{
                predDayInfo.innerText = predDate.value ? (&apos;Hari prediksi: &apos; + weekdayFromISO(predDate.value)) : &apos;&apos;;
            });

            runBtn.addEventListener(&apos;click&apos;, ()=>{
                outArea.value = &apos;&apos;;
                const pool = sel.value;
                if(!pool){ outArea.value = &apos;Error: Pilih pool terlebih dahulu.&apos;; return; }
                const txt = loadFileFromStorage(pool);
                if(!txt){ outArea.value = &apos;Error: File pool tidak ditemukan di localStorage.&apos;; return; }
                const rows = parsePoolText(txt);
                if(!rows || rows.length===0){ outArea.value = &apos;Error: Tidak ada baris data valid dalam file pool.&apos;; return; }
                const is5 = safeDetect4or5(pool)===5;
                const posCount = is5 ? 5 : 4;
                const iso = predDate.value;
                if(!iso){ outArea.value = &apos;Error: Pilih tanggal prediksi terlebih dahulu.&apos;; return; }
                const dayName = weekdayFromISO(iso);
                if(!dayName){ outArea.value = &apos;Error: Gagal menentukan hari dari tanggal.&apos;; return; }

                let out = `PREDIKSI untuk pool: ${pool}\nTanggal: ${iso} (${dayName})\nTipe: ${is5? &apos;5D&apos;:&apos;4D&apos;}\n\n`;

                // TopN: use computeTopN if available otherwise localComputeTopN
                if(document.getElementById(&apos;predTopNCheck&apos;) && document.getElementById(&apos;predTopNCheck&apos;).checked){
                    const topN = parseInt(document.getElementById(&apos;predTopNValue&apos;).value) || 9;
                    let topRes = null;
                    try {
                        if(typeof computeTopN === &apos;function&apos;) topRes = computeTopN(rows, posCount, topN, null, null);
                        else topRes = localComputeTopN(rows, posCount, topN, null, null);
                    } catch(e){
                        console.error(&apos;TopN error&apos;, e);
                        topRes = localComputeTopN(rows, posCount, topN, null, null);
                    }
                    out += "=== Prediksi Top N (posisi) ===\n";
                    const dayTop = topRes[dayName] || {};
                    for(const pos of ["A","B","C","D","E"].slice(0,posCount)){
                        const vals = (dayTop[pos]||[]).slice(0,topN).join(&apos;,&apos;);
                        out += `${pos}. ${vals}\n`;
                    }
                    out += "\n";
                }

                // BK & GE
                if(document.getElementById(&apos;predBkGeCheck&apos;) && document.getElementById(&apos;predBkGeCheck&apos;).checked){
                    const counters = freqPerPositionForWeekday(rows,posCount,dayName);
                    const bkge = (typeof pred_computeBkGeFromCounters === &apos;function&apos;) ? pred_computeBkGeFromCounters(counters) : (function(c){
                        const outt = {};
                        for(const pos of Object.keys(c)){ let besar=0,kecil=0,ganjil=0,genap=0; for(const [d,ct] of Object.entries(c[pos])){ const n=parseInt(d); if(n>=5) besar+=ct; else kecil+=ct; if(n%2===0) genap+=ct; else ganjil+=ct; } outt[pos]={BK: besar>=kecil?&apos;Besar&apos;:&apos;Kecil&apos;, GE: ganjil>=genap?&apos;Ganjil&apos;:&apos;Genap&apos;, stats:{besar,kecil,ganjil,genap}} }
                        return outt;
                    })(counters);
                    out += "=== Prediksi BK & GE ===\n";
                    for(const pos of ["A","B","C","D","E"].slice(0,posCount)){
                        const p = bkge[pos]||{BK:&apos;-&apos;,GE:&apos;-&apos;,stats:{besar:0,kecil:0,ganjil:0,genap:0}};
                        out += `${pos}: BK=${p.BK}, GE=${p.GE} (besar=${p.stats.besar},kecil=${p.stats.kecil},ganjil=${p.stats.ganjil},genap=${p.stats.genap})\n`;
                    }
                    out += "\n";
                }

                // 2D
                if(document.getElementById(&apos;pred2DCheck&apos;) && document.getElementById(&apos;pred2DCheck&apos;).checked){
                    const two = compute2DForWeekday(rows,is5,dayName);
                    out += "=== Prediksi 2D Depan-Belakang ===\n";
                    out += `Top AB: ${two.AB.slice(0,12).join(&apos;,&apos;)}\n`;
                    out += `Top ${is5? &apos;DE&apos;:&apos;CD&apos;}: ${two.X.slice(0,12).join(&apos;,&apos;)}\n\n`;
                }

                // BBFS
                if(document.getElementById(&apos;predBbfsCheck&apos;) && document.getElementById(&apos;predBbfsCheck&apos;).checked){
                    const bb = computeBBFS(rows,posCount,dayName);
                    out += "=== Prediksi BBFS (6 kombinasi kandidat) ===\n";
                    out += (bb.bbfs && bb.bbfs.length? bb.bbfs.join(&apos;,&apos;) : &apos;-&apos;) + "\n";
                    out += "CB (2 angka): " + (bb.cb? bb.cb.join(&apos;,&apos;) : &apos;-&apos;) + "\n\n";
                }

                // Angka Mati
                if(document.getElementById(&apos;predMatiCheck&apos;) && document.getElementById(&apos;predMatiCheck&apos;).checked){
                    const mati = computeAngkaMati(rows,posCount,dayName);
                    out += "=== Prediksi Angka Mati (2 angka per posisi) ===\n";
                    for(const pos of ["A","B","C","D","E"].slice(0,posCount)){
                        out += `${pos}: ${mati[pos] ? mati[pos].join(&apos;,&apos;) : &apos;-&apos;}\n`;
                    }
                    out += "\n";
                }

                outArea.value = out;
            });

            saveBtn && saveBtn.addEventListener(&apos;click&apos;, ()=>{
                const v = outArea.value;
                if(!v){ outArea.value = &apos;Belum ada hasil prediksi untuk disimpan.&apos;; return; }
                try {
                    const blob = new Blob([v], {type:&apos;text/plain;charset=utf-8&apos;});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement(&apos;a&apos;);
                    a.href = url;
                    const fname = `prediksi_${sel.value || &apos;pool&apos;}_${new Date().toISOString().slice(0,10)}.txt`;
                    a.download = fname;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch(e){
                    outArea.value = &apos;Gagal menyimpan file: &apos; + (e && e.message || e);
                }
            });

            clearBtn && clearBtn.addEventListener(&apos;click&apos;, ()=>{
                outArea.value = &apos;&apos;;
            });

            // also repopulate when ATAR refresh button clicked (if exists)
            const refreshBtn = document.getElementById(&apos;btnRefresh&apos;);
            if(refreshBtn) refreshBtn.addEventListener(&apos;click&apos;, populate);

        } catch(e){
            console.error(&apos;initPrediksi error&apos;, e);
        }
    };
})();

</script>

<script>
(function(){
    // Matrix settings
    const colors = [&apos;#00ffff&apos;,&apos;#ff00ff&apos;,&apos;#b6f47b&apos;,&apos;#fff06a&apos;,&apos;#ff8c42&apos;,&apos;#b36ff6&apos;,&apos;#dd1166&apos;];
    const canvas = document.getElementById(&apos;matrixBg&apos;);
    const overlay = document.getElementById(&apos;matrixOverlayGlow&apos;);
    let ctx, W, H, fontSize = 20, columns, drops;

    function setupCanvas(){
        if(!canvas) return;
        ctx = canvas.getContext(&apos;2d&apos;);
        function resize(){
            W = canvas.width = window.innerWidth;
            H = canvas.height = window.innerHeight;
            fontSize = Math.max(14, Math.min(26, Math.floor(Math.min(W,H)/60)));
            columns = Math.floor(W / fontSize) || 1;
            drops = new Array(columns).fill(1).map(()=> Math.floor(Math.random()*H/fontSize));
        }
        resize();
        window.addEventListener(&apos;resize&apos;, resize);
    }

    function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
    function pickColor(){ return colors[randInt(0,colors.length-1)]; }

    function draw(){
        if(!ctx) return;
        // translucent background to create trail
        ctx.fillStyle = &apos;rgba(0,0,0,0.15)&apos;;
        ctx.fillRect(0,0,W,H);

        ctx.font = fontSize + &apos;px monospace&apos;;
        ctx.textBaseline = &apos;top&apos;;
        for(let i=0;i<columns;i++){
            const text = String(randInt(0,9));
            const x = i * fontSize;
            const y = (drops[i] * fontSize) % H;
            // glow style
            ctx.shadowColor = pickColor();
            ctx.shadowBlur = 14;
            ctx.fillStyle = pickColor();
            ctx.fillText(text, x, y);
            // move drop
            if(y > H && Math.random() > 0.975) {
                drops[i] = 0;
            } else {
                drops[i]++;
            }
        }
    }

    // animation loop at moderate fps
    let animId = null;
    function loop(){
        draw();
        animId = requestAnimationFrame(loop);
    }

    // start
    setupCanvas();
    setTimeout(()=>{ loop(); }, 120);

    // MENU TRANSITION COLORS mapping
    const menuColorMap = {
        &apos;pageDashboard&apos;: &apos;#b36ff6&apos;,
        &apos;pageAnalisa&apos;: &apos;#f16640&apos;,
        &apos;pagePermutasi&apos;: &apos;#717e73&apos;,
        &apos;pageAtar&apos;: &apos;#dd1166&apos;,
        &apos;pagePrediksi&apos;: &apos;#b36ff6&apos;
    };

    function applyMenuColor(hex){
        document.documentElement.style.setProperty(&apos;--menu-bg-color&apos;, hex);
        const glow = hexToRgba(hex, 0.12);
        document.documentElement.style.setProperty(&apos;--glow-color&apos;, glow);
        if(overlay) overlay.style.background = `radial-gradient(circle at 50% 30%, ${hex}22, transparent 30%)`;
        document.body.style.transition = &apos;background 1.5s ease, box-shadow 1.5s ease&apos;;
        document.body.style.background = `radial-gradient(circle at 20% 20%, ${hex}20, transparent 40%), radial-gradient(circle at 80% 80%, ${hex}10, transparent 60%), #050506`;
    }

    function hexToRgba(hex, alpha){
        const c = hex.replace(&apos;#&apos;,&apos;&apos;);
        const r = parseInt(c.substring(0,2),16);
        const g = parseInt(c.substring(2,4),16);
        const b = parseInt(c.substring(4,6),16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    document.addEventListener(&apos;DOMContentLoaded&apos;, function(){
        const navs = document.querySelectorAll(&apos;.nav-btn&apos;);
        navs.forEach(btn=>{
            btn.addEventListener(&apos;click&apos;, ()=>{
                const tgt = btn.getAttribute(&apos;data-target&apos;);
                const color = menuColorMap[tgt] || &apos;#b36ff6&apos;;
                applyMenuColor(color);
                const hdr = document.querySelector(&apos;header&apos;);
                if(hdr){
                    hdr.style.boxShadow = `0 0 30px ${hexToRgba(color,0.35)}`;
                    setTimeout(()=>{ hdr.style.boxShadow = &apos;&apos;; }, 1600);
                }
            });
        });
        const active = document.querySelector(&apos;.nav-btn.active&apos;);
        if(active){
            const tgt = active.getAttribute(&apos;data-target&apos;);
            const color = menuColorMap[tgt] || &apos;#b36ff6&apos;;
            applyMenuColor(color);
        }
    });

    if(window.innerWidth < 640){
        if(canvas) canvas.style.opacity = &apos;0.7&apos;;
    }
})();
<script>
if (&apos;serviceWorker&apos; in navigator) {
  window.addEventListener(&apos;load&apos;, () => {
    navigator.serviceWorker.register(&apos;sw.js&apos;)
      .then(() => console.log(&apos;Service worker registered &apos;))
      .catch(err => console.error(&apos;SW registration failed:&apos;, err));
  });
}
</script>

</body>
</html>' frameborder="0" style="width:100%;height:calc(100vh - 80px);border:none;"></iframe>
    </section>
    
    
    <section id="pageMatrixPro" class="spa-page" style="display:none;">
        <iframe srcdoc='<!DOCTYPE html>

<html lang="id">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>MATRIX PRO V1.5</title>
<style>
/* === Tampilan dropdown pool menyerupai tombol menu hijau === */
select.form-control,
select.form-control option {
  background-color: var(--neon-green);
  color: var(--dark-bg);
  font-weight: 700;
  border: 2px solid var(--neon-green);
  text-shadow: 0 0 5px rgba(0, 0, 0, 0.4);
}

select.form-control:focus {
  outline: none;
  box-shadow: 0 0 15px var(--neon-green);
  background-color: #00ff66;
  color: var(--dark-bg);
}

/* Theme and layout */
:root {
  --neon-yellow: #ffff00;
  --neon-green: #00ff00;
  --neon-red: #ff0066;
  --neon-white: #ffffff;
  --neon-purple: #ff00ff;
  --neon-blue: #00ccff;
  --dark-bg: #0a0a0a;
  --card-bg: rgba(20,20,30,0.85);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: &apos;Courier New&apos;, monospace;
  background: var(--dark-bg);
  color: var(--neon-white);
  min-height: 100vh;
  overflow-x: hidden;
  position: relative;
}

.bg-animation {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}

.falling-number {
  position: absolute;
  font-family: monospace;
  animation: fall linear infinite;
  opacity: .85;
}

.small-number {
  font-size: 12px;
  color: var(--neon-green);
  text-shadow: 0 0 15px currentColor;
}

.medium-number {
  font-size: 18px;
  font-weight: bold;
  text-shadow: 0 0 20px currentColor;
}

@keyframes fall {
  to { transform: translateY(200vh); }
}

.container {
  position: relative;
  z-index: 1;
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.header {
  text-align: center;
  padding: 30px 0;
  position: relative;
}

.title {
  font-size: clamp(2rem, 5vw, 3rem);
  font-weight: 700;
  background: linear-gradient(45deg, var(--neon-yellow), var(--neon-purple));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 0 0 30px rgba(255,255,0,.5);
  animation: glow 2s ease-in-out infinite alternate;
}

@keyframes glow {
  from { filter: drop-shadow(0 0 20px rgba(255,255,0,.5)); }
  to { filter: drop-shadow(0 0 30px rgba(255,0,255,.8)); }
}

.nav-container {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin: 15px 0;
  flex-wrap: wrap;
}

.nav-btn {
  padding: 10px 18px;
  background: transparent;
  border: 2px solid var(--neon-green);
  color: var(--neon-green);
  cursor: pointer;
  font-weight: 700;
  position: relative;
  overflow: hidden;
  transition: all .25s;
  text-transform: uppercase;
}

.nav-btn:before {
  content: &apos;&apos;;
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
  transition: left .5s;
}

.nav-btn:hover:before {
  left: 100%;
}

.nav-btn.active {
  background: var(--neon-green);
  color: var(--dark-bg);
  box-shadow: 0 0 30px var(--neon-green);
}

.content-section {
  display: none;
  background: var(--card-bg);
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 10px;
  padding: 20px;
  backdrop-filter: blur(8px);
  box-shadow: 0 8px 32px rgba(0,255,0,.06);
}

.content-section.active {
  display: block;
}

.data-table {
  width: 100%;
  border-collapse: collapse;
  margin: 12px 0;
}

.data-table th,
.data-table td {
  padding: 10px;
  text-align: left;
  border: 1px solid rgba(255,255,255,.12);
}

.data-table th {
  background: rgba(255,255,0,.08);
  color: var(--neon-yellow);
  text-transform: uppercase;
}

.date-row {
  background: rgba(255,255,0,.04);
  font-weight: 700;
}

.form-control {
  width: 100%;
  padding: 10px;
  background: rgba(255,255,255,.04);
  border: 1px solid var(--neon-green);
  color: var(--neon-white);
  border-radius: 6px;
}

.btn {
  padding: 8px 16px;
  background: linear-gradient(45deg, var(--neon-green), var(--neon-yellow));
  border: none;
  color: var(--dark-bg);
  font-weight: 700;
  cursor: pointer;
  border-radius: 6px;
}

.submenu {
  display: flex;
  gap: 10px;
  margin: 10px 0;
  flex-wrap: wrap;
}

.submenu-btn {
  padding: 8px 12px;
  background: transparent;
  border: 1px solid var(--neon-purple);
  color: var(--neon-purple);
  cursor: pointer;
  border-radius: 6px;
}

.submenu-btn.active {
  background: var(--neon-purple);
  color: var(--dark-bg);
  box-shadow: 0 0 12px var(--neon-purple);
}

.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,.9);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 999;
}

.loading-text {
  font-size: 1.6rem;
  color: var(--neon-green);
  animation: glitch .35s infinite;
}

@keyframes glitch {
  0%, 100% { text-shadow: 2px 0 var(--neon-red), -2px 0 var(--neon-blue); }
  25% { text-shadow: -2px 0 var(--neon-red), 2px 0 var(--neon-blue); }
  50% { text-shadow: 2px 0 var(--neon-blue), -2px 0 var(--neon-red); }
  75% { text-shadow: -2px 0 var(--neon-blue), 2px 0 var(--neon-red); }
}

/* Accuracy result colors */
.win5d {
  color: var(--neon-green);
  font-weight: 800;
  text-shadow: 0 0 8px rgba(0,255,0,0.6);
  animation: glowPulse 1.2s ease-in-out infinite;
}

.win4d {
  color: var(--neon-yellow);
  font-weight: 800;
  text-shadow: 0 0 8px rgba(255,255,0,0.6);
  animation: glowPulse 1.2s ease-in-out infinite;
}

.win3d {
  color: var(--neon-blue);
  font-weight: 800;
  text-shadow: 0 0 8px rgba(0,204,255,0.6);
  animation: glowPulse 1.2s ease-in-out infinite;
}

.lose {
  color: var(--neon-red);
  font-weight: 800;
  text-shadow: 0 0 8px rgba(255,0,102,0.6);
}

@keyframes glowPulse {
  0% { filter: brightness(1); transform: translateY(0); }
  50% { filter: brightness(1.18); transform: translateY(-2px); }
  100% { filter: brightness(1); transform: translateY(0); }
}

.accuracy-block {
  padding: 12px;
  background: rgba(0,0,0,0.35);
  border-radius: 8px;
}

.accuracy-line {
  display: flex;
  gap: 12px;
  align-items: center;
  margin: 6px 0;
}

.atar-label {
  width: 90px;
  font-weight: 700;
}

/* Database Management Styles */
.db-list-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  margin: 6px 0;
  background: rgba(255,255,255,.03);
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,.1);
}

.db-list-item.active {
  background: rgba(0,255,0,.1);
  border-color: var(--neon-green);
}

.db-name {
  font-weight: 700;
}

.db-info {
  font-size: 0.8em;
  color: var(--neon-blue);
}

.db-actions {
  display: flex;
  gap: 8px;
}

.db-action-btn {
  padding: 4px 8px;
  background: transparent;
  border: 1px solid;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8em;
}

.db-use-btn {
  border-color: var(--neon-green);
  color: var(--neon-green);
}

.db-delete-btn {
  border-color: var(--neon-red);
  color: var(--neon-red);
}

/* Permutasi Styles */
.perm-inputs {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 15px;
  margin: 15px 0;
}

.perm-input-group {
  padding: 15px;
  background: rgba(255,255,255,.05);
  border-radius: 8px;
  border: 1px solid var(--neon-purple);
}

.perm-input {
  width: 100%;
  padding: 12px;
  font-size: 18px;
  text-align: center;
  background: rgba(0,0,0,.7);
  border: 2px solid var(--neon-green);
  color: var(--neon-white);
  border-radius: 6px;
  margin-bottom: 10px;
}

.pangkas-options {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 5px;
}

.pangkas-options label {
  font-size: 11px;
  display: flex;
  align-items: center;
  gap: 3px;
}

.pangkas-options input[type="checkbox"] {
  width: auto;
  margin: 0;
}

/* Analisis Styles */
.analysis-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 15px;
  margin: 15px 0;
}

.analysis-card {
  padding: 15px;
  background: rgba(255,255,255,.05);
  border-radius: 8px;
  border: 1px solid var(--neon-blue);
}

.analysis-card h4 {
  color: var(--neon-blue);
  margin-bottom: 10px;
}

.position-result {
  margin-bottom: 10px;
  padding: 8px;
  background: rgba(0,0,0,.3);
  border-radius: 5px;
}

.position-title {
  font-weight: bold;
  color: var(--neon-yellow);
}

.position-data {
  color: var(--neon-green);
  font-family: monospace;
}

.chart-container {
  width: 100%;
  height: 250px;
  background: rgba(0,0,0,.3);
  border-radius: 8px;
  padding: 10px;
  margin: 10px 0;
}

.history-table-container {
  max-height: 300px;
  overflow-y: auto;
  margin: 15px 0;
  border: 1px solid var(--neon-blue);
  border-radius: 8px;
}

.history-table {
  width: 100%;
  border-collapse: collapse;
}

.history-table th {
  background: rgba(0,100,255,.3);
  color: var(--neon-blue);
  padding: 8px;
  text-align: left;
  position: sticky;
  top: 0;
}

.history-table td {
  padding: 6px 8px;
  border-bottom: 1px solid rgba(255,255,255,.1);
}

.history-table tr:hover {
  background: rgba(255,255,255,.05);
}

@media (max-width: 768px) {
  .container { padding: 10px; }
  .nav-btn { padding: 8px 12px; font-size: .9rem; }
  .data-table th, .data-table td { padding: 8px; }
  .perm-inputs { grid-template-columns: 1fr; }
  .analysis-grid { grid-template-columns: 1fr; }
}

/* === Fade-in Animation for Section Transition === */
.content-section {
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.6s ease, transform 0.6s ease;
}
.content-section.active {
  display: block;
  opacity: 1;
  transform: translateY(0);
}

#shio .container, #bbfs .container {
  background: transparent !important;
  box-shadow: none !important;
  color: var(--neon-white);
  font-family: &apos;Courier New&apos;, monospace;
}
#shio h1, #bbfs h1, #shio h2, #bbfs h2 {
  background: linear-gradient(45deg, var(--neon-yellow), var(--neon-green), var(--neon-blue));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-align: center;
  text-shadow: 0 0 20px rgba(0,255,0,0.5);
}
#shio .card, #bbfs .input-group, #bbfs .analysis-control, #bbfs .analysis-section {
  background: rgba(255,255,255,.05) !important;
  border: 1px solid rgba(0,255,0,.3) !important;
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 0 20px rgba(0,255,0,0.1);
}
#shio .btn, #bbfs button {
  background: linear-gradient(45deg, var(--neon-green), var(--neon-yellow));
  border: none;
  color: var(--dark-bg);
  font-weight: 700;
  cursor: pointer;
  border-radius: 6px;
  box-shadow: 0 0 10px var(--neon-green);
  transition: all .25s;
}
#shio .btn:hover, #bbfs button:hover {
  background: linear-gradient(45deg, var(--neon-yellow), var(--neon-green));
  box-shadow: 0 0 20px var(--neon-green);
}
#shio select, #bbfs select, #shio input, #bbfs input {
  background: rgba(0,0,0,.6);
  color: var(--neon-white);
  border: 1px solid var(--neon-green);
  border-radius: 6px;
  padding: 8px;
}
#shio table, #bbfs table {
  width: 100%;
  border-collapse: collapse;
  background: rgba(0,0,0,.3);
}
#shio th, #bbfs th {
  background: rgba(0,255,0,.15);
  color: var(--neon-yellow);
  padding: 8px;
}
#shio td, #bbfs td {
  border: 1px solid rgba(0,255,0,.2);
  padding: 6px;
  color: var(--neon-white);
}
#shio .data-info, #bbfs .message {
  color: var(--neon-green);
  text-align: center;
  margin-top: 10px;
}
</style>
</head>
<body>
<canvas height="641" id="jackpotCanvas" style="display: none;" width="1366"></canvas>
<div id="jackpotOverlay" style="display: none;"><div id="jackpotText"> JACKPOT </div></div>
<div class="bg-animation" id="bgAnimation"></div>
<div class="loading-overlay" id="loadingOverlay"><div class="loading-text">Memproses data... Tunggu sebentar</div></div>
<div class="container">
<header class="header"><h1 class="title">MATRIX PRO V1.5</h1></header>
<nav class="nav-container">
<button class="nav-btn" onclick="showSection(&apos;prediction&apos;, this)"> PREDIKSI</button>
<button class="nav-btn" onclick="showSection(&apos;accuracy&apos;, this)"> AKURASI</button>
<button class="nav-btn active" onclick="showSection(&apos;upload&apos;, this)"> FILE BASIS</button>
<button class="nav-btn" onclick="showSection(&apos;history&apos;, this)"> RIWAYAT</button>
<button class="nav-btn" onclick="showSection(&apos;permutasi&apos;, this)"> PERMUTASI</button>
<button class="nav-btn" onclick="showSection(&apos;analisis&apos;, this)"> ANALISIS</button><button class="nav-btn" onclick="showSection(&apos;shio&apos;, this)"> SHIO</button><button class="nav-btn" onclick="showSection(&apos;bbfs&apos;, this)"> BBFS</button>
</nav>
<!-- SECTION PREDIKSI -->
<section class="content-section" id="prediction">
<h2 style="color:var(--neon-yellow);margin-bottom:12px">Prediksi Harian</h2>
<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:10px">
<div style="display:flex;gap:8px;align-items:center;">
<label for="startDate">Dari:</label>
<input class="form-control" id="startDate" style="width:auto" type="date"/>
<label for="endDate">Sampai:</label>
<input class="form-control" id="endDate" style="width:auto" type="date"/>
</div>
</div>
<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:10px">
<div class="submenu">
<button class="submenu-btn" id="btn4d" onclick="selectPoolType(&apos;4D&apos;, event)">4D</button>
<button class="submenu-btn active" id="btn5d" onclick="selectPoolType(&apos;5D&apos;, event)">5D</button>
</div>
<div style="flex:1;min-width:220px">
<select class="form-control" id="poolSelect" onchange="onPoolChange()"><option value="-">-- Tidak ada DB terdeteksi --</option></select>
</div>
<div>
<button class="btn" onclick="generatePredictionsFromDB()">Tampilkan Prediksi</button>
</div>
</div>
<div style="overflow:auto">
<table class="data-table" id="predictionTable">
<thead><tr><th>Hari/Tanggal</th><th>Posisi</th><th>ATAR 1</th><th>ATAR 2</th><th>ATAR 3</th><th>Catatan</th></tr></thead>
<tbody id="predictionBody"></tbody>
</table>
</div>
</section>
<!-- SECTION AKURASI -->
<section class="content-section" id="accuracy">
<h2 style="color:var(--neon-yellow);margin-bottom:12px">Cek Akurasi</h2>
<div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
<div style="min-width:220px"><select class="form-control" id="accuracyPoolSelect"><option value="-">-- Tidak ada DB terdeteksi --</option></select></div>
<div><input class="form-control" id="accuracyDate" type="date"/></div>
<div style="min-width:220px"><input class="form-control" id="accuracyResultInput" placeholder="Masukkan result, contoh 1234 atau 12345" type="text"/></div>
<div><button class="btn" onclick="checkAccuracy()">Cek</button></div>
</div>
<div id="accuracyOutput" style="margin-top:12px"></div>
</section>
<!-- SECTION UPLOAD -->
<section class="content-section active" id="upload">
<h2 style="color:var(--neon-yellow);margin-bottom:12px">Unggah File Basis</h2>
<div style="margin-bottom:15px;padding:12px;background:rgba(255,255,0,.05);border-radius:8px;border:1px solid var(--neon-yellow)">
<div style="font-weight:700;margin-bottom:8px;color:var(--neon-yellow)">Database Aktif:</div>
<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
<select class="form-control" id="activeDbSelect" onchange="switchActiveDatabase()" style="flex:1;min-width:200px"><option value="">-- Pilih Database --</option></select>
<div id="activeDbInfo" style="font-size:0.9em;color:var(--neon-green)">Tidak ada database aktif</div>
</div>
</div>
<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
<input accept=".txt" id="fileInput" style="display:none" type="file"/>
<button class="btn" onclick="document.getElementById(&apos;fileInput&apos;).click()">Pilih File</button>
<button class="btn" onclick="handleFileUpload()">Unggah File</button>
<button class="btn" onclick="loadStoredDB()">Muat Semua DB</button>
<button class="btn" onclick="clearAllDatabases()" style="background:linear-gradient(45deg,var(--neon-red),var(--neon-purple))">Hapus Semua DB</button>
</div>
<div style="margin-top:20px">
<div style="font-weight:700;margin-bottom:8px;color:var(--neon-yellow)">Database Tersimpan:</div>
<div id="databaseList" style="max-height:300px;overflow-y:auto;padding:8px;background:rgba(0,0,0,.3);border-radius:6px"><div style="padding:12px;text-align:center;color:var(--neon-yellow)">Tidak ada database tersimpan</div></div>
</div>
<div id="uploadStatus" style="margin-top:12px"></div>
<div style="margin-top:12px;background:rgba(255,255,255,.03);padding:10px;border-radius:8px">
<b>Petunjuk format:</b>
<div style="margin-top:6px">File harus mengikuti format seperti di DB_ATAR.txt / DB_DELTA.txt: blok dimulai dengan <code>POOL : NAME</code>, baris <code>Angka Tarung Hari &lt;Hari&gt;</code>, lalu baris <code>Posisi X: ... A: ... A: ... A: ...</code>.</div>
</div>
</section>
<!-- SECTION HISTORY -->
<section class="content-section" id="history">
<h2 style="color:var(--neon-yellow);margin-bottom:12px">Riwayat Hasil</h2>
<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:12px">
<button class="btn" onclick="clearHistory()" style="background:linear-gradient(45deg,var(--neon-red),var(--neon-purple))">Hapus Data History</button>
<button class="btn" onclick="exportToPDF()">Ekspor ke PDF</button>
<button class="btn" onclick="exportToExcel()">Ekspor ke Excel</button>
</div>
<div style="overflow:auto">
<table class="data-table">
<thead>
<tr>
<th class="history-header">TANGGAL</th>
<th class="history-header">POOL</th>
<th class="history-header">PREDIKSI</th>
<th class="history-header">RESULT</th>
<th class="history-header">STATUS</th>
<th class="history-header">AKURASI</th>
</tr>
</thead>
<tbody id="historyBody"></tbody>
</table>
</div>
</section>
<!-- SECTION PERMUTASI -->
<section class="content-section" id="permutasi">
<h2 style="color:var(--neon-yellow);margin-bottom:12px"> Sistem Permutasi Prediksi</h2>
<div style="margin-bottom:20px;padding:15px;background:rgba(255,255,0,.05);border-radius:8px;border:1px solid var(--neon-yellow)">
<div style="font-weight:700;margin-bottom:8px;color:var(--neon-yellow)">Manajemen Databasis:</div>
<div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
<input accept=".txt" id="databasisFile" style="display:none" type="file"/>
<button class="btn" onclick="document.getElementById(&apos;databasisFile&apos;).click()"> Upload Databasis</button>
<button class="btn" onclick="saveDatabasis()"> Simpan Databasis</button>
<button class="btn" onclick="loadDatabasisData()"> Load Data</button>
</div>
<div id="databasisInfo" style="margin-top:8px;font-size:0.9em;color:var(--neon-green)">
    Status: Databasis belum diupload
  </div>
</div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-bottom:15px">
<div>
<label style="display:block;margin-bottom:5px;color:var(--neon-green)">Pilih Pool:</label>
<select class="form-control" id="permPoolSelect" onchange="togglePositionE()">
<option value="">-- Pilih Pool --</option>
<optgroup label="4D">
<option value="TOK">TOKYO</option>
<option value="PPL">PPLOT</option>
<option value="CHI">CHIA</option>
<option value="SYD">SYDNEY</option>
<option value="HKG">HONGKONG</option>
<option value="SEO">SEOUL</option>
</optgroup>
<optgroup label="5D">
<option value="T15">T15</option>
<option value="T21">T21</option>
</optgroup>
</select>
</div>
<div>
<label style="display:block;margin-bottom:5px;color:var(--neon-green)">Pilih Tanggal:</label>
<input class="form-control" id="permDate" type="date"/>
</div>
</div>
<div style="margin-bottom:15px">
<label style="display:block;margin-bottom:8px;color:var(--neon-green);font-weight:bold">Input Angka Permutasi:</label>
<div class="perm-inputs" id="permInputs">
<div class="perm-input-group">
<label style="display:block;margin-bottom:5px;color:var(--neon-purple)">Posisi A</label>
<input class="perm-input" id="posA" maxlength="3" onkeyup="moveToNext(this, &apos;posB&apos;)" placeholder="Contoh: 123" type="text"/>
<div class="pangkas-options">
<label><input id="pangkasAOdd" type="checkbox"/> Ganjil</label>
<label><input id="pangkasAEven" type="checkbox"/> Genap</label>
<label><input id="pangkasABig" type="checkbox"/> Besar</label>
<label><input id="pangkasASmall" type="checkbox"/> Kecil</label>
</div>
</div>
<div class="perm-input-group">
<label style="display:block;margin-bottom:5px;color:var(--neon-purple)">Posisi B</label>
<input class="perm-input" id="posB" maxlength="3" onkeyup="moveToNext(this, &apos;posC&apos;)" placeholder="Contoh: 456" type="text"/>
<div class="pangkas-options">
<label><input id="pangkasBOdd" type="checkbox"/> Ganjil</label>
<label><input id="pangkasBEven" type="checkbox"/> Genap</label>
<label><input id="pangkasBBig" type="checkbox"/> Besar</label>
<label><input id="pangkasBSmall" type="checkbox"/> Kecil</label>
</div>
</div>
<div class="perm-input-group">
<label style="display:block;margin-bottom:5px;color:var(--neon-purple)">Posisi C</label>
<input class="perm-input" id="posC" maxlength="3" onkeyup="moveToNext(this, &apos;posD&apos;)" placeholder="Contoh: 789" type="text"/>
<div class="pangkas-options">
<label><input id="pangkasCOdd" type="checkbox"/> Ganjil</label>
<label><input id="pangkasCEven" type="checkbox"/> Genap</label>
<label><input id="pangkasCBig" type="checkbox"/> Besar</label>
<label><input id="pangkasCSmall" type="checkbox"/> Kecil</label>
</div>
</div>
<div class="perm-input-group">
<label style="display:block;margin-bottom:5px;color:var(--neon-purple)">Posisi D</label>
<input class="perm-input" id="posD" maxlength="3" onkeyup="moveToNext(this, &apos;posE&apos;)" placeholder="Contoh: 012" type="text"/>
<div class="pangkas-options">
<label><input id="pangkasDOdd" type="checkbox"/> Ganjil</label>
<label><input id="pangkasDEven" type="checkbox"/> Genap</label>
<label><input id="pangkasDBig" type="checkbox"/> Besar</label>
<label><input id="pangkasDSmall" type="checkbox"/> Kecil</label>
</div>
</div>
<div class="perm-input-group" id="posEGroup" style="display:none">
<label style="display:block;margin-bottom:5px;color:var(--neon-purple)">Posisi E</label>
<input class="perm-input" id="posE" maxlength="3" placeholder="Contoh: 345" type="text"/>
<div class="pangkas-options">
<label><input id="pangkasEOdd" type="checkbox"/> Ganjil</label>
<label><input id="pangkasEEven" type="checkbox"/> Genap</label>
<label><input id="pangkasEBig" type="checkbox"/> Besar</label>
<label><input id="pangkasESmall" type="checkbox"/> Kecil</label>
</div>
</div>
</div>
</div>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:15px">
<button class="btn" onclick="doPermutation()" style="flex:1"> Generate Permutasi</button>
<button class="btn" onclick="clearPermutationInputs()" style="background:linear-gradient(45deg,var(--neon-red),var(--neon-purple))"> Clear Input</button>
</div>
<div style="background:var(--card-bg);border:1px solid var(--neon-green);border-radius:8px;padding:15px;position:relative">
<button class="btn" onclick="copyPermutationResult()" style="position:absolute;top:10px;right:10px;padding:5px 10px;font-size:12px"> Salin</button>
<div id="permResult" style="min-height:100px;max-height:400px;overflow-y:auto">
<div style="text-align:center;color:var(--neon-yellow);padding:20px">
       Hasil permutasi akan ditampilkan di sini...
    </div>
</div>
</div>
<div id="permLoading" style="display:none;text-align:center;padding:20px">
<div style="color:var(--neon-green)">Melakukan permutasi...</div>
</div>
</section>
<!-- SECTION ANALISIS -->
<section class="content-section" id="analisis">
<h2 style="color:var(--neon-yellow);margin-bottom:12px"> Sistem Analisis Prediksi</h2>
<div style="margin-bottom:20px;padding:15px;background:rgba(0,255,255,.05);border-radius:8px;border:1px solid var(--neon-blue)">
<div style="font-weight:700;margin-bottom:8px;color:var(--neon-blue)">Manajemen Data History:</div>
<div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-bottom:10px">
<div>
<label style="display:block;margin-bottom:5px;color:var(--neon-blue)">Pilih Pool:</label>
<select class="form-control" id="analPoolSelect" onchange="updateHistoryButtons()">
<option value="">-- Pilih Pool --</option>
<optgroup label="4D">
<option value="TOK">TOKYO</option>
<option value="PPL">PPLOT</option>
<option value="CHI">CHIA</option>
<option value="SYD">SYDNEY</option>
<option value="HKG">HONGKONG</option>
<option value="SEO">SEOUL</option>
</optgroup>
<optgroup label="5D">
<option value="T15">T15</option>
<option value="T21">T21</option>
</optgroup>
</select>
</div>
<div>
<label style="display:block;margin-bottom:5px;color:var(--neon-blue)">Rentang Analisis (hari):</label>
<input class="form-control" id="analDays" max="365" min="7" placeholder="Jumlah hari" type="number" value="30"/>
</div>
</div>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px">
<input accept=".txt,.csv" id="historyFile" style="display:none" type="file"/>
<button class="btn" onclick="document.getElementById(&apos;historyFile&apos;).click()"> Upload History</button>
<button class="btn" onclick="addManualHistory()"> Tambah Manual</button>
<button class="btn" onclick="saveAnalisisHistory()"> Simpan History</button>
<button class="btn" onclick="loadAnalisisHistory()"> Load History</button>
<button class="btn" onclick="clearAnalisisHistory()" style="background:linear-gradient(45deg,var(--neon-red),var(--neon-purple))"> Hapus History</button>
</div>
<div id="historyInfo" style="font-size:0.9em;color:var(--neon-green)">
    Status: History belum dimuat
  </div>
</div>
<div class="history-table-container">
<table class="history-table">
<thead>
<tr>
<th>Tanggal</th>
<th>Pool</th>
<th>Result</th>
<th>Aksi</th>
</tr>
</thead>
<tbody id="historyTableBody">
<tr>
<td colspan="4" style="text-align:center;padding:20px;color:var(--neon-yellow)">
          Data history akan ditampilkan di sini...
        </td>
</tr>
</tbody>
</table>
</div>
<div style="margin-bottom:15px">
<label style="display:block;margin-bottom:8px;color:var(--neon-blue);font-weight:bold">Metode Analisis:</label>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px">
<label style="display:flex;align-items:center;gap:8px">
<input checked="" id="analSelisih" type="checkbox"/>
<span>Pola Selisih &amp; Arah</span>
</label>
<label style="display:flex;align-items:center;gap:8px">
<input checked="" id="analMarkov" type="checkbox"/>
<span>Transisi Markov</span>
</label>
<label style="display:flex;align-items:center;gap:8px">
<input checked="" id="analCorrelation" type="checkbox"/>
<span>Cross-Correlation</span>
</label>
<label style="display:flex;align-items:center;gap:8px">
<input checked="" id="analDominasi" type="checkbox"/>
<span>Dominasi &amp; Stabilitas</span>
</label>
</div>
</div>
<div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:15px">
<button class="btn" onclick="runAnalysis()" style="flex:1"> Jalankan Analisis</button>
<button class="btn" onclick="clearAnalysis()" style="background:linear-gradient(45deg,var(--neon-red),var(--neon-purple))"> Clear Hasil</button>
</div>
<div class="chart-container">
<div style="text-align:center;color:var(--neon-yellow);margin-bottom:10px">Grafik Frekuensi Angka</div>
<canvas id="frequencyChart"></canvas>
</div>
<div class="analysis-grid" id="analysisResults">
<div class="analysis-card">
<h4> Pola Selisih &amp; Arah</h4>
<div class="position-result">
<div class="position-title">Trend Utama</div>
<div class="position-data">Menunggu analisis...</div>
</div>
</div>
<div class="analysis-card">
<h4> Transisi Markov</h4>
<div class="position-result">
<div class="position-title">Pola Transisi</div>
<div class="position-data">Menunggu analisis...</div>
</div>
</div>
</div>
<div style="background:var(--card-bg);border:1px solid var(--neon-blue);border-radius:8px;padding:15px;margin-top:15px;position:relative">
<button class="btn" onclick="copyAnalysisResult()" style="position:absolute;top:10px;right:10px;padding:5px 10px;font-size:12px"> Salin</button>
<div id="analResult">
<div style="text-align:center;color:var(--neon-yellow);padding:20px">
       Hasil analisis akan ditampilkan di sini...
    </div>
</div>
</div>
<div id="analLoading" style="display:none;text-align:center;padding:20px">
<div style="color:var(--neon-green)">Menganalisis data...</div>
</div>
</section><section class="content-section" id="shio">
<div class="container">
    <h2 style="color:var(--neon-blue);margin-bottom:15px;text-align:center;"> Menu Prediksi SHIO</h2>

    <div class="card" style="margin-bottom:20px;padding:15px;background:rgba(255,255,255,.05);border:1px solid rgba(0,255,0,.3);border-radius:10px;box-shadow:0 0 20px rgba(0,255,0,0.1);">
        <h4 style="color:var(--neon-green)">Basis Data SHIO</h4>
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px;">
            <input accept=".csv,.txt" id="shio_fileInput" style="display:none" type="file"/ onchange="shio_handleFile(event)">
            <button class="btn" onclick="document.getElementById(&apos;shio_fileInput&apos;).click()"> Upload Data Result</button>
            <button class="btn" onclick="shio_saveData()"> Simpan Data</button>
            <button class="btn" onclick="shio_loadSavedPools()"> Muat Pool</button>
            <select class="form-control" id="shio_poolSelect" onchange="shio_loadDataForPool(this.value)" style="flex:1;min-width:150px"></select>
            <button class="btn" onclick="shio_clearAllData()" style="background:linear-gradient(45deg,var(--neon-red),var(--neon-purple))"> Clear Semua</button>
        </div>
        <div class="data-info" id="shio_dataStatus" style="margin-top:10px;text-align:left;">Tidak ada data dimuat.</div>
    </div>

    <h3 style="color:var(--neon-yellow);margin-top:20px;margin-bottom:10px;text-align:center;">1. Pola Analisis SHIO</h3>
    <div class="analysis-grid">
        <div class="analysis-card" style="border-color:var(--neon-green)">
            <h4 style="color:var(--neon-green)">Pola SHIO Dominan (Top 3)</h4>
            <div id="shio_dominan_pola">Menunggu Analisis...</div>
        </div>
        <div class="analysis-card" style="border-color:var(--neon-green)">
            <h4 style="color:var(--neon-green)">Pola Transisi SHIO (Top 2)</h4>
            <div id="shio_transisi_pola">Menunggu Analisis...</div>
        </div>
    </div>
    <div class="analysis-card" style="margin-top:15px;border-color:var(--neon-red)">
        <h4 style="color:var(--neon-red)">Pola SHIO Mati (Posisi 2D Terendah)</h4>
        <div id="shio_mati_pola">Menunggu Analisis...</div>
    </div>
    <button class="btn" onclick="shio_analyzeDailyPattern()" style="margin-top:15px;width:100%"> Jalankan Analisis Pola Harian</button>

    <h3 style="color:var(--neon-yellow);margin-top:30px;margin-bottom:10px;text-align:center;">2. Prediksi Hari Ini</h3>
    <div class="card" style="padding:15px;border:1px solid var(--neon-blue);">
        <div style="display:flex;gap:10px;align-items:center;margin-bottom:15px">
            <label for="shio_predDate" style="color:var(--neon-purple);white-space:nowrap;">Tanggal Prediksi:</label>
            <input class="form-control" id="shio_predDate" type="date" style="width:auto;flex-grow:0"/>
            <button class="btn" onclick="shio_runPrediction()" style="flex-grow:1"> Tampilkan Prediksi</button>
        </div>

        <div style="margin-bottom:15px;padding:10px;background:rgba(255,0,102,.1);border:1px solid var(--neon-red);border-radius:6px">
            <h4 style="color:var(--neon-red);margin-bottom:8px;">SHIO MATI Hari Ini:</h4>
            <div id="shio_predShioMati" style="font-size:1.2rem;font-weight:bold;color:var(--neon-red);text-shadow:0 0 10px var(--neon-red);">---</div>
        </div>

        <h4 style="color:var(--neon-green);margin-bottom:8px;">Angka 2D Rekomendasi (Horisontal)</h4>
        <div id="shio_2d_rekomendasi" style="min-height:50px;overflow-x:auto;white-space:nowrap;padding:10px;background:rgba(0,255,0,.1);border:1px solid var(--neon-green);border-radius:6px;font-size:1.2rem;line-height:1.5;">
            <span style="color:var(--neon-yellow)">--- Angka 2D akan muncul di sini ---</span>
        </div>
        <div id="shio_2d_info" style="font-size:0.9em;color:var(--neon-purple);margin-top:5px;">* Angka yang di-highlight memiliki kemungkinan paling rendah kemunculannya di riwayat data Anda (Paling direkomendasikan).</div>
    </div>
</div>
</section><section class="content-section" id="bbfs">
<div class="container">
<h1>BBFS Analyzer</h1>
<div class="input-group">
<h2> Menu Database &amp; Log</h2>
<p>Pool Aktif: <span class="neon-text" id="pool-aktif">N/A</span></p>
<div style="margin-bottom: 15px;">
<label for="poolNameSelect">Pilih/Load Pool Data:</label>
<select id="poolNameSelect" onchange="loadPoolData()">
<option value="">-- PILIH POOL --</option>
</select>
<button onclick="loadPoolData()">Load Data</button>
</div>
<div>
<label for="poolNameInput">Nama Pool Baru (Contoh: HKG):</label>
<input id="poolNameInput" placeholder="Contoh: HKG" style="width: 100px;" type="text"/>
<label for="dataFileInput">Upload File Histori (.txt):</label>
<input accept=".txt" id="dataFileInput" type="file"/>
<button onclick="uploadData()">Upload &amp; Simpan</button>
</div>
<p class="message" id="messageArea" style="display: none;"></p>
</div>
<div class="input-group">
<h2> Histori Data Terbaru (10 Baris)</h2>
<table class="result-table" id="historyTable">
<thead>
<tr><th>Tanggal</th><th>A</th><th>B</th><th>C</th><th>D</th></tr>
</thead>
<tbody id="historyBody">
<tr><td colspan="5">Belum ada data dimuat.</td></tr>
</tbody>
</table>
</div>
<div class="analysis-control">
<div>
<label for="predictionDate" style="color: var(--neon-color-1);">Pilih Tanggal Prediksi:</label>
<input id="predictionDate" style="font-size: 1.1em;" type="date"/>
</div>
<button onclick="predictForSelectedDate()" style="font-size: 1.2em; padding: 15px 30px;">
             JALANKAN ANALISIS &amp; PREDIKSI
        </button>
</div>
<div id="analysisResultArea">
<h2><span class="neon-text"> Hasil Analisis Historis</span></h2>
<p style="text-align: center;">Pilih tanggal dan tekan tombol **JALANKAN ANALISIS &amp; PREDIKSI** di atas.</p>
</div>
<div id="prediksiResultArea">
<h2><span class="neon-text"> Hasil Prediksi Harian</span></h2>
<p style="text-align: center;">Pilih tanggal dan tekan tombol **JALANKAN ANALISIS &amp; PREDIKSI** di atas.</p>
</div>
</div>
<script>
    let activeHistoryData = []; 
    let activePoolName = ""; 

    const MISTIK = {
        lama: { 0: 1, 1: 0, 2: 5, 3: 8, 4: 7, 5: 2, 6: 9, 7: 4, 8: 3, 9: 6 },
        baru: { 0: 8, 1: 7, 2: 6, 3: 9, 4: 5, 5: 4, 6: 2, 7: 1, 8: 0, 9: 3 },
        mirror: { 0: 5, 1: 6, 2: 7, 3: 8, 4: 9, 5: 0, 6: 1, 7: 2, 8: 3, 9: 4 }
    };
    const DAY_NAMES = [&apos;Minggu&apos;, &apos;Senin&apos;, &apos;Selasa&apos;, &apos;Rabu&apos;, &apos;Kamis&apos;, &apos;Jumat&apos;, &apos;Sabtu&apos;];

    // --- Utility Functions ---

    function getDayName(dateStr) {
        if (!dateStr || dateStr.length < 10) return "Tanggal Invalid";
        const [day, month, year] = dateStr.split(&apos;/&apos;);
        // Gunakan format YYYY-MM-DD untuk Date Object yang aman
        const date = new Date(`${year}-${month}-${day}`);
        // Jika Date Object invalid (misalnya tanggal tidak benar), kembalikan &apos;N/A&apos;
        if (isNaN(date.getTime())) return "N/A";
        return DAY_NAMES[date.getDay()];
    }

    function showMessage(msg, type) {
        const msgArea = document.getElementById(&apos;messageArea&apos;);
        msgArea.textContent = msg;
        msgArea.className = `message ${type}`; 
        msgArea.style.display = &apos;block&apos;;
        setTimeout(() => {
            msgArea.style.display = &apos;none&apos;;
        }, 5000);
    }
    
    function getResultArray(item) {
        const res = item.result;
        if (Array.isArray(res)) return res.map(n => parseInt(n));
        if (typeof res === &apos;string&apos;) return res.split(&apos;&apos;).map(n => parseInt(n));
        return [];
    }
    
    function sortData(data) {
        // Mengurutkan data berdasarkan tanggal terbaru (descending)
        data.sort((a, b) => {
            const dateA = a.date.split(&apos;/&apos;).reverse().join(&apos;&apos;);
            const dateB = b.date.split(&apos;/&apos;).reverse().join(&apos;&apos;);
            return dateB.localeCompare(dateA);
        });
        return data;
    }

    // --- Data Management Functions ---

    function savePoolData(name, data) {
        try {
            const dataToSave = sortData(data);
            localStorage.setItem(`pool_${name}`, JSON.stringify(dataToSave));
            activePoolName = name;
            activeHistoryData = dataToSave;
            showMessage(`Pool data "${name}" berhasil disimpan. Total data: ${dataToSave.length} baris.`, &apos;success&apos;);
            populatePoolSelects();
            displayHistory();
        } catch (e) {
            showMessage(&apos;Gagal menyimpan data ke LocalStorage. Data mungkin terlalu besar.&apos;, &apos;error&apos;);
            console.error(e);
        }
    }

    function populatePoolSelects() {
        const fixedPools = [&apos;TOK&apos;, &apos;PPL&apos;, &apos;CHI&apos;, &apos;SYD&apos;, &apos;HKG&apos;, &apos;SEO&apos;, &apos;T15&apos;, &apos;T21&apos;];
        const localStorageKeys = Object.keys(localStorage).filter(key => key.startsWith(&apos;pool_&apos;)).map(key => key.substring(5));
        const allPoolNames = [...new Set([...fixedPools, ...localStorageKeys])].sort();

        const selectLoad = document.getElementById(&apos;poolNameSelect&apos;);
        selectLoad.innerHTML = &apos;<option value="">-- PILIH POOL --</option>&apos;;

        allPoolNames.forEach(name => {
            const option = `<option value="${name}">${name}</option>`;
            selectLoad.innerHTML += option;
        });
    }
    
    function loadPoolData() {
        const select = document.getElementById(&apos;poolNameSelect&apos;);
        const name = select.value;
        const key = `pool_${name}`;

        if (!name) {
            showMessage(&apos;Silakan pilih Pool untuk dimuat.&apos;, &apos;error&apos;);
            return;
        }

        try {
            const data = localStorage.getItem(key);
            if (data) {
                activePoolName = name;
                activeHistoryData = sortData(JSON.parse(data));
                showMessage(`Pool data "${activePoolName}" berhasil dimuat. Total data: ${activeHistoryData.length} baris.`, &apos;success&apos;);
                displayHistory();
                document.getElementById(&apos;pool-aktif&apos;).textContent = activePoolName;
            } else {
                showMessage(`Data Pool "${name}" tidak ditemukan di LocalStorage.`, &apos;warning&apos;);
                activePoolName = name;
                activeHistoryData = [];
                displayHistory();
                document.getElementById(&apos;pool-aktif&apos;).textContent = activePoolName;
            }
        } catch (e) {
            showMessage(&apos;Gagal memuat data dari LocalStorage.&apos;, &apos;error&apos;);
            console.error(e);
        }
    }

    function uploadData() {
        const poolName = document.getElementById(&apos;poolNameInput&apos;).value.trim().toUpperCase();
        const fileInput = document.getElementById(&apos;dataFileInput&apos;);
        const file = fileInput.files[0];

        if (!poolName || poolName.length < 3) {
            showMessage(&apos;Nama Pool harus diisi minimal 3 karakter.&apos;, &apos;error&apos;);
            return;
        }
        if (!file) {
            showMessage(&apos;Silakan pilih file data (.txt) untuk diunggah.&apos;, &apos;error&apos;);
            return;
        }

        if (!file.name.endsWith(&apos;.txt&apos;)) {
            showMessage(&apos;Hanya file .txt yang didukung.&apos;, &apos;error&apos;);
            return;
        }

        const reader = new FileReader();
        
        reader.onload = (e) => {
            try {
                const content = e.target.result;
                const lines = content.split(/\r?\n/).filter(line => line.trim() !== &apos;&apos;);
                
                let parsedData = [];
                let errorCount = 0;

                lines.forEach(line => {
                    const cleanedLine = line.trim().replace(/[\s\t]+/g, &apos;,&apos;).replace(/,+/g, &apos;,&apos;);
                    const parts = cleanedLine.split(&apos;,&apos;);
                    
                    if (parts.length >= 5) {
                        const datePart = parts[0].trim();
                        const resultParts = parts.slice(1).map(p => p.trim()).filter(p => p !== &apos;&apos;);

                        if (datePart.match(/^\d{2}\/\d{2}\/\d{4}$/) && resultParts.length >= 4) {
                            const result = resultParts.map(p => parseInt(p));

                            if (result.every(num => !isNaN(num) && num >= 0 && num <= 9)) {
                                parsedData.push({ 
                                    date: datePart, 
                                    result: result, 
                                    day: getDayName(datePart) 
                                });
                                return;
                            }
                        }
                    }
                    errorCount++;
                });

                if (parsedData.length === 0) {
                    showMessage(&apos;Gagal memproses data. Pastikan format: DD/MM/YYYY,A,B,C,D (atau dipisahkan spasi).&apos;, &apos;error&apos;);
                    return;
                }
                
                if (errorCount > 0) {
                     showMessage(`Terdapat ${errorCount} baris data yang diabaikan. ${parsedData.length} baris berhasil diproses.`, &apos;warning&apos;);
                } else {
                    showMessage(`Semua ${parsedData.length} baris berhasil diproses.`, &apos;success&apos;);
                }

                savePoolData(poolName, parsedData);
                fileInput.value = &apos;&apos;;

            } catch (err) {
                showMessage(`Terjadi kesalahan fatal saat memproses file: ${err.message}`, &apos;error&apos;);
                console.error(err);
            }
        };
        
        reader.onerror = () => {
             showMessage(&apos;Gagal membaca file.&apos;, &apos;error&apos;);
        };

        reader.readAsText(file, &apos;UTF-8&apos;);
    }
    
    function displayHistory() {
        const tbody = document.getElementById(&apos;historyBody&apos;);
        tbody.innerHTML = &apos;&apos;;
        
        if (activeHistoryData.length === 0) {
            tbody.innerHTML = &apos;<tr><td colspan="5">Belum ada data dimuat.</td></tr>&apos;;
            return;
        }
        
        const maxLen = activeHistoryData.reduce((max, item) => Math.max(max, getResultArray(item).length), 0);
        const posNames = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;].slice(0, maxLen);
        
        const tableHead = document.getElementById(&apos;historyTable&apos;).querySelector(&apos;thead tr&apos;);
        tableHead.innerHTML = &apos;<th>Tanggal</th>&apos; + posNames.map(p => `<th>${p}</th>`).join(&apos;&apos;);

        const latest10 = activeHistoryData.slice(0, 10);
        
        latest10.forEach(data => {
            const resultArr = getResultArray(data);
            let row = `<tr><td>${data.date}</td>`;
            row += resultArr.map(n => `<td>${n}</td>`).join(&apos;&apos;);
            
            for (let i = resultArr.length; i < maxLen; i++) {
                row += &apos;<td>-</td>&apos;;
            }
            
            tbody.innerHTML += row + &apos;</tr>&apos;;
        });
    }

    document.addEventListener(&apos;DOMContentLoaded&apos;, () => {
        populatePoolSelects();
        // Atur tanggal default ke hari ini
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, &apos;0&apos;);
        const dd = String(today.getDate()).padStart(2, &apos;0&apos;);
        document.getElementById(&apos;predictionDate&apos;).value = `${yyyy}-${mm}-${dd}`;
    });

    // --- Core Analysis Functions ---

    function analyzeFrequencies(data) {
        if (data.length === 0) return null;
        const maxLen = data.reduce((max, item) => Math.max(max, getResultArray(item).length), 0);
        const freqs = Array(maxLen).fill(0).map(() => Array(10).fill(0));
        data.forEach(item => {
            const result = getResultArray(item);
            result.forEach((num, index) => {
                if (index < maxLen && !isNaN(num)) freqs[index][num]++;
            });
        });
        return { freqs, maxLen };
    }
    
    function analyzeDeltaTransitions(data) {
        if (data.length === 0) return null;
        const deltaFreqs = [];
        const maxLen = data.reduce((max, item) => Math.max(max, getResultArray(item).length), 0);
        for (let j = 0; j < maxLen; j++) {
            const posDeltas = {};
            for (let i = 1; i < data.length; i++) {
                const prevResult = getResultArray(data[i]);
                const currResult = getResultArray(data[i - 1]);
                if (prevResult[j] !== undefined && currResult[j] !== undefined) {
                    const delta = Math.abs(currResult[j] - prevResult[j]);
                    posDeltas[delta] = (posDeltas[delta] || 0) + 1;
                }
            }
            deltaFreqs.push(posDeltas);
        }
        return { deltaFreqs, maxLen };
    }
    
    function analyzeDailyTransitions(data) {
        if (data.length === 0) return null;
        const maxLen = data.reduce((max, item) => Math.max(max, getResultArray(item).length), 0);
        const posNames = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;].slice(0, maxLen);
        const dailyTransitions = {};
        DAY_NAMES.forEach(day => {
            dailyTransitions[day] = Array(maxLen).fill(0).map(() => ({}));
        });
        for (let i = 1; i < data.length; i++) {
            const prevItem = data[i];
            const currItem = data[i - 1];
            const prevResult = getResultArray(prevItem); 
            const currResult = getResultArray(currItem);
            const day = getDayName(currItem.date);
            if (day === &apos;N/A&apos;) continue;
            for (let j = 0; j < maxLen; j++) {
                if (prevResult[j] !== undefined && currResult[j] !== undefined) {
                    const key = `${prevResult[j]} ke ${currResult[j]}`;
                    dailyTransitions[day][j][key] = (dailyTransitions[day][j][key] || 0) + 1;
                }
            }
        }
        const sortedDailyTransitions = DAY_NAMES.map(day => {
            const posTrans = dailyTransitions[day].map((transitions, index) => {
                const sorted = Object.entries(transitions)
                    .sort(([, a], [, b]) => b - a)
                    .slice(0, 3)
                    .map(([key,]) => key.split(&apos; ke &apos;).join(&apos;-&apos;));
                return { pos: posNames[index], top3: sorted };
            });
            return { day, posTrans };
        });
        return sortedDailyTransitions;
    }

    function analyzeDailyRecommendation(data) {
        if (data.length === 0) return { top7: &apos;N/A&apos;, cold3: &apos;N/A&apos; };
        const freqsData = analyzeFrequencies(data);
        if (!freqsData) return { top7: &apos;N/A&apos;, cold3: &apos;N/A&apos; };
        const overallFreqs = Array(10).fill(0);
        freqsData.freqs.forEach(posFreqs => posFreqs.forEach((count, num) => overallFreqs[num] += count));
        const top7 = overallFreqs.map((count, num) => ({ num, count })).sort((a, b) => b.count - a.count).slice(0, 7).map(item => item.num);
        const cold3 = overallFreqs.map((count, num) => ({ num, count })).sort((a, b) => a.count - b.count).slice(0, 3).map(item => item.num);
        return { top7: top7.join(&apos;, &apos;), cold3: cold3.join(&apos;, &apos;) };
    }

    function analyzeDeltaDominance(data) {
        const deltaResult = analyzeDeltaTransitions(data);
        if (!deltaResult) return null;
        const posNames = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;].slice(0, deltaResult.maxLen);
        const dominance = posNames.map((pos, index) => {
            const posDeltas = deltaResult.deltaFreqs[index];
            const sorted = Object.entries(posDeltas).sort(([, a], [, b]) => b - a).slice(0, 3);
            return { pos: pos, top3: sorted.map(([delta, count]) => `${delta} (${count})`).join(&apos;, &apos;) };
        });
        return dominance;
    }

    function analyzeKembarPola(data) {
        if (data.length === 0) return { kembarFreq: &apos;N/A&apos;, polaFreq: &apos;N/A&apos; };
        const kembarFreq = {};
        const polaFreq = {};
        data.forEach(item => {
            const R = getResultArray(item);
            const R4 = R.slice(0, 4);
            for (let i = 0; i < R.length - 1; i++) {
                if (R[i] === R[i + 1]) {
                    const pair = `${R[i]}${R[i + 1]}`;
                    kembarFreq[pair] = (kembarFreq[pair] || 0) + 1;
                }
            }
            if (R4.length === 4) {
                if (R4[0] === R4[1] && R4[2] !== R4[3]) polaFreq[&apos;AABB&apos;] = (polaFreq[&apos;AABB&apos;] || 0) + 1;
                if (R4[1] === R4[2] && R4[0] !== R4[3]) polaFreq[&apos;BCCB&apos;] = (polaFreq[&apos;BCCB&apos;] || 0) + 1;
                if (R4[2] === R4[3] && R4[0] !== R4[1]) polaFreq[&apos;CDDC&apos;] = (polaFreq[&apos;CDDC&apos;] || 0) + 1;
                if (R4[0] === R4[3] && R4[1] !== R4[2]) polaFreq[&apos;ADDA&apos;] = (polaFreq[&apos;ADDA&apos;] || 0) + 1;
                if (R4[0] === R4[1] && R4[2] === R4[3]) polaFreq[&apos;AABBCCDD&apos;] = (polaFreq[&apos;AABBCCDD&apos;] || 0) + 1;
            }
        });
        const sortedKembar = Object.entries(kembarFreq).sort(([, a], [, b]) => b - a).slice(0, 5).map(([pair, count]) => `${pair} (${count}x)`).join(&apos;, &apos;);
        const sortedPola = Object.entries(polaFreq).filter(([, count]) => count > 0).sort(([, a], [, b]) => b - a).slice(0, 5).map(([pola, count]) => `${pola} (${count}x)`).join(&apos;, &apos;);
        return { kembarFreq: sortedKembar, polaFreq: sortedPola };
    }

    function analyzeDailyPolaDominance(data) {
        if (data.length === 0) return null;
        const maxLen = data.reduce((max, item) => Math.max(max, getResultArray(item).length), 0);
        const dailyPola = {};
        DAY_NAMES.forEach(day => {
            dailyPola[day] = { GG: {}, BK: {} };
        });
        data.forEach(item => {
            const R = getResultArray(item);
            const day = getDayName(item.date);
            if (day === &apos;N/A&apos;) return;
            let polaGG = &apos;&apos;;
            let polaBK = &apos;&apos;;
            for (let i = 0; i < R.length; i++) {
                if (i < maxLen) {
                    polaGG += R[i] % 2 === 0 ? &apos;G&apos; : &apos;J&apos;;
                    polaBK += R[i] >= 5 ? &apos;B&apos; : &apos;K&apos;;
                }
            }
            if (polaGG.length === maxLen) dailyPola[day].GG[polaGG] = (dailyPola[day].GG[polaGG] || 0) + 1;
            if (polaBK.length === maxLen) dailyPola[day].BK[polaBK] = (dailyPola[day].BK[polaBK] || 0) + 1;
        });
        const finalPola = DAY_NAMES.map(day => {
            const sortedGG = Object.entries(dailyPola[day].GG).sort(([, a], [, b]) => b - a).slice(0, 5).map(([pola, count]) => `${pola} (${count}x)`).join(&apos; &apos;);
            const sortedBK = Object.entries(dailyPola[day].BK).sort(([, a], [, b]) => b - a).slice(0, 5).map(([pola, count]) => `${pola} (${count}x)`).join(&apos; &apos;);
            return { day, GG: sortedGG || &apos;N/A&apos;, BK: sortedBK || &apos;N/A&apos; };
        });
        return finalPola;
    }

    // --- NEW HELPER FUNCTIONS FOR REQUIREMENTS 1 & 2 ---

    // Helper: Mendapatkan 3 Angka Dingin (paling tidak sering muncul) secara keseluruhan
    function getOverallColdNumbers(data) {
        const freqsData = analyzeFrequencies(data);
        if (!freqsData) return [];
        const overallFreqs = Array(10).fill(0);
        freqsData.freqs.forEach(posFreqs => posFreqs.forEach((count, num) => overallFreqs[num] += count));
        // Urutkan menaik (yang paling dingin/least frequent)
        const cold3 = overallFreqs.map((count, num) => ({ num, count })).sort((a, b) => a.count - b.count).slice(0, 3).map(item => item.num);
        return cold3;
    }
    
    // Helper: Mendapatkan Top 7 angka dominan per posisi (Req 1)
    function getPositionalBBFS(data) {
        const freqsData = analyzeFrequencies(data);
        if (!freqsData) return [];
        const positionalBBFS = freqsData.freqs.map(posFreqs => {
            return posFreqs.map((count, num) => ({ num, count }))
                           .sort((a, b) => b.count - a.count)
                           .slice(0, 7) // Top 7 numbers for this position
                           .map(item => item.num);
        });
        return positionalBBFS;
    }

    // --- PREDICTION FUNCTIONS (MODIFIED) ---

    // 1. BBFS Kuat (7 Angka) Berdasarkan Frekuensi Harian (MODIFIED for positional display)
    function predictBBFS(data) {
        if (data.length === 0) return { overall: &apos;Data kosong.&apos;, positional: [] };
        
        const freqsData = analyzeFrequencies(data);
        if (!freqsData) return { overall: &apos;Gagal menghitung frekuensi.&apos;, positional: [] };

        // 1. Overall BBFS (untuk info umum)
        const overallFreqs = Array(10).fill(0);
        freqsData.freqs.forEach(posFreqs => posFreqs.forEach((count, num) => overallFreqs[num] += count));
        const overallTop7 = overallFreqs.map((count, num) => ({ num, count })).sort((a, b) => b.count - a.count).slice(0, 7).map(item => item.num).join(&apos;, &apos;);

        // 2. Positional BBFS (Req 1: 7 angka per posisi)
        const positionalBBFS = getPositionalBBFS(data);
        
        return { 
            overall: overallTop7, 
            positional: positionalBBFS 
        };
    }

    // 2. Top 5 Kombinasi Harian per Posisi A-B-C-D/E (MODIFIED for Top 5 and new logic - Req 2)
    function predictTop5Combinations(data) {
        const positionalBBFS = getPositionalBBFS(data); // Top 7 dominant per position
        const coldNumbers = getOverallColdNumbers(data); // Top 3 cold numbers overall (Angka Dingin/Mati)
        const maxLen = positionalBBFS.length;
        const posNames = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;].slice(0, maxLen);
        
        // Safety check for cold numbers
        const cold1 = coldNumbers[0] !== undefined ? coldNumbers[0] : 0;
        const cold2 = coldNumbers[1] !== undefined ? coldNumbers[1] : 5;
        const cold3 = coldNumbers[2] !== undefined ? coldNumbers[2] : 9;

        const top5Comb = posNames.map((pos, index) => {
            const posBBFS = positionalBBFS[index]; // 7 dominant numbers for this position

            // Kombinasi 1: 3 dominant + 2 cold (Req 2 - Kombinasi 1)
            // Ambil 3 angka dominan dari posBBFS (index 0, 1, 2)
            const c1Dominant = posBBFS.slice(0, 3);
            const c1Cold = [cold1, cold2];
            // Gunakan Set untuk memastikan hanya 5 angka unik dan kemudian gabungkan
            const c1 = [...new Set([...c1Dominant, ...c1Cold])].slice(0, 5).join(&apos;&apos;);

            // Kombinasi 2: 4 dominant + 1 cold (Req 2 - Kombinasi 2)
            // Ambil 4 angka dominan dari posBBFS (index 0, 1, 2, 3)
            const c2Dominant = posBBFS.slice(0, 4);
            const c2Cold = [cold3];
            const c2 = [...new Set([...c2Dominant, ...c2Cold])].slice(0, 5).join(&apos;&apos;);
            
            // Kombinasi 3: Next 3 dominant (4th, 5th, 6th) + 2 cold (Req 2 - Kombinasi 3 / Asumsi Perbaikan Typo)
            // Ambil 3 angka berikutnya dari posBBFS (index 3, 4, 5)
            const c3Dominant = posBBFS.slice(3, 6);
            const c3Cold = [cold1, cold2];
            const c3 = [...new Set([...c3Dominant, ...c3Cold])].slice(0, 5).join(&apos;&apos;);

            // Kombinasi 4: Top 5 angka kuat pertama (dominan) murni dari posisi
            const c4 = posBBFS.slice(0, 5).join(&apos;&apos;);

            // Kombinasi 5: Mix - Gabungan 2 angka terkuat dari C1, 2 terkuat dari C2, 1 Cold unik
            const c5 = [...new Set([posBBFS[0], posBBFS[1], posBBFS[2], posBBFS[3], cold3])].slice(0, 5).join(&apos;&apos;);

            return { pos, c1: c1 || &apos;N/A&apos;, c2: c2 || &apos;N/A&apos;, c3: c3 || &apos;N/A&apos;, c4: c4 || &apos;N/A&apos;, c5: c5 || &apos;N/A&apos; };
        });
        return top5Comb;
    }

    // 3. Angka Tarung (Kombinasi 2D Kuat) (MODIFIED for C1 permutation and Angka Mati filter - Req 3)
    function predictAngkaTarung(data) {
        const top5Comb = predictTop5Combinations(data);
        const coldNumbers = getOverallColdNumbers(data); // Angka Mati (Cold 3)
        const maxLen = top5Comb.length;
        
        // Ambil KOMB. 1 (C1) sebagai basis Angka Tarung (karena menggunakan 3 angka dominan terkuat)
        const c1DigitsPerPos = top5Comb.map(tc => tc.c1.split(&apos;&apos;).map(Number));

        const combine2D = (arr1, arr2) => {
            const pairs = new Set();
            if(arr1.length === 0 || arr2.length === 0) return &apos;N/A&apos;;
            arr1.forEach(n1 => arr2.forEach(n2 => {
                const pair = `${n1}${n2}`;
                // Filter ketat: Cek apakah angka mati (cold number) ada di pasangan 2D ini
                const isDead = coldNumbers.includes(n1) || coldNumbers.includes(n2);
                // Tambahkan filter untuk Angka Kembar (XX) karena sering dianggap lemah dalam tarung
                const isKembar = n1 === n2; 
                
                // Hanya masukkan jika BUKAN angka mati (cold) dan BUKAN kembar
                if (!isDead && !isKembar) { 
                    pairs.add(pair);
                }
            }));
            
            // Batasi output ke 100 pasangan saja (untuk performa & tampilan)
            return Array.from(pairs).slice(0, 100).sort().join(&apos;, &apos;) + (pairs.size > 100 ? &apos;...&apos; : &apos;&apos;);
        };
        
        const result = {};
        if (maxLen >= 2) result.AB = combine2D(c1DigitsPerPos[0], c1DigitsPerPos[1]);
        if (maxLen >= 3) result.BC = combine2D(c1DigitsPerPos[1], c1DigitsPerPos[2]);
        if (maxLen >= 4) result.CD = combine2D(c1DigitsPerPos[2], c1DigitsPerPos[3]);
        if (maxLen >= 5) result.DE = combine2D(c1DigitsPerPos[3], c1DigitsPerPos[4]);
        return result;
    }

    // --- Wrapper untuk Prediksi Tanggal ---
    function predictForSelectedDate() {
        const selectedDateStr = document.getElementById(&apos;predictionDate&apos;).value; // YYYY-MM-DD
        
        if (activeHistoryData.length === 0) {
            showMessage(&apos;Silakan Load Pool Data terlebih dahulu.&apos;, &apos;error&apos;);
            return;
        }

        if (!selectedDateStr) {
            showMessage(&apos;Silakan pilih tanggal untuk prediksi.&apos;, &apos;error&apos;);
            return;
        }
        
        const predictionDateInt = parseInt(selectedDateStr.replace(/-/g, &apos;&apos;), 10);
        
        // 1. Filter Data: Hanya gunakan data histori yang *sebelum* tanggal yang dipilih.
        const filteredData = activeHistoryData.filter(item => {
            // Konversi format DD/MM/YYYY menjadi YYYYMMDD integer
            const [d, m, y] = item.date.split(&apos;/&apos;);
            const itemDateInt = parseInt(`${y}${m}${d}`, 10);
            return itemDateInt < predictionDateInt;
        });

        if (filteredData.length === 0) {
            showMessage(`Tidak ada data histori yang ditemukan sebelum tanggal ${selectedDateStr}. Analisis dibatalkan.`, &apos;error&apos;);
            document.getElementById(&apos;analysisResultArea&apos;).innerHTML = `<h2><span class="neon-text"> Hasil Analisis Historis</span></h2><p style="text-align: center;">Tidak ada data aktif.</p>`;
            document.getElementById(&apos;prediksiResultArea&apos;).innerHTML = `<h2><span class="neon-text"> Hasil Prediksi Harian</span></h2><p style="text-align: center;">Tidak ada data aktif.</p>`;
            return;
        }

        // 2. Tentukan Hari (untuk judul)
        const predictionDate = new Date(selectedDateStr.replace(/-/g, &apos;/&apos;));
        const dayOfWeek = DAY_NAMES[predictionDate.getDay()];

        // 3. Jalankan Analisis Utama
        runAnalysisAndPrediction(filteredData, selectedDateStr, dayOfWeek);
    }

    // --- Fungsi Utama Analisis menerima data subset dan konteks tanggal ---
    function runAnalysisAndPrediction(data, predictionDateStr, dayOfWeek) {
        
        const maxLen = data.reduce((max, item) => Math.max(max, getResultArray(item).length), 0);
        const posNames = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;].slice(0, maxLen);

        // --- ANALISIS HISTORI ---
        const recData = analyzeDailyRecommendation(data);
        const deltaDom = analyzeDeltaDominance(data);
        const kembarPola = analyzeKembarPola(data);
        const dailyPolaDom = analyzeDailyPolaDominance(data);
        const dailyTrans = analyzeDailyTransitions(data);
        
        let histHtml = `
            <h2><span class="neon-text"> Hasil Analisis Historis: ${activePoolName} (${data.length} Data)</span></h2>
            <hr>
            <p>Analisis dilakukan berdasarkan data histori **sebelum** tanggal **${predictionDateStr}**.</p>
            <div class="analysis-section">
                <h3>1.  Rekomendasi Angka Harian</h3>
                <p>BBFS Kuat (7 Angka Dominan): **${recData.top7}**</p>
                <p>3 Angka Lemah (Cold Numbers): **${recData.cold3}**</p>
            </div>
            
            <div class="analysis-section">
                <h3>2.  Delta Transisi Dominan per Posisi ${posNames.join(&apos;-&apos;)}</h3>
                <table class="result-table">
                    <thead><tr><th>Posisi</th><th>Top 3 Delta (Delta - Count)</th></tr></thead>
                    <tbody>
                        ${deltaDom.map(d => `<tr><td>**${d.pos}**</td><td>${d.top3}</td></tr>`).join(&apos;&apos;)}
                    </tbody>
                </table>
            </div>

            <div class="analysis-section">
                <h3>3.  Pola Dominan Angka Kembar</h3>
                <p>Angka Kembar Berdekatan (XX): **${kembarPola.kembarFreq}**</p>
                <p>Pola Kembar 4D (Contoh: AABB): **${kembarPola.polaFreq}**</p>
            </div>

            <div class="analysis-section">
                <h3>4.  Pola Dominan J/G & B/K (Top 5 Kombinasi Pola)</h3>
                <table class="result-table">
                    <thead><tr><th>Hari</th><th>Ganjil-Genap (J/G)</th><th>Besar-Kecil (B/K)</th></tr></thead>
                    <tbody>
                        ${dailyPolaDom.map(p => `
                            <tr>
                                <td>**${p.day}**</td>
                                <td>${p.GG}</td>
                                <td>${p.BK}</td>
                            </tr>
                        `).join(&apos;&apos;)}
                    </tbody>
                </table>
            </div>
            
            <div class="analysis-section">
                <h3>5.  Top Transisi Angka Harian (Posisi Kombinasi)</h3>
                <table class="result-table">
                    <thead>
                        <tr>
                            <th>Hari</th>
                            ${posNames.map(p => `<th>${p} (Top 3 Transisi X-Y)</th>`).join(&apos;&apos;)}
                        </tr>
                    </thead>
                    <tbody>
                        ${dailyTrans.map(dt => `
                            <tr>
                                <td>**${dt.day}**</td>
                                ${dt.posTrans.map(pt => `<td>${pt.top3.join(&apos;, &apos;)}</td>`).join(&apos;&apos;)}
                            </tr>
                        `).join(&apos;&apos;)}
                    </tbody>
                </table>
            </div>
        `;

        document.getElementById(&apos;analysisResultArea&apos;).innerHTML = histHtml;

        // --- PREDIKSI HARIAN ---
        const bbfsResult = predictBBFS(data);
        const top5Comb = predictTop5Combinations(data);
        const angkaTarung = predictAngkaTarung(data);

        // Render Positional BBFS (Req 1)
        let bbfsPositionalHtml = bbfsResult.positional.map((bbfs7, index) => {
            return `<tr><td>**${posNames[index]}**</td><td>${bbfs7.join(&apos;, &apos;)}</td></tr>`;
        }).join(&apos;&apos;);

        let predHtml = `
            <h2><span class="neon-text"> Hasil Prediksi Harian untuk **${predictionDateStr} (${dayOfWeek})**: ${activePoolName}</span></h2>
            <hr>
            
            <div class="analysis-section">
                <h3>1. 7 BBFS Kuat (7 Angka) Berdasarkan Frekuensi Harian per Posisi</h3>
                <p>Angka BBFS Kuat (Overall): **${bbfsResult.overall}**</p>
                <table class="result-table">
                    <thead><tr><th>Posisi</th><th>7 Angka Dominan</th></tr></thead>
                    <tbody>${bbfsPositionalHtml}</tbody>
                </table>
            </div>

            <div class="analysis-section">
                <h3>2.  Top 5 Kombinasi Harian per Posisi A-B-C-D/E</h3>
                <table class="result-table">
                    <thead>
                        <tr>
                            <th>Posisi</th>
                            <th>Kombinasi 1 (3 Dom + 2 Cold)</th>
                            <th>Kombinasi 2 (4 Dom + 1 Cold)</th>
                            <th>Kombinasi 3 (Next 3 Dom + 2 Cold)</th>
                            <th>Kombinasi 4 (Top 5 Dom Murni)</th>
                            <th>Kombinasi 5 (Mix Kuat)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${top5Comb.map(tc => `
                            <tr>
                                <td>**${tc.pos}**</td>
                                <td>${tc.c1}</td>
                                <td>${tc.c2}</td>
                                <td>${tc.c3}</td>
                                <td>${tc.c4}</td>
                                <td>${tc.c5}</td>
                            </tr>
                        `).join(&apos;&apos;)}
                    </tbody>
                </table>
            </div>

            <div class="analysis-section">
                <h3>3.  Angka Tarung (Kombinasi 2D Kuat) - Dari Komb. 1 & Filter Ketat</h3>
                <p>Angka Mati (Filter): **${getOverallColdNumbers(data).join(&apos;, &apos;)}**</p>
                <table class="result-table">
                    <thead><tr><th>2D Posisi</th><th>Kombinasi Kuat (Tanpa Angka Mati/Kembar)</th></tr></thead>
                    <tbody>
                        ${angkaTarung.AB ? `<tr><td>**AB**</td><td>**${angkaTarung.AB}**</td></tr>` : &apos;&apos;}
                        ${angkaTarung.BC ? `<tr><td>**BC**</td><td>**${angkaTarung.BC}**</td></tr>` : &apos;&apos;}
                        ${angkaTarung.CD ? `<tr><td>**CD**</td><td>**${angkaTarung.CD}**</td></tr>` : &apos;&apos;}
                        ${angkaTarung.DE ? `<tr><td>**DE**</td><td>**${angkaTarung.DE}**</td></tr>` : &apos;&apos;}
                    </tbody>
                </table>
            </div>
        `;
        document.getElementById(&apos;prediksiResultArea&apos;).innerHTML = predHtml;

        showMessage(`Analisis dan Prediksi untuk tanggal ${predictionDateStr} selesai.`, &apos;success&apos;);
    }

</script>
</section>
</div>
<script>
// ==================== GLOBAL VARIABLES ====================
const LOCAL_DB_KEY = &apos;gpt_atar_db_v2_fix&apos;;
const ACTIVE_DB_KEY = &apos;gpt_atar_active_db_v2_fix&apos;;
const ALL_DATABASES_KEY = &apos;gpt_atar_all_databases_v2_fix&apos;;
const HISTORY_KEY = &apos;gpt_atar_history_v2_fix&apos;;

let atarDB = {};
let currentPoolType = &apos;5D&apos;;
let databasisData = null;
let analisisHistoryData = {
    TOK: [], PPL: [], CHI: [], SYD: [], HKG: [], SEO: [], T15: [], T21: []
};

// ==================== CORE FUNCTIONS ====================
function showSection(id, ev) { 
    document.querySelectorAll(&apos;.content-section&apos;).forEach(sec => sec.classList.remove(&apos;active&apos;)); 
    document.querySelectorAll(&apos;.nav-btn&apos;).forEach(b => b.classList.remove(&apos;active&apos;)); 
    if(ev && ev.target) ev.target.classList.add(&apos;active&apos;); 
    document.getElementById(id).classList.add(&apos;active&apos;); 
}

function selectPoolType(type, ev) { 
    currentPoolType = type; 
    document.getElementById(&apos;btn4d&apos;).classList.toggle(&apos;active&apos;, type === &apos;4D&apos;); 
    document.getElementById(&apos;btn5d&apos;).classList.toggle(&apos;active&apos;, type === &apos;5D&apos;); 
    populatePoolSelect(); 
}

function onPoolChange() { }

// ==================== DATABASE MANAGEMENT ====================
function getAllDatabases() {
    const raw = localStorage.getItem(ALL_DATABASES_KEY);
    return raw ? JSON.parse(raw) : {};
}

function saveAllDatabases(databases) {
    localStorage.setItem(ALL_DATABASES_KEY, JSON.stringify(databases));
}

function getActiveDatabase() {
    return localStorage.getItem(ACTIVE_DB_KEY) || &apos;&apos;;
}

function setActiveDatabase(dbName) {
    localStorage.setItem(ACTIVE_DB_KEY, dbName);
}

function loadActiveDatabase() {
    const activeDbName = getActiveDatabase();
    const allDbs = getAllDatabases();
    
    if (activeDbName && allDbs[activeDbName]) {
        atarDB = allDbs[activeDbName];
        updateActiveDbInfo(activeDbName);
    } else {
        atarDB = {};
        updateActiveDbInfo(&apos;&apos;);
    }
    
    populatePoolSelect();
    renderDatabaseList();
}

function switchActiveDatabase() {
    const select = document.getElementById(&apos;activeDbSelect&apos;);
    const dbName = select.value;
    
    if (dbName) {
        const allDbs = getAllDatabases();
        if (allDbs[dbName]) {
            atarDB = allDbs[dbName];
            setActiveDatabase(dbName);
            updateActiveDbInfo(dbName);
            populatePoolSelect();
            
            document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
                `<div style="padding:12px;background:rgba(0,255,0,.07);border:1px solid var(--neon-green);border-radius:8px;color:var(--neon-green)">
                    Database aktif: <b>${escapeHtml(dbName)}</b>
                 </div>`;
        }
    }
}

function updateActiveDbInfo(dbName) {
    const select = document.getElementById(&apos;activeDbSelect&apos;);
    const infoEl = document.getElementById(&apos;activeDbInfo&apos;);
    
    select.value = dbName;
    
    if (dbName && atarDB) {
        const poolCount = Object.keys(atarDB).filter(p => p !== &apos;_timestamp&apos;).length;
        infoEl.textContent = `${poolCount} pool tersedia`;
    } else {
        infoEl.textContent = &apos;Tidak ada database aktif&apos;;
    }
}

function renderDatabaseList() {
    const container = document.getElementById(&apos;databaseList&apos;);
    const allDbs = getAllDatabases();
    const activeDb = getActiveDatabase();
    
    if (Object.keys(allDbs).length === 0) {
        container.innerHTML = &apos;<div style="padding:12px;text-align:center;color:var(--neon-yellow)">Tidak ada database tersimpan</div>&apos;;
        return;
    }
    
    let html = &apos;&apos;;
    Object.keys(allDbs).forEach(dbName => {
        const db = allDbs[dbName];
        const poolCount = Object.keys(db).filter(p => p !== &apos;_timestamp&apos;).length;
        const isActive = dbName === activeDb;
        
        html += `
            <div class="db-list-item ${isActive ? &apos;active&apos; : &apos;&apos;}">
                <div>
                    <div class="db-name">${escapeHtml(dbName)}</div>
                    <div class="db-info">${poolCount} pool  ${new Date(db._timestamp || Date.now()).toLocaleDateString(&apos;id-ID&apos;)}</div>
                </div>
                <div class="db-actions">
                    <button class="db-action-btn db-use-btn" onclick="useDatabase(&apos;${escapeHtml(dbName)}&apos;)">Gunakan</button>
                    <button class="db-action-btn db-delete-btn" onclick="deleteDatabase(&apos;${escapeHtml(dbName)}&apos;)">Hapus</button>
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

function useDatabase(dbName) {
    const allDbs = getAllDatabases();
    if (allDbs[dbName]) {
        atarDB = allDbs[dbName];
        setActiveDatabase(dbName);
        updateActiveDbInfo(dbName);
        populatePoolSelect();
        renderDatabaseList();
        
        document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
            `<div style="padding:12px;background:rgba(0,255,0,.07);border:1px solid var(--neon-green);border-radius:8px;color:var(--neon-green)">
                Database aktif: <b>${escapeHtml(dbName)}</b>
             </div>`;
    }
}

function deleteDatabase(dbName) {
    if (confirm(`Hapus database "${dbName}"?`)) {
        const allDbs = getAllDatabases();
        delete allDbs[dbName];
        saveAllDatabases(allDbs);
        
        if (getActiveDatabase() === dbName) {
            setActiveDatabase(&apos;&apos;);
            atarDB = {};
            updateActiveDbInfo(&apos;&apos;);
            populatePoolSelect();
        }
        
        renderDatabaseList();
        
        document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
            `<div style="padding:12px;background:rgba(255,0,0,.06);border:1px solid var(--neon-red);border-radius:8px;color:var(--neon-red)">
                Database <b>${escapeHtml(dbName)}</b> telah dihapus
             </div>`;
    }
}

function clearAllDatabases() {
    if (confirm(&apos;Hapus semua database? Tindakan ini tidak dapat dibatalkan.&apos;)) {
        localStorage.removeItem(ALL_DATABASES_KEY);
        localStorage.removeItem(ACTIVE_DB_KEY);
        atarDB = {};
        updateActiveDbInfo(&apos;&apos;);
        populatePoolSelect();
        renderDatabaseList();
        
        document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
            `<div style="padding:12px;background:rgba(255,0,0,.06);border:1px solid var(--neon-red);border-radius:8px;color:var(--neon-red)">
                Semua database telah dihapus
             </div>`;
    }
}

// ==================== UTILITY FUNCTIONS ====================
function escapeHtml(s) {
    return String(s).replace(/&/g,&apos;&amp;&apos;).replace(/</g,&apos;&lt;&apos;).replace(/>/g,&apos;&gt;&apos;);
}

function normalizeDay(dayRaw) { 
    if(!dayRaw) return dayRaw; 
    const d = dayRaw.trim(); 
    return d.charAt(0).toUpperCase()+d.slice(1).toLowerCase(); 
}

// ==================== FILE PARSING ====================
function parseAndStoreData(content, sourceFileName) {
    const lines = content.split(/\r?\n/);
    let currentPool = null, currentDay = null; 
    const pools = {};
    
    for(const rawLine of lines) { 
        const line = rawLine.trim(); 
        if(!line) continue;
        
        const poolMatch = line.match(/^POOL\s*:\s*([A-Z0-9_\-]+)/i);
        if(poolMatch) { 
            currentPool = poolMatch[1].toUpperCase(); 
            if(!pools[currentPool]) pools[currentPool] = {}; 
            continue; 
        }
        
        const dayMatch = line.match(/Angka\s+Tarung\s+Hari\s+([A-Za-z]+)/i);
        if(dayMatch && currentPool) { 
            currentDay = normalizeDay(dayMatch[1]); 
            if(!pools[currentPool][currentDay]) pools[currentPool][currentDay] = {}; 
            continue; 
        }
        
        const posMatch = line.match(/^Posisi\s+([A-E])\s*:\s*(.*)$/i);
        if(posMatch && currentPool && currentDay) { 
            const posisi = posMatch[1].toUpperCase(); 
            const rest = posMatch[2]; 
            const groupRegex = /[A-E]\s*:\s*([0-9\s,]+)/gi; 
            let m; 
            const foundSets = []; 
            
            while((m = groupRegex.exec(rest)) !== null) { 
                const nums = m[1].split(&apos;,&apos;).map(s => s.trim()).filter(s => s !== &apos;&apos;); 
                foundSets.push(nums.map(s => parseInt(s,10))); 
            }
            
            if(foundSets.length === 0) { 
                const fallback = rest.match(/([0-9]+\s*(?:,\s*[0-9]+)+)/); 
                if(fallback) { 
                    const arr = fallback[1].split(&apos;,&apos;).map(s => s.trim()); 
                    foundSets.push(arr.map(s => parseInt(s,10))); 
                } 
            }
            
            for(let i = 0; i < foundSets.length; i++) { 
                const atarKey = &apos;ATAR&apos; + (i + 1); 
                if(!pools[currentPool][currentDay][atarKey]) pools[currentPool][currentDay][atarKey] = {}; 
                pools[currentPool][currentDay][atarKey][posisi] = foundSets[i]; 
            }
            continue; 
        }
        
        if(/^=+$/.test(line)) continue; 
    }
    
    pools._timestamp = Date.now();
    return pools;
}

// ==================== UI HELPERS ====================
function populatePoolSelect() { 
    const sel = document.getElementById(&apos;poolSelect&apos;); 
    const sel2 = document.getElementById(&apos;accuracyPoolSelect&apos;);
    const activeDbSelect = document.getElementById(&apos;activeDbSelect&apos;);
    
    sel.innerHTML = &apos;&apos;; 
    sel2.innerHTML = &apos;&apos;;
    activeDbSelect.innerHTML = &apos;<option value="">-- Pilih Database --</option>&apos;;
    
    const pools = Object.keys(atarDB || {}).filter(p => p !== &apos;_timestamp&apos;).sort(); 
    if(pools.length === 0) { 
        const opt = document.createElement(&apos;option&apos;); 
        opt.value = &apos;-&apos;; 
        opt.textContent = &apos;-- Tidak ada DB terdeteksi --&apos;; 
        sel.appendChild(opt); 
        sel2.appendChild(opt.cloneNode(true)); 
    } else { 
        pools.forEach(p => { 
            const opt = document.createElement(&apos;option&apos;); 
            opt.value = p; 
            opt.textContent = p; 
            sel.appendChild(opt); 
            const opt2 = document.createElement(&apos;option&apos;); 
            opt2.value = p; 
            opt2.textContent = p; 
            sel2.appendChild(opt2); 
        }); 
    }
    
    const allDbs = getAllDatabases();
    Object.keys(allDbs).forEach(dbName => {
        const option = document.createElement(&apos;option&apos;);
        option.value = dbName;
        option.textContent = dbName;
        if (dbName === getActiveDatabase()) {
            option.selected = true;
        }
        activeDbSelect.appendChild(option);
    });
}

// ==================== FILE UPLOAD ====================
function handleFileUpload() { 
    const fileInput = document.getElementById(&apos;fileInput&apos;);
    const f = fileInput.files && fileInput.files[0]; 
    
    if(!f) { 
        document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
            `<div style="padding:12px;background:rgba(255,0,0,.06);border:1px solid var(--neon-red);border-radius:8px;color:var(--neon-red)">
                Silakan pilih file terlebih dahulu
             </div>`; 
        return; 
    } 
    
    document.getElementById(&apos;loadingOverlay&apos;).style.display = &apos;flex&apos;; 
    const reader = new FileReader(); 
    reader.onload = function(ev) { 
        setTimeout(() => { 
            document.getElementById(&apos;loadingOverlay&apos;).style.display = &apos;none&apos;; 
            try { 
                const parsedData = parseAndStoreData(String(ev.target.result), f.name);
                const allDbs = getAllDatabases();
                allDbs[f.name] = parsedData;
                saveAllDatabases(allDbs);
                useDatabase(f.name);
                
                document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
                    `<div style="padding:12px;background:rgba(0,255,0,.07);border:1px solid var(--neon-green);border-radius:8px;color:var(--neon-green)">
                        File <b>${escapeHtml(f.name)}</b> berhasil diproses dan disimpan.
                     </div>`;
                       
                renderDatabaseList();
            } catch(err) { 
                document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
                    `<div style="padding:12px;background:rgba(255,0,0,.06);border:1px solid var(--neon-red);border-radius:8px;color:var(--neon-red)">
                        Gagal memproses file: ${escapeHtml(err.message)}
                     </div>`; 
                console.error(err); 
            } 
        }, 300); 
    }; 
    reader.onerror = function() {
        document.getElementById(&apos;loadingOverlay&apos;).style.display = &apos;none&apos;;
        document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
            `<div style="padding:12px;background:rgba(255,0,0,.06);border:1px solid var(--neon-red);border-radius:8px;color:var(--neon-red)">
                Gagal membaca file
             </div>`;
    };
    reader.readAsText(f); 
}

function loadStoredDB() { 
    loadActiveDatabase();
    renderDatabaseList();
    
    const activeDb = getActiveDatabase();
    if (activeDb) {
        document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
            `<div style="padding:12px;background:rgba(0,255,0,.06);border:1px solid var(--neon-green);border-radius:8px;color:var(--neon-green)">
                Database aktif: <b>${escapeHtml(activeDb)}</b>
             </div>`;
    } else {
        document.getElementById(&apos;uploadStatus&apos;).innerHTML = 
            `<div style="padding:12px;background:rgba(255,255,255,.02);border:1px solid rgba(255,255,255,.04);border-radius:8px;color:var(--neon-yellow)">
               Tidak ada database aktif. Silakan upload file atau pilih database.
             </div>`;
    }
}

// ==================== PREDICTION SYSTEM ====================
function generatePredictionsFromDB() { 
    const pool = document.getElementById(&apos;poolSelect&apos;).value; 
    if(!pool || !atarDB[pool]) { 
        alert(&apos;Pilih pool yang valid setelah mengunggah DB.&apos;); 
        return; 
    } 
    
    const startDateInput = document.getElementById(&apos;startDate&apos;).value;
    const endDateInput = document.getElementById(&apos;endDate&apos;).value;
    
    const tbody = document.getElementById(&apos;predictionBody&apos;); 
    tbody.innerHTML = &apos;&apos;; 
    const daysArr = [&apos;Minggu&apos;,&apos;Senin&apos;,&apos;Selasa&apos;,&apos;Rabu&apos;,&apos;Kamis&apos;,&apos;Jumat&apos;,&apos;Sabtu&apos;]; 
    const today = new Date();
    
    let startDate = startDateInput ? new Date(startDateInput) : new Date();
    let endDate = endDateInput ? new Date(endDateInput) : new Date();
    endDate.setDate(endDate.getDate() + 1);
    
    const diffTime = Math.abs(endDate - startDate);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    for(let i = 0; i < diffDays; i++) { 
        const d = new Date(startDate);
        d.setDate(startDate.getDate() + i);
        const dayName = daysArr[d.getDay()]; 
        const dateLabel = `${dayName}, ${d.toLocaleDateString(&apos;id-ID&apos;)}`; 
        const positions = (currentPoolType === &apos;4D&apos;) ? [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;] : [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;]; 
        const dayData = atarDB[pool] && atarDB[pool][dayName] ? atarDB[pool][dayName] : null;
        
        positions.forEach((pos, index) => { 
            const tr = document.createElement(&apos;tr&apos;); 
            if(index === 0) tr.className = &apos;date-row&apos;; 
            const atar1 = (dayData && dayData.ATAR1 && dayData.ATAR1[pos]) ? dayData.ATAR1[pos].join(&apos;, &apos;) : &apos;-&apos;; 
            const atar2 = (dayData && dayData.ATAR2 && dayData.ATAR2[pos]) ? dayData.ATAR2[pos].join(&apos;, &apos;) : &apos;-&apos;; 
            const atar3 = (dayData && dayData.ATAR3 && dayData.ATAR3[pos]) ? dayData.ATAR3[pos].join(&apos;, &apos;) : &apos;-&apos;; 
            
            if(index === 0) { 
                tr.innerHTML = `<td rowspan="${positions.length}">${dateLabel}</td><td>Posisi ${pos}</td><td>${atar1}</td><td>${atar2}</td><td>${atar3}</td><td rowspan="${positions.length}">${dayData ? &apos;Data asli&apos; : &apos;Tidak ada data, tampilkan -&apos;}</td>`; 
            } else { 
                tr.innerHTML = `<td>Posisi ${pos}</td><td>${atar1}</td><td>${atar2}</td><td>${atar3}</td>`; 
            } 
            tbody.appendChild(tr); 
        }); 
    } 
}

// ==================== ACCURACY SYSTEM ====================
function evaluateAtarForResult(atarSets, resultStr) {
    const len = resultStr.length;
    const digits = resultStr.split(&apos;&apos;).map(d => d);
    
    const positions = (len === 4) ? [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;] : [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;];
    const posMatch = positions.map((pos, i) => {
        const list = (atarSets && atarSets[pos]) ? atarSets[pos] : [];
        const digit = digits[i];
        return list.map(String).includes(digit);
    });
    
    if(len === 4) { 
        const all4 = posMatch.every(Boolean);
        const bcd = posMatch.slice(1,4).every(Boolean);
        
        if(all4) return &apos;Menang 4D&apos;;
        if(bcd) return &apos;Menang 3D&apos;;
        return &apos;Kalah&apos;;
    } else { 
        const all5 = posMatch.every(Boolean);
        const xbcde = posMatch.slice(1,5).every(Boolean);
        const xxcde = posMatch.slice(2,5).every(Boolean);
        
        if(all5) return &apos;Menang 5D&apos;;
        if(xbcde) return &apos;Menang 4D&apos;;
        if(xxcde) return &apos;Menang 3D&apos;;
        return &apos;Kalah&apos;;
    }
}

function checkAccuracy() {
    const pool = document.getElementById(&apos;accuracyPoolSelect&apos;).value;
    const dateStr = document.getElementById(&apos;accuracyDate&apos;).value;
    const result = (document.getElementById(&apos;accuracyResultInput&apos;).value || &apos;&apos;).trim();
    
    if(!pool || pool === &apos;-&apos;) { 
        alert(&apos;Pilih pool yang valid.&apos;); 
        return; 
    }
    if(!dateStr) { 
        alert(&apos;Pilih tanggal.&apos;); 
        return; 
    }
    if(!result || !(result.length === 4 || result.length === 5)) { 
        alert(&apos;Masukkan result 4D atau 5D.&apos;); 
        return; 
    }
    
    const d = new Date(dateStr);
    const daysArr = [&apos;Minggu&apos;,&apos;Senin&apos;,&apos;Selasa&apos;,&apos;Rabu&apos;,&apos;Kamis&apos;,&apos;Jumat&apos;,&apos;Sabtu&apos;];
    const dayName = daysArr[d.getDay()];
    const dayData = atarDB[pool] && atarDB[pool][dayName];
    
    if(!dayData) { 
        document.getElementById(&apos;accuracyOutput&apos;).innerHTML = 
            `<div style="padding:12px;background:rgba(255,255,255,.03);border-radius:8px">
               Tidak ada data ATAR untuk <b>${pool}</b> pada hari <b>${dayName}</b>.
             </div>`; 
        return; 
    }
    
    const resultLen = result.length;
    const atarKeys = [&apos;ATAR1&apos;,&apos;ATAR2&apos;,&apos;ATAR3&apos;];
    const resultsPerAtar = [];
    let winnersCount = 0;
    let hasBigWin = false;
    
    for(const key of atarKeys) {
        const sets = dayData[key] || {};
        const res = evaluateAtarForResult(sets, result);
        resultsPerAtar.push({key, res});
        if(res.startsWith(&apos;Menang&apos;)) {
            winnersCount++;
            if(res === &apos;Menang 5D&apos; || res === &apos;Menang 4D&apos;) hasBigWin = true;
        }
    }
    
    const lines = [];
    lines.push(`<div style="padding:8px 0;margin-bottom:6px"><strong>Pool:</strong> ${escapeHtml(pool)} &nbsp;&nbsp; <strong>Hari:</strong> ${escapeHtml(dayName)} &nbsp;&nbsp; <strong>Result:</strong> ${escapeHtml(result)}</div>`);
    lines.push(&apos;<div style="font-weight:700;margin-bottom:6px">Detail:</div>&apos;);
    
    for(const r of resultsPerAtar) {
        let cls = &apos;lose&apos;;
        if(r.res === &apos;Menang 5D&apos;) cls = &apos;win5d&apos;;
        else if(r.res === &apos;Menang 4D&apos;) cls = &apos;win4d&apos;;
        else if(r.res === &apos;Menang 3D&apos;) cls = &apos;win3d&apos;;
        
        lines.push(`<div class="accuracy-line"><div class="atar-label">${r.key}</div><div class="${cls}">${r.res}</div></div>`);
    }
    
    lines.push(`<div style="margin-top:12px;font-weight:800">Akurasi: ${winnersCount} dari 3 ATAR menang</div>`);
    
    lines.push(&apos;<div style="margin-top:12px;padding:10px;background:rgba(255,255,255,.05);border-radius:6px;font-size:0.9em">&apos;);
    lines.push(&apos;<div style="font-weight:700;margin-bottom:4px">Catatan cara menghitung:</div>&apos;);
    lines.push(&apos;<div>1. Cek Angka Result sesuai dengan posisi nya</div>&apos;);
    lines.push(&apos;<div>2. FORMAT 4D: ABCD= YYYY,menang 4D | BCD=XYYY,menang 3D | selain itu kalah</div>&apos;);
    lines.push(&apos;<div>3. FORMAT 5D: ABCDE= YYYYY,menang 5D | XBCDE=XYYYY,menang 4D | XXCDE=XYYYY,menang 3D | selain itu kalah</div>&apos;);
    lines.push(&apos;</div>&apos;);
    
    document.getElementById(&apos;accuracyOutput&apos;).innerHTML = lines.join(&apos;\n&apos;);
    
    saveHistory({
        date: d.toISOString(),
        pool, 
        prediction: getActiveDatabase() || &apos;DB_ATAR&apos;,
        result, 
        atarResults: resultsPerAtar,
        accuracy: Math.round((winnersCount/3)*100)
    });
    renderHistory();
    
    if(hasBigWin) { 
        triggerJackpot(); 
    }
}

// ==================== HISTORY SYSTEM ====================
function saveHistory(item) { 
    const raw = localStorage.getItem(HISTORY_KEY) || &apos;[]&apos;; 
    const arr = JSON.parse(raw); 
    arr.push(item); 
    localStorage.setItem(HISTORY_KEY, JSON.stringify(arr)); 
}

function renderHistory() { 
    const raw = localStorage.getItem(HISTORY_KEY) || &apos;[]&apos;; 
    const arr = JSON.parse(raw).slice(-200).reverse(); 
    const tbody = document.getElementById(&apos;historyBody&apos;); 
    tbody.innerHTML = &apos;&apos;; 
    
    arr.forEach(it => { 
        const tr = document.createElement(&apos;tr&apos;); 
        tr.className = &apos;history-row&apos;;
        
        const d = new Date(it.date); 
        const days = [&apos;Minggu&apos;,&apos;Senin&apos;,&apos;Selasa&apos;,&apos;Rabu&apos;,&apos;Kamis&apos;,&apos;Jumat&apos;,&apos;Sabtu&apos;];
        const dayName = days[d.getDay()];
        const dateFormatted = `${dayName}, ${d.getDate().toString().padStart(2, &apos;0&apos;)}/${(d.getMonth()+1).toString().padStart(2, &apos;0&apos;)}/${d.getFullYear()}`;
        
        const tdDate = document.createElement(&apos;td&apos;);
        tdDate.className = &apos;history-date&apos;;
        tdDate.textContent = dateFormatted;
        
        const tdPool = document.createElement(&apos;td&apos;);
        tdPool.className = &apos;history-pool&apos;;
        tdPool.textContent = escapeHtml(it.pool);
        
        const tdPrediction = document.createElement(&apos;td&apos;);
        tdPrediction.className = &apos;history-prediction&apos;;
        tdPrediction.textContent = escapeHtml(it.prediction);
        
        const tdResult = document.createElement(&apos;td&apos;);
        tdResult.className = &apos;history-result&apos;;
        tdResult.textContent = escapeHtml(it.result);
        
        const tdStatus = document.createElement(&apos;td&apos;);
        tdStatus.className = &apos;history-status&apos;;
        
        if(it.atarResults && Array.isArray(it.atarResults)) {
            it.atarResults.forEach(atar => {
                const atarLine = document.createElement(&apos;div&apos;);
                atarLine.className = &apos;atar-result-line&apos;;
                
                let cls = &apos;lose&apos;;
                if(atar.res === &apos;Menang 5D&apos;) cls = &apos;win5d&apos;;
                else if(atar.res === &apos;Menang 4D&apos;) cls = &apos;win4d&apos;;
                else if(atar.res === &apos;Menang 3D&apos;) cls = &apos;win3d&apos;;
                
                atarLine.innerHTML = `<span class="${cls}">${atar.key} ${atar.res}</span>`;
                tdStatus.appendChild(atarLine);
            });
        } else {
            tdStatus.innerHTML = `<span style="color:${it.status && it.status.includes(&apos;Menang&apos;) ? &apos;var(--neon-green)&apos; : &apos;var(--neon-red)&apos;}">${escapeHtml(it.status || &apos;Tidak ada data&apos;)}</span>`;
        }
        
        const tdAccuracy = document.createElement(&apos;td&apos;);
        tdAccuracy.className = &apos;history-accuracy&apos;;
        tdAccuracy.textContent = it.accuracy ? `${it.accuracy}%` : &apos;0%&apos;;
        
        tr.appendChild(tdDate);
        tr.appendChild(tdPool);
        tr.appendChild(tdPrediction);
        tr.appendChild(tdResult);
        tr.appendChild(tdStatus);
        tr.appendChild(tdAccuracy);
        
        tbody.appendChild(tr); 
    }); 
}

function clearHistory() {
    if(confirm(&apos;Apakah Anda yakin ingin menghapus semua data riwayat?&apos;)) {
        localStorage.removeItem(HISTORY_KEY);
        renderHistory();
        alert(&apos;Data riwayat berhasil dihapus.&apos;);
    }
}

function exportToPDF() {
    const raw = localStorage.getItem(HISTORY_KEY) || &apos;[]&apos;;
    const arr = JSON.parse(raw);
    
    if(arr.length === 0) {
        alert(&apos;Tidak ada data riwayat untuk diekspor.&apos;);
        return;
    }
    
    let content = &apos;Riwayat Hasil GPT ATAR Pro V2\n\n&apos;;
    content += &apos;Tanggal, Pool, Prediksi, Result, Status, Akurasi\n&apos;;
    
    arr.forEach(item => {
        const d = new Date(item.date);
        const dateStr = `${d.toLocaleDateString(&apos;id-ID&apos;)} ${d.toLocaleTimeString(&apos;id-ID&apos;)}`;
        content += `${dateStr}, ${item.pool}, ${item.prediction}, ${item.result}, ${item.status}, ${item.accuracy}%\n`;
    });
    
    const blob = new Blob([content], { type: &apos;text/plain&apos; });
    const url = URL.createObjectURL(blob);
    const a = document.createElement(&apos;a&apos;);
    a.href = url;
    a.download = &apos;riwayat_hasil_gpt_atar.txt&apos;;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    alert(&apos;Data berhasil diekspor sebagai file teks (format CSV).&apos;);
}

function exportToExcel() {
    const raw = localStorage.getItem(HISTORY_KEY) || &apos;[]&apos;;
    const arr = JSON.parse(raw);
    
    if(arr.length === 0) {
        alert(&apos;Tidak ada data riwayat untuk diekspor.&apos;);
        return;
    }
    
    let csvContent = &apos;Tanggal,Pool,Prediksi,Result,Status,Akurasi\n&apos;;
    
    arr.forEach(item => {
        const d = new Date(item.date);
        const dateStr = `${d.toLocaleDateString(&apos;id-ID&apos;)} ${d.toLocaleTimeString(&apos;id-ID&apos;)}`;
        csvContent += `"${dateStr}","${item.pool}","${item.prediction}","${item.result}","${item.status}","${item.accuracy}"\n`;
    });
    
    const blob = new Blob([csvContent], { type: &apos;text/csv;charset=utf-8;&apos; });
    const url = URL.createObjectURL(blob);
    const a = document.createElement(&apos;a&apos;);
    a.href = url;
    a.download = &apos;riwayat_hasil_gpt_atar.csv&apos;;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    alert(&apos;Data berhasil diekspor sebagai file CSV (dapat dibuka di Excel).&apos;);
}

// ==================== PERMUTASI SYSTEM ====================
function togglePositionE() {
    const poolSelect = document.getElementById(&apos;permPoolSelect&apos;);
    const posEGroup = document.getElementById(&apos;posEGroup&apos;);
    
    if(poolSelect.value === &apos;T15&apos; || poolSelect.value === &apos;T21&apos;) {
        posEGroup.style.display = &apos;block&apos;;
    } else {
        posEGroup.style.display = &apos;none&apos;;
    }
}

function moveToNext(current, nextFieldId) {
    if(current.value.length >= current.maxLength) {
        const nextField = document.getElementById(nextFieldId);
        if(nextField && nextField.style.display !== &apos;none&apos;) {
            nextField.focus();
        }
    }
}

function doPermutation() {
    const pool = document.getElementById(&apos;permPoolSelect&apos;).value;
    const date = document.getElementById(&apos;permDate&apos;).value;
    const posA = document.getElementById(&apos;posA&apos;).value;
    const posB = document.getElementById(&apos;posB&apos;).value;
    const posC = document.getElementById(&apos;posC&apos;).value;
    const posD = document.getElementById(&apos;posD&apos;).value;
    const posE = document.getElementById(&apos;posE&apos;).value;
    const loading = document.getElementById(&apos;permLoading&apos;);
    const result = document.getElementById(&apos;permResult&apos;);
    
    if(!pool || !date || !posA || !posB || !posC || !posD) {
        alert(&apos;Silakan lengkapi semua input!&apos;);
        return;
    }
    
    loading.style.display = &apos;block&apos;;
    
    setTimeout(() => {
        loading.style.display = &apos;none&apos;;
        
        const filters = {
            a: getFilterOptions(&apos;A&apos;),
            b: getFilterOptions(&apos;B&apos;),
            c: getFilterOptions(&apos;C&apos;),
            d: getFilterOptions(&apos;D&apos;),
            e: getFilterOptions(&apos;E&apos;)
        };
        
        const permutations = generatePermutations(posA, posB, posC, posD, posE, filters);
        
        let resultHTML = `
            <h3 style="color:var(--neon-yellow);margin-bottom:10px;"> Hasil Permutasi Pool: ${pool}</h3>
            <p style="margin-bottom:5px;"> Tanggal: ${new Date(date).toLocaleDateString(&apos;id-ID&apos;)}</p>
            <p style="margin-bottom:15px;color:var(--neon-green)"> Total Permutasi: ${permutations.length}</p>
            <hr style="border-color:var(--neon-purple);margin:15px 0;">
            <div class="permutation-result" style="font-family:monospace;line-height:1.8;">
        `;
        
        const permutationString = permutations.join(&apos; * &apos;);
        resultHTML += `<div style="word-wrap:break-word;">${permutationString}</div>`;
        
        resultHTML += &apos;</div>&apos;;
        result.innerHTML = resultHTML;
    }, 1000);
}

function getFilterOptions(position) {
    return {
        odd: document.getElementById(`pangkas${position}Odd`).checked,
        even: document.getElementById(`pangkas${position}Even`).checked,
        big: document.getElementById(`pangkas${position}Big`).checked,
        small: document.getElementById(`pangkas${position}Small`).checked
    };
}

function generatePermutations(a, b, c, d, e, filters) {
    const results = [];
    const posA = filterDigits(a.split(&apos;&apos;), filters.a);
    const posB = filterDigits(b.split(&apos;&apos;), filters.b);
    const posC = filterDigits(c.split(&apos;&apos;), filters.c);
    const posD = filterDigits(d.split(&apos;&apos;), filters.d);
    const posE = e ? filterDigits(e.split(&apos;&apos;), filters.e) : [&apos;&apos;];
    
    for(let i = 0; i < posA.length; i++) {
        for(let j = 0; j < posB.length; j++) {
            for(let k = 0; k < posC.length; k++) {
                for(let l = 0; l < posD.length; l++) {
                    if(e && posE.length > 0) {
                        for(let m = 0; m < posE.length; m++) {
                            results.push(`${posA[i]}${posB[j]}${posC[k]}${posD[l]}${posE[m]}`);
                        }
                    } else {
                        results.push(`${posA[i]}${posB[j]}${posC[k]}${posD[l]}`);
                    }
                }
            }
        }
    }
    
    return results;
}

function filterDigits(digits, filters) {
    if (!filters.odd && !filters.even && !filters.big && !filters.small) {
        return digits;
    }
    
    return digits.filter(digit => {
        const num = parseInt(digit);
        let include = true;
        
        if (filters.odd && num % 2 === 0) include = false;
        if (filters.even && num % 2 !== 0) include = false;
        if (filters.big && num < 5) include = false;
        if (filters.small && num >= 5) include = false;
        
        return include;
    });
}

function copyPermutationResult() {
    const element = document.getElementById(&apos;permResult&apos;);
    const text = element.innerText;
    
    navigator.clipboard.writeText(text).then(() => {
        const btn = event.target;
        const originalText = btn.innerText;
        btn.innerText = &apos; Tersalin!&apos;;
        setTimeout(() => {
            btn.innerText = originalText;
        }, 2000);
    });
}

function clearPermutationInputs() {
    document.getElementById(&apos;posA&apos;).value = &apos;&apos;;
    document.getElementById(&apos;posB&apos;).value = &apos;&apos;;
    document.getElementById(&apos;posC&apos;).value = &apos;&apos;;
    document.getElementById(&apos;posD&apos;).value = &apos;&apos;;
    document.getElementById(&apos;posE&apos;).value = &apos;&apos;;
    document.getElementById(&apos;permResult&apos;).innerHTML = 
        &apos;<div style="text-align:center;color:var(--neon-yellow);padding:20px"> Hasil permutasi akan ditampilkan di sini...</div>&apos;;
    
    document.querySelectorAll(&apos;.pangkas-options input[type="checkbox"]&apos;).forEach(checkbox => {
        checkbox.checked = false;
    });
}

// ==================== DATABASIS MANAGEMENT ====================
document.getElementById(&apos;databasisFile&apos;).addEventListener(&apos;change&apos;, function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(event) {
        const content = event.target.result;
        try {
            databasisData = parseDatabasis(content);
            document.getElementById(&apos;databasisInfo&apos;).innerHTML = 
                `Status: <span style="color:var(--neon-green)">Databasis berhasil diupload (${Object.keys(databasisData).length} pools)</span>`;
        } catch (error) {
            console.error(&apos;Error parsing databasis:&apos;, error);
            document.getElementById(&apos;databasisInfo&apos;).innerHTML = 
                &apos;Status: <span style="color:var(--neon-red)">Error parsing databasis</span>&apos;;
        }
    };
    reader.readAsText(file);
});

function saveDatabasis() {
    if (!databasisData) {
        alert(&apos;Tidak ada databasis yang diupload!&apos;);
        return;
    }
    
    try {
        localStorage.setItem(&apos;matrixDatabasis&apos;, JSON.stringify(databasisData));
        document.getElementById(&apos;databasisInfo&apos;).innerHTML = 
            &apos;Status: <span style="color:var(--neon-green)">Databasis berhasil disimpan di localStorage</span>&apos;;
    } catch (error) {
        console.error(&apos;Error saving databasis:&apos;, error);
        document.getElementById(&apos;databasisInfo&apos;).innerHTML = 
            &apos;Status: <span style="color:var(--neon-red)">Error menyimpan databasis</span>&apos;;
    }
}

function loadDatabasisData() {
    const pool = document.getElementById(&apos;permPoolSelect&apos;).value;
    const dateStr = document.getElementById(&apos;permDate&apos;).value;
    
    if (!pool) {
        alert(&apos;Pilih pool terlebih dahulu!&apos;);
        return;
    }
    
    if (!dateStr) {
        alert(&apos;Pilih tanggal terlebih dahulu!&apos;);
        return;
    }
    
    if (!databasisData) {
        const stored = localStorage.getItem(&apos;matrixDatabasis&apos;);
        if (stored) {
            try {
                databasisData = JSON.parse(stored);
            } catch (error) {
                alert(&apos;Error memuat databasis dari localStorage&apos;);
                return;
            }
        } else {
            alert(&apos;Tidak ada databasis yang tersimpan!&apos;);
            return;
        }
    }
    
    const date = new Date(dateStr);
    const days = [&apos;Minggu&apos;, &apos;Senin&apos;, &apos;Selasa&apos;, &apos;Rabu&apos;, &apos;Kamis&apos;, &apos;Jumat&apos;, &apos;Sabtu&apos;];
    const dayName = days[date.getDay()];
    
    if (!databasisData[pool] || !databasisData[pool][dayName]) {
        alert(`Data tidak ditemukan untuk pool ${pool} pada hari ${dayName}`);
        return;
    }
    
    const data = databasisData[pool][dayName];
    
    document.getElementById(&apos;posA&apos;).value = data.A ? data.A.join(&apos;&apos;) : &apos;&apos;;
    document.getElementById(&apos;posB&apos;).value = data.B ? data.B.join(&apos;&apos;) : &apos;&apos;;
    document.getElementById(&apos;posC&apos;).value = data.C ? data.C.join(&apos;&apos;) : &apos;&apos;;
    document.getElementById(&apos;posD&apos;).value = data.D ? data.D.join(&apos;&apos;) : &apos;&apos;;
    
    if (data.E) {
        document.getElementById(&apos;posE&apos;).value = data.E.join(&apos;&apos;);
    }
    
    document.getElementById(&apos;databasisInfo&apos;).innerHTML = 
        `Status: <span style="color:var(--neon-green)">Data untuk ${pool} (${dayName}) berhasil dimuat</span>`;
}

function parseDatabasis(text) {
    const lines = text.split(&apos;\n&apos;);
    const result = {};
    let currentPool = null;
    let currentDay = null;
    
    for (let line of lines) {
        line = line.trim();
        
        if (line.startsWith(&apos;POOL &apos;)) {
            const poolMatch = line.match(/POOL (\w+)/);
            if (poolMatch) {
                currentPool = poolMatch[1];
                result[currentPool] = {};
            }
        } else if (line.startsWith(&apos;===&apos;)) {
            const dayMatch = line.match(/=== (\w+) ===/);
            if (dayMatch && currentPool) {
                currentDay = dayMatch[1];
                result[currentPool][currentDay] = {};
            }
        } else if (line.startsWith(&apos;Posisi &apos;)) {
            const posMatch = line.match(/Posisi (\w+): ([\d,\s]+)/);
            if (posMatch && currentPool && currentDay) {
                const position = posMatch[1];
                const numbers = posMatch[2].split(&apos;,&apos;).map(num => num.trim());
                result[currentPool][currentDay][position] = numbers;
            }
        }
    }
    
    return result;
}

// ==================== ANALISIS SYSTEM ====================
document.getElementById(&apos;historyFile&apos;).addEventListener(&apos;change&apos;, function(e) {
    uploadHistoryFile(e);
});

function uploadHistoryFile(e) {
    const file = e.target.files[0];
    const poolSelect = document.getElementById(&apos;analPoolSelect&apos;);
    
    if(!poolSelect.value) {
        alert(&apos;Silakan pilih pool terlebih dahulu!&apos;);
        return;
    }
    
    if(!file) {
        alert(&apos;Silakan pilih file history!&apos;);
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        const lines = content.split(&apos;\n&apos;);
        let addedCount = 0;
        let errorCount = 0;
        
        lines.forEach(line => {
            line = line.trim();
            if (line) {
                const parts = line.split(&apos;,&apos;);
                
                if (parts.length >= 4) {
                    let date, numbers;
                    
                    if (isValidDate(parts[0])) {
                        date = formatDate(parts[0]);
                        numbers = parts.slice(1, 5);
                    } else {
                        const autoDate = new Date();
                        autoDate.setDate(autoDate.getDate() - Math.floor(Math.random() * 30));
                        date = formatDate(autoDate.toLocaleDateString(&apos;id-ID&apos;));
                        numbers = parts.slice(0, 4);
                    }
                    
                    if (numbers.every(num => isValidNumber(num))) {
                        analisisHistoryData[poolSelect.value].push({
                            date: date,
                            numbers: numbers,
                            pool: poolSelect.value
                        });
                        addedCount++;
                    } else {
                        errorCount++;
                    }
                } else {
                    errorCount++;
                }
            }
        });
        
        document.getElementById(&apos;historyInfo&apos;).innerHTML = 
            `Status: <span style="color:var(--neon-green)">History berhasil diupload! ${addedCount} entri ditambahkan. ${errorCount > 0 ? `(${errorCount} error)` : &apos;&apos;}</span>`;
        
        displayHistoryTable();
        saveAnalisisHistoryToStorage();
    };
    reader.readAsText(file);
}

function addManualHistory() {
    const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
    if(!pool) {
        alert(&apos;Silakan pilih pool terlebih dahulu!&apos;);
        return;
    }
    
    const date = prompt(&apos;Masukkan tanggal (dd/mm/yyyy):&apos;);
    if (!date || !isValidDate(date)) {
        alert(&apos;Format tanggal tidak valid! Gunakan format dd/mm/yyyy&apos;);
        return;
    }
    
    const numbers = prompt(&apos;Masukkan angka result (contoh: 1,2,3,4):&apos;);
    if (!numbers) {
        return;
    }
    
    const numberArray = numbers.split(&apos;,&apos;).map(num => num.trim());
    if (!numberArray.every(num => isValidNumber(num)) || numberArray.length < 4) {
        alert(&apos;Format angka tidak valid! Pastikan semua angka antara 0-9 dan minimal 4 angka&apos;);
        return;
    }
    
    analisisHistoryData[pool].push({
        date: formatDate(date),
        numbers: numberArray.slice(0, 4),
        pool: pool
    });
    
    document.getElementById(&apos;historyInfo&apos;).innerHTML = 
        `Status: <span style="color:var(--neon-green)">History manual ditambahkan: ${date} - ${numbers}</span>`;
    
    displayHistoryTable();
    saveAnalisisHistoryToStorage();
}

function saveAnalisisHistory() {
    const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
    if(!pool) {
        alert(&apos;Silakan pilih pool terlebih dahulu!&apos;);
        return;
    }
    
    try {
        const data = analisisHistoryData[pool];
        if (data.length === 0) {
            alert(&apos;Tidak ada data history untuk diekspor!&apos;);
            return;
        }
        
        let csvContent = &apos;Tanggal,Angka1,Angka2,Angka3,Angka4,Pool\n&apos;;
        data.forEach(item => {
            csvContent += `"${item.date}","${item.numbers[0]}","${item.numbers[1]}","${item.numbers[2]}","${item.numbers[3]}","${item.pool}"\n`;
        });
        
        const blob = new Blob([csvContent], { type: &apos;text/csv;charset=utf-8;&apos; });
        const url = URL.createObjectURL(blob);
        const a = document.createElement(&apos;a&apos;);
        a.href = url;
        a.download = `history_${pool}_${new Date().getTime()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        document.getElementById(&apos;historyInfo&apos;).innerHTML = 
            `Status: <span style="color:var(--neon-green)">History untuk pool ${pool} berhasil diekspor! ${data.length} entri</span>`;
    } catch (e) {
        alert(&apos;Gagal menyimpan history: &apos; + e.message);
    }
}

function loadAnalisisHistory() {
    const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
    if(!pool) {
        alert(&apos;Silakan pilih pool terlebih dahulu!&apos;);
        return;
    }
    
    try {
        const savedData = localStorage.getItem(`analisis-history-${pool}`);
        if (savedData) {
            analisisHistoryData[pool] = JSON.parse(savedData);
            document.getElementById(&apos;historyInfo&apos;).innerHTML = 
                `Status: <span style="color:var(--neon-green)">History untuk pool ${pool} berhasil dimuat! ${analisisHistoryData[pool].length} entri</span>`;
            displayHistoryTable();
        } else {
            document.getElementById(&apos;historyInfo&apos;).innerHTML = 
                `Status: <span style="color:var(--neon-yellow)">Tidak ada data history yang tersimpan untuk pool ${pool}</span>`;
        }
    } catch (e) {
        alert(&apos;Gagal memuat history: &apos; + e.message);
    }
}

function clearAnalisisHistory() {
    const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
    if(!pool) {
        alert(&apos;Silakan pilih pool terlebih dahulu!&apos;);
        return;
    }
    
    if(confirm(`Apakah Anda yakin ingin menghapus semua history untuk pool ${pool}?`)) {
        analisisHistoryData[pool] = [];
        localStorage.removeItem(`analisis-history-${pool}`);
        document.getElementById(&apos;historyInfo&apos;).innerHTML = 
            `Status: <span style="color:var(--neon-green)">History untuk pool ${pool} telah dihapus!</span>`;
        displayHistoryTable();
    }
}

function saveAnalisisHistoryToStorage() {
    const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
    if(pool) {
        try {
            localStorage.setItem(`analisis-history-${pool}`, JSON.stringify(analisisHistoryData[pool]));
        } catch (e) {
            console.error(&apos;Gagal menyimpan history ke localStorage:&apos;, e);
        }
    }
}

function displayHistoryTable() {
    const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
    const tableBody = document.getElementById(&apos;historyTableBody&apos;);
    
    if (!pool) {
        tableBody.innerHTML = &apos;<tr><td colspan="4" style="text-align:center;padding:20px;color:var(--neon-yellow)">Pilih pool untuk melihat history</td></tr>&apos;;
        return;
    }
    
    const data = analisisHistoryData[pool];
    
    if (data.length === 0) {
        tableBody.innerHTML = &apos;<tr><td colspan="4" style="text-align:center;padding:20px;color:var(--neon-yellow)">Tidak ada data history</td></tr>&apos;;
        return;
    }
    
    const sortedData = [...data].sort((a, b) => {
        return new Date(b.date.split(&apos;/&apos;).reverse().join(&apos;-&apos;)) - new Date(a.date.split(&apos;/&apos;).reverse().join(&apos;-&apos;));
    });
    
    let html = &apos;&apos;;
    sortedData.forEach((item, index) => {
        html += `<tr>
            <td>${item.date}</td>
            <td>${item.pool}</td>
            <td>${item.numbers.join(&apos;, &apos;)}</td>
            <td>
                <button onclick="deleteHistoryItem(&apos;${pool}&apos;, ${index})" style="padding:2px 6px;background:var(--neon-red);color:white;border:none;border-radius:3px;font-size:10px;cursor:pointer">Hapus</button>
            </td>
        </tr>`;
    });
    
    tableBody.innerHTML = html;
}

function deleteHistoryItem(pool, index) {
    if(confirm(&apos;Hapus data history ini?&apos;)) {
        analisisHistoryData[pool].splice(index, 1);
        saveAnalisisHistoryToStorage();
        displayHistoryTable();
        document.getElementById(&apos;historyInfo&apos;).innerHTML = 
            `Status: <span style="color:var(--neon-green)">Data history berhasil dihapus</span>`;
    }
}

function isValidDate(dateString) {
    const regex = /^\d{2}\/\d{2}\/\d{4}$/;
    return regex.test(dateString);
}

function isValidNumber(num) {
    return !isNaN(num) && num >= 0 && num <= 9;
}

function formatDate(dateString) {
    if (dateString.includes(&apos;-&apos;)) {
        const parts = dateString.split(&apos;-&apos;);
        return `${parts[2]}/${parts[1]}/${parts[0]}`;
    }
    return dateString;
}

function updateHistoryButtons() {
    const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
    const saveBtn = document.querySelector(&apos;button[onclick="saveAnalisisHistory()"]&apos;);
    const loadBtn = document.querySelector(&apos;button[onclick="loadAnalisisHistory()"]&apos;);
    const clearBtn = document.querySelector(&apos;button[onclick="clearAnalisisHistory()"]&apos;);
    
    if (pool) {
        saveBtn.disabled = false;
        loadBtn.disabled = false;
        clearBtn.disabled = false;
    } else {
        saveBtn.disabled = true;
        loadBtn.disabled = true;
        clearBtn.disabled = true;
    }
    
    displayHistoryTable();
}

function runAnalysis() {
    const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
    const loading = document.getElementById(&apos;analLoading&apos;);
    const result = document.getElementById(&apos;analResult&apos;);
    const analysisResults = document.getElementById(&apos;analysisResults&apos;);
    
    if(!pool) {
        alert(&apos;Silakan pilih pool terlebih dahulu!&apos;);
        return;
    }
    
    const history = analisisHistoryData[pool];
    if (history.length === 0) {
        alert(&apos;Tidak ada data history untuk pool ini. Silakan upload atau tambah data history terlebih dahulu.&apos;);
        return;
    }
    
    loading.style.display = &apos;block&apos;;
    
    setTimeout(() => {
        loading.style.display = &apos;none&apos;;
        
        analysisResults.innerHTML = &apos;&apos;;
        
        const positions = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;];
        if(pool === &apos;T15&apos; || pool === &apos;T21&apos;) {
            positions.push(&apos;E&apos;);
        }
        
        const analysisData = performAdvancedAnalysis(history, positions);
        
        if(document.getElementById(&apos;analSelisih&apos;).checked) {
            const card = createAnalysisCard(&apos; Pola Selisih & Arah&apos;);
            positions.forEach(pos => {
                const trend = analysisData.trends[pos] || &apos;Stabil&apos;;
                const percentage = analysisData.accuracy[pos] || &apos;50%&apos;;
                const div = document.createElement(&apos;div&apos;);
                div.className = &apos;position-result&apos;;
                div.innerHTML = `
                    <div class="position-title">Posisi ${pos}</div>
                    <div class="position-data">Tren: ${trend} (Akurasi: ${percentage})</div>
                `;
                card.appendChild(div);
            });
            analysisResults.appendChild(card);
        }
        
        if(document.getElementById(&apos;analMarkov&apos;).checked) {
            const card = createAnalysisCard(&apos; Transisi Markov&apos;);
            positions.forEach(pos => {
                const transitions = analysisData.transitions[pos] || &apos;0-1-2&apos;;
                const div = document.createElement(&apos;div&apos;);
                div.className = &apos;position-result&apos;;
                div.innerHTML = `
                    <div class="position-title">Posisi ${pos}</div>
                    <div class="position-data">Pola: ${transitions}</div>
                `;
                card.appendChild(div);
            });
            analysisResults.appendChild(card);
        }
        
        if(document.getElementById(&apos;analDominasi&apos;).checked) {
            const card = createAnalysisCard(&apos; Dominasi & Stabilitas&apos;);
            positions.forEach(pos => {
                const dominant = analysisData.dominantNumbers[pos] || &apos;0,1,2&apos;;
                const div = document.createElement(&apos;div&apos;);
                div.className = &apos;position-result&apos;;
                div.innerHTML = `
                    <div class="position-title">Posisi ${pos}</div>
                    <div class="position-data">Angka Dominan: ${dominant}</div>
                `;
                card.appendChild(div);
            });
            analysisResults.appendChild(card);
        }
        
        let analysisHTML = `
            <h3 style="color:var(--neon-yellow);margin-bottom:10px;"> Hasil Analisis Pool: ${pool}</h3>
            <p style="margin-bottom:5px;"> Waktu analisis: ${new Date().toLocaleString()}</p>
            <p style="margin-bottom:5px;"> Data history: ${history.length} entri</p>
            <p style="margin-bottom:15px;color:var(--neon-green)"> Metode analisis: ${getSelectedMethods()}</p>
            <hr style="border-color:var(--neon-blue);margin:15px 0;">
            <div style="background:rgba(0,0,0,.3);padding:10px;border-radius:5px;margin-bottom:10px">
                <strong>Rekomendasi Prediksi:</strong><br>
                <span style="color:var(--neon-green);font-family:monospace;font-size:1.2em">${analysisData.recommendation || &apos;Berdasarkan pola historis&apos;}</span>
            </div>
            <p>Analisis lengkap telah selesai berdasarkan ${history.length} data history.</p>
        `;
        
        result.innerHTML = analysisHTML;
        
        drawFrequencyChart(positions, analysisData.frequencies);
    }, 2000);
}

function performAdvancedAnalysis(history, positions) {
    const result = {
        trends: {},
        transitions: {},
        dominantNumbers: {},
        frequencies: {},
        accuracy: {},
        recommendation: &apos;&apos;
    };
    
    positions.forEach((pos, index) => {
        const positionNumbers = history.map(item => parseInt(item.numbers[index]));
        const frequency = {};
        
        for (let i = 0; i <= 9; i++) {
            frequency[i] = positionNumbers.filter(num => num === i).length;
        }
        
        result.frequencies[pos] = frequency;
        
        const dominant = Object.entries(frequency)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(entry => entry[0])
            .join(&apos;, &apos;);
        
        result.dominantNumbers[pos] = dominant;
        
        const recentNumbers = positionNumbers.slice(-10);
        const avg = recentNumbers.reduce((a, b) => a + b, 0) / recentNumbers.length;
        result.trends[pos] = avg > 4.5 ? &apos;Naik&apos; : avg < 4.5 ? &apos;Turun&apos; : &apos;Stabil&apos;;
        
        result.accuracy[pos] = Math.round((Math.max(...Object.values(frequency)) / history.length) * 100) + &apos;%&apos;;
    });
    
    const recommendation = positions.map(pos => {
        const freq = result.frequencies[pos];
        const mostFrequent = Object.entries(freq)
            .sort((a, b) => b[1] - a[1])[0][0];
        return mostFrequent;
    }).join(&apos;&apos;);
    
    result.recommendation = recommendation;
    
    return result;
}

function drawFrequencyChart(positions, frequencies) {
    const chartCanvas = document.getElementById(&apos;frequencyChart&apos;);
    if(!chartCanvas) return;
    
    const ctx = chartCanvas.getContext(&apos;2d&apos;);
    chartCanvas.width = chartCanvas.parentElement.offsetWidth - 20;
    chartCanvas.height = 200;
    
    ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
    
    const colors = [&apos;#0f0&apos;, &apos;#0ff&apos;, &apos;#f0f&apos;, &apos;#ff0&apos;, &apos;#f00&apos;];
    const barWidth = chartCanvas.width / (positions.length * 12);
    const maxValue = Math.max(...positions.map(pos => 
        Math.max(...Object.values(frequencies[pos] || {}))
    )) || 100;
    
    positions.forEach((pos, posIndex) => {
        const color = colors[posIndex % colors.length];
        const freqData = frequencies[pos] || {};
        
        for(let digit = 0; digit < 10; digit++) {
            const value = freqData[digit] || 0;
            const barHeight = (value / maxValue) * (chartCanvas.height - 40);
            const x = posIndex * (chartCanvas.width / positions.length) + digit * barWidth + 10;
            const y = chartCanvas.height - barHeight - 20;
            
            ctx.fillStyle = color;
            ctx.fillRect(x, y, barWidth - 2, barHeight);
            
            if(posIndex === 0) {
                ctx.fillStyle = &apos;#0f0&apos;;
                ctx.font = &apos;10px monospace&apos;;
                ctx.fillText(digit, x, chartCanvas.height - 5);
            }
            
            if (value > 0) {
                ctx.fillStyle = &apos;#fff&apos;;
                ctx.font = &apos;8px monospace&apos;;
                ctx.fillText(value, x, y - 5);
            }
        }
        
        ctx.fillStyle = color;
        ctx.font = &apos;bold 12px monospace&apos;;
        ctx.fillText(`Posisi ${pos}`, posIndex * (chartCanvas.width / positions.length) + (chartCanvas.width / positions.length / 2) - 20, 15);
    });
    
    ctx.strokeStyle = &apos;#0f0&apos;;
    ctx.beginPath();
    ctx.moveTo(10, chartCanvas.height - 20);
    ctx.lineTo(chartCanvas.width - 10, chartCanvas.height - 20);
    ctx.stroke();
}

function createAnalysisCard(title) {
    const card = document.createElement(&apos;div&apos;);
    card.className = &apos;analysis-card&apos;;
    card.innerHTML = `<h4>${title}</h4>`;
    return card;
}

function getSelectedMethods() {
    const methods = [];
    if(document.getElementById(&apos;analSelisih&apos;).checked) methods.push(&apos;Pola Selisih&apos;);
    if(document.getElementById(&apos;analMarkov&apos;).checked) methods.push(&apos;Transisi Markov&apos;);
    if(document.getElementById(&apos;analCorrelation&apos;).checked) methods.push(&apos;Cross-Correlation&apos;);
    if(document.getElementById(&apos;analDominasi&apos;).checked) methods.push(&apos;Dominasi & Stabilitas&apos;);
    return methods.join(&apos;, &apos;);
}

function copyAnalysisResult() {
    const element = document.getElementById(&apos;analResult&apos;);
    const text = element.innerText;
    
    navigator.clipboard.writeText(text).then(() => {
        const btn = event.target;
        const originalText = btn.innerText;
        btn.innerText = &apos; Tersalin!&apos;;
        setTimeout(() => {
            btn.innerText = originalText;
        }, 2000);
    });
}

function clearAnalysis() {
    document.getElementById(&apos;analysisResults&apos;).innerHTML = `
        <div class="analysis-card">
            <h4> Pola Selisih & Arah</h4>
            <div class="position-result">
                <div class="position-title">Trend Utama</div>
                <div class="position-data">Menunggu analisis...</div>
            </div>
        </div>
        <div class="analysis-card">
            <h4> Transisi Markov</h4>
            <div class="position-result">
                <div class="position-title">Pola Transisi</div>
                <div class="position-data">Menunggu analisis...</div>
            </div>
        </div>
    `;
    
    document.getElementById(&apos;analResult&apos;).innerHTML = 
        &apos;<div style="text-align:center;color:var(--neon-yellow);padding:20px"> Hasil analisis akan ditampilkan di sini...</div>&apos;;
    
    const chartCanvas = document.getElementById(&apos;frequencyChart&apos;);
    if(chartCanvas) {
        const ctx = chartCanvas.getContext(&apos;2d&apos;);
        ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
    }
}

// ==================== JACKPOT ANIMATION ====================
function triggerJackpot() {
    const canvas = document.getElementById(&apos;jackpotCanvas&apos;);
    const overlay = document.getElementById(&apos;jackpotOverlay&apos;);
    const text = document.getElementById(&apos;jackpotText&apos;);
    
    canvas.style.display = &apos;block&apos;;
    overlay.style.display = &apos;block&apos;;
    
    const ctx = canvas.getContext(&apos;2d&apos;);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const particles = [];
    const colors = [&apos;#ff0000&apos;,&apos;#ffff00&apos;,&apos;#00ff00&apos;,&apos;#00ffff&apos;,&apos;#ff00ff&apos;];
    
    for(let i = 0; i < 200; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: Math.random() * 4 + 1,
            c: colors[Math.floor(Math.random() * colors.length)],
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4
        });
    }
    
    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fillStyle = p.c;
            ctx.fill();
            
            p.x += p.vx;
            p.y += p.vy;
            
            if(p.x < 0 || p.x > canvas.width) p.vx *= -1;
            if(p.y < 0 || p.y > canvas.height) p.vy *= -1;
        });
        
        requestAnimationFrame(animate);
    }
    
    animate();
    
    text.style.animation = &apos;textPulse 0.6s ease-in-out infinite&apos;;
    
    setTimeout(() => {
        canvas.style.display = &apos;none&apos;;
        overlay.style.display = &apos;none&apos;;
        text.style.animation = &apos;&apos;;
    }, 3000);
}

// ==================== BACKGROUND ANIMATION ====================
function initBgAnimation() {
    const bg = document.getElementById(&apos;bgAnimation&apos;);
    const chars = &apos;0123456789ABCDEF&apos;;
    const count = Math.floor(window.innerWidth * window.innerHeight / 4000);
    
    for(let i = 0; i < count; i++) {
        const el = document.createElement(&apos;div&apos;);
        el.className = &apos;falling-number&apos;;
        el.textContent = chars[Math.floor(Math.random() * chars.length)];
        el.style.left = Math.random() * 100 + &apos;vw&apos;;
        el.style.animationDuration = (Math.random() * 10 + 10) + &apos;s&apos;;
        el.style.animationDelay = Math.random() * 5 + &apos;s&apos;;
        el.classList.add(Math.random() > 0.5 ? &apos;small-number&apos; : &apos;medium-number&apos;);
        el.style.color = Math.random() > 0.7 ? &apos;var(--neon-purple)&apos; : (Math.random() > 0.5 ? &apos;var(--neon-green)&apos; : &apos;var(--neon-yellow)&apos;);
        bg.appendChild(el);
    }
}

// ==================== INITIALIZATION ====================
window.onload = function() {
    initBgAnimation();
    loadStoredDB();
    renderHistory();
    
    const today = new Date();
    const nextWeek = new Date();
    nextWeek.setDate(today.getDate() + 7);
    
    document.getElementById(&apos;startDate&apos;).valueAsDate = today;
    document.getElementById(&apos;endDate&apos;).valueAsDate = nextWeek;
    document.getElementById(&apos;accuracyDate&apos;).valueAsDate = today;
    document.getElementById(&apos;permDate&apos;).valueAsDate = today;
    
    const stored = localStorage.getItem(&apos;matrixDatabasis&apos;);
    if (stored) {
        try {
            databasisData = JSON.parse(stored);
            document.getElementById(&apos;databasisInfo&apos;).innerHTML = 
                `Status: <span style="color:var(--neon-green)">Databasis tersimpan (${Object.keys(databasisData).length} pools)</span>`;
        } catch (error) {
            console.error(&apos;Error loading stored databasis:&apos;, error);
        }
    }
    
    const pools = [&apos;TOK&apos;, &apos;PPL&apos;, &apos;CHI&apos;, &apos;SYD&apos;, &apos;HKG&apos;, &apos;SEO&apos;, &apos;T15&apos;, &apos;T21&apos;];
    pools.forEach(pool => {
        const savedData = localStorage.getItem(`analisis-history-${pool}`);
        if (savedData) {
            analisisHistoryData[pool] = JSON.parse(savedData);
        }
    });
};
</script>
<!-- Integrasi ANALYSIS V1.7 ke MATRIX PRO V1.0.HTML -->
<script>
/* ANALYSIS V1.7
   - Parse file .txt history upload (format dd/mm/yyyy,A,B,C,D or dd/mm/yyyy,A,B,C,D,E)
   - If uploaded file exists, use it as primary data source for analysis
   - Still fallback to localStorage/ATAR if no file uploaded
   - Adds UI feedback when a file is loaded
*/
(function(){
  const HISTORY_KEY=&apos;gpt_atar_history_v2_fix&apos;;
  const ALL_DATABASES_KEY=&apos;gpt_atar_all_databases_v2_fix&apos;;
  const DEFAULT_DAYS=30;
  const MARKOV_MIN = 5;
  const CORR_MIN = 7;

  // Global container for uploaded history file (array of {date: ISO, result: &apos;1234&apos; or &apos;12345&apos;})
  window.uploadedHistoryData = null;
  window.uploadedHistoryFilename = null;

  function parseDateDMY(s){
    const parts = s.split(&apos;/&apos;);
    if(parts.length < 3) return null;
    let d = parseInt(parts[0],10);
    let m = parseInt(parts[1],10);
    let y = parseInt(parts[2],10);
    if(y < 100) { y += 2000; }
    if(Number.isNaN(d) || Number.isNaN(m) || Number.isNaN(y)) return null;
    const dt = new Date(y, m-1, d);
    if(isNaN(dt.getTime())) return null;
    return dt.toISOString();
  }

  function normalizeResultString(s){
    if(!s) return &apos;&apos;;
    return String(s).replace(/\D/g,&apos;&apos;);
  }

  function parseHistoryTxtContent(text){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l && !l.startsWith(&apos;#&apos;));
    const out = [];
    for(const line of lines){
      const parts = line.split(/[,;\t]+/).map(p=>p.trim()).filter(p=>p!==&apos;&apos;);
      if(parts.length < 2) continue;
      const dateIso = parseDateDMY(parts[0]);
      if(!dateIso) continue;
      const digits = parts.slice(1).join(&apos;&apos;);
      const normalized = normalizeResultString(digits);
      if(normalized.length === 4 || normalized.length === 5){
        out.push({ date: dateIso, result: normalized });
      } else {
        const candidate = parts.slice(1).map(x=>normalizeResultString(x)).join(&apos;&apos;);
        if(candidate.length === 4 || candidate.length === 5){
          out.push({ date: dateIso, result: candidate });
        }
      }
    }
    out.sort((a,b)=> new Date(a.date) - new Date(b.date));
    return out;
  }

  function attachHistoryFileHandler(){
    const fileInput = document.getElementById(&apos;historyFile&apos;);
    if(!fileInput) return;
    fileInput.addEventListener(&apos;change&apos;, function(ev){
      const f = fileInput.files && fileInput.files[0];
      if(!f) return;
      const reader = new FileReader();
      reader.onload = function(e){
        try{
          const txt = String(e.target.result || &apos;&apos;);
          const parsed = parseHistoryTxtContent(txt);
          if(parsed.length === 0){
            alert(&apos;File terupload namun tidak ada baris valid ditemukan. Pastikan format: dd/mm/yyyy,A,B,C,D (4D) atau dd/mm/yyyy,A,B,C,D,E (5D).&apos;);
            window.uploadedHistoryData = null;
            window.uploadedHistoryFilename = null;
            updateAnalInfo(&apos;Tidak ada data terdeteksi dari file.&apos;);
            return;
          }
          window.uploadedHistoryData = parsed;
          window.uploadedHistoryFilename = f.name;
          updateAnalInfo(`File terupload: ${f.name}  ${parsed.length} rekam terbaca.`);
          console.log(&apos;Uploaded history parsed (first 5):&apos;, parsed.slice(0,5));
        }catch(err){
          console.error(&apos;Gagal parsing file history&apos;, err);
          alert(&apos;Gagal mem-parsing file history. Lihat console untuk detail.&apos;);
          window.uploadedHistoryData = null;
          window.uploadedHistoryFilename = null;
          updateAnalInfo(&apos;Gagal parsing file.&apos;);
        }
      };
      reader.onerror = function(){ alert(&apos;Gagal membaca file.&apos;); };
      reader.readAsText(f);
    });
  }

  function updateAnalInfo(msg){
    const info = document.getElementById(&apos;historyInfo&apos;);
    if(info) info.innerHTML = msg;
  }

  function loadHistoryForPool(pool, days){
    const raw = localStorage.getItem(HISTORY_KEY) || &apos;[]&apos;;
    let arr = [];
    try{ arr = JSON.parse(raw); }catch(e){ arr = []; }
    const since = new Date(); since.setDate(since.getDate() - days);
    return arr.filter(it => String(it.pool) === String(pool) && it.date && new Date(it.date) >= since)
              .sort((a,b)=> new Date(a.date) - new Date(b.date));
  }

  function loadAtarDB(){ const all = localStorage.getItem(ALL_DATABASES_KEY) || &apos;{}&apos;; try{return JSON.parse(all);}catch(e){return {}; } }

  function initPositionCounters(includeE=false){
    const positions=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]; if(includeE) positions.push(&apos;E&apos;);
    const out = {}; positions.forEach(p=> out[p]=Array.from({length:10},()=>0)); return out;
  }
  function incrementCounter(counters,pos,digit){ const n = parseInt(digit,10); if(Number.isFinite(n) && n>=0 && n<=9) counters[pos][n]++; }
  function computeFrequencyFromHistoryObjArr(historyArr, includeE=false){
    const counters = initPositionCounters(includeE);
    historyArr.forEach(item=>{
      const s = normalizeResultString(item.result || &apos;&apos;);
      if(!s) return;
      for(let i=0;i<Math.min(s.length, Object.keys(counters).length); i++){
        const pos = Object.keys(counters)[i];
        incrementCounter(counters,pos,s[i]);
      }
    });
    return counters;
  }
  function computeFrequencyFromAtarDB(pool, includeE=false){
    const all = loadAtarDB();
    if(!all || !all[pool]) return initPositionCounters(includeE);
    const poolData = all[pool];
    const counters = initPositionCounters(includeE);
    Object.keys(poolData).forEach(k=>{
      if(k === &apos;_timestamp&apos;) return;
      const dayObj = poolData[k];
      [&apos;ATAR1&apos;,&apos;ATAR2&apos;,&apos;ATAR3&apos;].forEach(atarKey=>{
        const sets = dayObj[atarKey] || {};
        Object.keys(sets).forEach(pos=>{
          (sets[pos]||[]).forEach(num=>{
            const s = String(num).replace(/\\D/g,&apos;&apos;);
            if(s.length===1) incrementCounter(counters,pos,s);
            else s.split(&apos;&apos;).forEach(d=>{ if(d.match(/^[0-9]$/)) incrementCounter(counters,pos,d); });
          });
        });
      });
    });
    return counters;
  }

  function topNFromCounters(counters,n=7){
    const ret = {};
    Object.keys(counters).forEach(pos=>{
      const arr = counters[pos].map((cnt,d)=>({digit:d,count:cnt}));
      arr.sort((a,b)=> b.count - a.count || a.digit - b.digit);
      ret[pos] = arr.slice(0,n);
    });
    return ret;
  }

  function computeMarkovFromSequence(seq, includeE=false){
    const positions = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]; if(includeE) positions.push(&apos;E&apos;);
    const matrices = {}; positions.forEach(p=> matrices[p] = Array.from({length:10}, ()=>Array.from({length:10}, ()=>0)));
    for(let i=0;i<seq.length-1;i++){
      const cur = seq[i], nxt = seq[i+1];
      if(!cur || !nxt) continue;
      for(let j=0;j<positions.length;j++){
        const a = parseInt(cur[j],10), b = parseInt(nxt[j],10);
        if(Number.isInteger(a) && Number.isInteger(b) && a>=0 && a<=9 && b>=0 && b<=9){
          matrices[positions[j]][a][b]++;
        }
      }
    }
    const probs = {};
    positions.forEach(p=>{
      probs[p] = matrices[p].map(row=>{
        const s = row.reduce((x,y)=>x+y,0);
        if(s===0) return row.map(()=>0);
        return row.map(v=>v/s);
      });
    });
    return probs;
  }

  function computeMarkovFromHistoryArr(historyArr, includeE=false){
    const seq = historyArr.map(it=> normalizeResultString(it.result || &apos;&apos;)).filter(s=>s.length>0);
    return computeMarkovFromSequence(seq, includeE);
  }

  function computeMarkovFromAtar(pool, includeE=false){
    const all = loadAtarDB();
    if(!all || !all[pool]) return computeMarkovFromSequence([], includeE);
    const seq = [];
    Object.keys(all[pool]).forEach(k=>{
      if(k === &apos;_timestamp&apos;) return;
      const dayObj = all[pool][k];
      [&apos;ATAR1&apos;,&apos;ATAR2&apos;,&apos;ATAR3&apos;].forEach(atarKey=>{
        const sets = dayObj[atarKey] || {};
        const positions = includeE? [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;] : [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;];
        const digits = positions.map(pos=>{
          const arr = sets[pos] || [];
          if(arr.length===0) return &apos;&apos;;
          const v = String(arr[0]).replace(/\\D/g,&apos;&apos;);
          return v.length? v[0] : &apos;&apos;;
        }).join(&apos;&apos;);
        if(digits.length >= (includeE?5:4)) seq.push(digits);
      });
    });
    return computeMarkovFromSequence(seq, includeE);
  }

  function computeCorrelationFromHistoryArr(historyArr, includeE=false){
    const positions = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]; if(includeE) positions.push(&apos;E&apos;);
    const series = {}; positions.forEach(p=> series[p]=[]);
    historyArr.forEach(item=>{
      const s = normalizeResultString(item.result || &apos;&apos;);
      for(let i=0;i<positions.length;i++){
        const d = s[i];
        const v = (d && d.match(/^[0-9]$/)) ? parseInt(d,10) : NaN;
        series[positions[i]].push(Number.isFinite(v)?v:NaN);
      }
    });
    function pearson(x,y){
      if(!x||!y||x.length!==y.length) return NaN;
      let n=0,sx=0,sy=0,sxx=0,syy=0,sxy=0;
      for(let i=0;i<x.length;i++){
        const xi=x[i], yi=y[i];
        if(isNaN(xi) || isNaN(yi)) continue;
        n++; sx+=xi; sy+=yi; sxx+=xi*xi; syy+=yi*yi; sxy+=xi*yi;
      }
      if(n<=1) return NaN;
      const num = sxy - (sx*sy)/n;
      const den = Math.sqrt((sxx - (sx*sx)/n) * (syy - (sy*sy)/n));
      if(den === 0) return NaN;
      return num/den;
    }
    const corr = {};
    for(let i=0;i<positions.length;i++){
      for(let j=i+1;j<positions.length;j++){
        const k = `${positions[i]}_${positions[j]}`;
        corr[k] = pearson(series[positions[i]], series[positions[j]]);
      }
    }
    return corr;
  }

  // Rendering helpers
  function renderTopNumbers(topObj, sourceLabel){
    const container = document.getElementById(&apos;analysisResults&apos;);
    if(!container) return;
    let html = `<div style="padding:6px;color:var(--neon-blue)"><strong>Sumber data:</strong> ${sourceLabel}</div>`;
    Object.keys(topObj).forEach(pos=>{
      const arr = topObj[pos];
      const items = arr.map(it=>`${it.digit}(${it.count})`).join(&apos;, &apos;);
      html += `<div class="position-result"><div class="position-title">Posisi ${pos}</div><div class="position-data">Top: ${items}</div></div>`;
    });
    const firstCard = container.querySelector(&apos;.analysis-card&apos;);
    if(firstCard) firstCard.innerHTML = `<h4> Pola Selisih & Arah</h4>${html}`;
  }

  function renderMarkovSummary(markov, historyLength, usingAtar=false){
    const container = document.getElementById(&apos;analysisResults&apos;);
    if(!container) return;
    let html = &apos;<h4> Transisi Markov (ringkasan paling mungkin)</h4>&apos;;
    if(!usingAtar && historyLength < MARKOV_MIN){
      html += `<div style="padding:8px;color:var(--neon-yellow)">Tidak cukup data history (min ${MARKOV_MIN} rekam) untuk menghitung Markov dari history. Menggunakan ATAR sebagai estimasi.</div>`;
    }
    Object.keys(markov).forEach(pos=>{
      const mat = markov[pos];
      const lines = [];
      for(let d=0; d<10; d++){
        const row = mat[d];
        const max = Math.max(...row);
        if(max <= 0) continue;
        const idxs = [];
        row.forEach((v,idx)=>{ if(v>0 && Math.abs(v-max) < 1e-9) idxs.push(idx); });
        lines.push(`${d}  ${idxs.join(&apos;,&apos;)} (${(max*100).toFixed(1)}%)`);
      }
      html += `<div class="position-result"><div class="position-title">Posisi ${pos}</div><div class="position-data">${lines.slice(0,8).join(&apos;  &apos;) || &apos;&apos;}</div></div>`;
    });
    const cards = container.querySelectorAll(&apos;.analysis-card&apos;);
    if(cards[1]) cards[1].innerHTML = html;
    else container.insertAdjacentHTML(&apos;beforeend&apos;, `<div class="analysis-card">${html}</div>`);
  }

  let currentChart = null;
  function ensureChartJs(cb){ if(window.Chart) return cb(); const s=document.createElement(&apos;script&apos;); s.src=&apos;https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js&apos;; s.onload=cb; s.onerror=()=>{ console.warn(&apos;Gagal memuat Chart.js&apos;); cb(); }; document.head.appendChild(s); }
  function renderFrequencyChart(counters, sourceLabel){
    ensureChartJs(()=>{ const ctx = document.getElementById(&apos;frequencyChart&apos;); if(!ctx) return; const positions = Object.keys(counters); const labels = Array.from({length:10}, (_,i)=>String(i)); const datasets = positions.map((pos,idx)=>({ label:`Posisi ${pos}`, data:counters[pos], barThickness:8 })); if(currentChart){ try{ currentChart.destroy(); }catch(e){} } currentChart = new Chart(ctx.getContext(&apos;2d&apos;), { type:&apos;bar&apos;, data:{ labels, datasets }, options:{ responsive:true, maintainAspectRatio:false, scales:{ x:{ stacked:false }, y:{ beginAtZero:true } }, plugins:{ legend:{ position:&apos;top&apos; }, title:{ display:true, text: &apos;Frekuensi Angka per Posisi (&apos; + sourceLabel + &apos;)&apos; } } } }); });
  }

  function renderCorrelation(corrObj, historyLength, usingAtar=false){
    const el = document.getElementById(&apos;analResult&apos;);
    if(!el) return;
    const lines = [&apos;<div style="padding:8px"><strong> Korelasi Antar Posisi (Pearson) </strong></div>&apos;];
    if(!usingAtar && historyLength < CORR_MIN){
      lines.push(`<div style="padding:6px 10px;color:var(--neon-yellow)">Tidak cukup data history (min ${CORR_MIN} rekam) untuk korelasi. Menggunakan ATAR sebagai estimasi.</div>`);
    }
    Object.keys(corrObj).forEach(k=>{
      const v = corrObj[k];
      const disp = (v===null||v===undefined||isNaN(v)) ? &apos;n/a&apos; : v.toFixed(3);
      lines.push(`<div style="padding:6px 10px">${k.replace(&apos;_&apos;,&apos;  &apos;)}: ${disp}</div>`);
    });
    el.innerHTML = lines.join(&apos;\\n&apos;);
  }

  // Main runner
  window.runAnalysis = function(){
    try{
      const pool = document.getElementById(&apos;analPoolSelect&apos;).value;
      const daysInput = parseInt(document.getElementById(&apos;analDays&apos;).value,10) || DEFAULT_DAYS;
      const includeE = (pool === &apos;T15&apos; || pool === &apos;T21&apos;);
      if(!pool){ alert(&apos;Pilih Pool untuk analisis&apos;); return; }
      const loading = document.getElementById(&apos;analLoading&apos;); if(loading) loading.style.display = &apos;block&apos;;
      setTimeout(()=>{
        // Primary source: uploadedHistoryData if available
        let historyArr = null;
        let sourceLabel = &apos;&apos;;
        if(window.uploadedHistoryData && Array.isArray(window.uploadedHistoryData) && window.uploadedHistoryData.length>0){
          historyArr = window.uploadedHistoryData;
          sourceLabel = `File Upload: ${window.uploadedHistoryFilename || &apos;uploaded&apos;}`;
        } else {
          // fallback to localStorage history for the selected pool
          const hist = loadHistoryForPool(pool, daysInput);
          if(hist && hist.length>0){
            historyArr = hist.map(h => ({ date: h.date, result: String(h.result || h.resultString || &apos;&apos;) }));
            sourceLabel = &apos;History (localStorage)&apos;;
          } else {
            // final fallback: use ATAR DB
            historyArr = null;
            sourceLabel = &apos;Database ATAR (estimasi)&apos;;
          }
        }

        let counters;
        if(historyArr){
          counters = computeFrequencyFromHistoryObjArr(historyArr, includeE);
        } else {
          counters = computeFrequencyFromAtarDB(pool, includeE);
        }

        const top7 = topNFromCounters(counters,7);
        renderTopNumbers(top7, sourceLabel);

        // Markov
        let markov, usingAtarForMarkov=false;
        if(historyArr && historyArr.length >= MARKOV_MIN){
          markov = computeMarkovFromHistoryArr(historyArr, includeE);
        } else {
          markov = computeMarkovFromAtar(pool, includeE);
          usingAtarForMarkov = true;
        }
        renderMarkovSummary(markov, historyArr ? historyArr.length : 0, usingAtarForMarkov);

        // Correlation
        let corr, usingAtarForCorr=false;
        if(historyArr && historyArr.length >= CORR_MIN){
          corr = computeCorrelationFromHistoryArr(historyArr, includeE);
        } else {
          usingAtarForCorr = true;
          const all = loadAtarDB();
          const pseudo = [];
          if(all && all[pool]){
            Object.keys(all[pool]).forEach(k=>{
              if(k === &apos;_timestamp&apos;) return;
              const dayObj = all[pool][k];
              [&apos;ATAR1&apos;,&apos;ATAR2&apos;,&apos;ATAR3&apos;].forEach(atarKey=>{
                const sets = dayObj[atarKey] || {};
                const positions = includeE? [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;] : [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;];
                const
<!-- ANALYSIS V2.0 - Fusion Engine + Adaptive Markov Transition -->
<script>
/* ANALYSIS V2.0
   Features:
   - Fusion Engine: combine user history + ATAR DB into fused probability per position
   - Adaptive Markov Transition: combine first-order Markov + delta-direction layer
   - Predict top-N digits per position with confidence score
   - Public function: runAnalysisV2(options)
     Options (object, optional):
       { pool, days, wHistory, wAtar, alphaMarkovDelta, topN }
     Defaults: wHistory=0.7, wAtar=0.3, alphaMarkovDelta=0.6, topN=3
*/
(function(){
  // --- Defaults & Helpers ---
  const DEFAULTS = { wHistory:0.7, wAtar:0.3, alphaMarkovDelta:0.6, topN:3, days:30 };
  function ensureChartJs(cb){ if(window.Chart) return cb(); const s=document.createElement(&apos;script&apos;); s.src=&apos;https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js&apos;; s.onload=cb; s.onerror=()=>{ console.warn(&apos;Gagal memuat Chart.js&apos;); cb(); }; document.head.appendChild(s); }
  function normalizeResultString(s){ if(!s) return &apos;&apos;; return String(s).replace(/\D/g,&apos;&apos;); }
  function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
  function sum(arr){ return arr.reduce((a,b)=>a+b,0); }

  // --- load helpers (use existing keys) ---
  const HISTORY_KEY=&apos;gpt_atar_history_v2_fix&apos;;
  const ALL_DATABASES_KEY=&apos;gpt_atar_all_databases_v2_fix&apos;;
  function loadHistoryForPool(pool, days){
    const raw = localStorage.getItem(HISTORY_KEY) || &apos;[]&apos;;
    let arr = [];
    try{ arr = JSON.parse(raw); } catch(e){ arr = []; }
    const since = new Date(); since.setDate(since.getDate() - days);
    return arr.filter(it => String(it.pool) === String(pool) && it.date && new Date(it.date) >= since)
              .sort((a,b)=> new Date(a.date) - new Date(b.date));
  }
  function loadAtarDB(){ const all = localStorage.getItem(ALL_DATABASES_KEY) || &apos;{}&apos;; try{return JSON.parse(all);}catch(e){return {}; } }

  // --- Frequency counters (positions A..E) ---
  function initPositionCounters(includeE=false){
    const positions=[&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]; if(includeE) positions.push(&apos;E&apos;);
    const out={}; positions.forEach(p=> out[p]=Array.from({length:10},()=>0)); return out;
  }
  function incrementCounter(counters,pos,digit){ const n = parseInt(digit,10); if(Number.isFinite(n) && n>=0 && n<=9) counters[pos][n]++; }

  // compute frequency/probability from history array (array of {date,result})
  function freqFromHistoryArr(historyArr, includeE=false){
    const counters = initPositionCounters(includeE);
    historyArr.forEach(item=>{
      const s = normalizeResultString(item.result || &apos;&apos;);
      if(!s) return;
      for(let i=0;i<Math.min(s.length, Object.keys(counters).length); i++){
        const pos = Object.keys(counters)[i];
        incrementCounter(counters,pos,s[i]);
      }
    });
    // convert counts -> probabilities
    const probs = {};
    Object.keys(counters).forEach(pos=>{
      const c = counters[pos];
      const total = sum(c) || 1;
      probs[pos] = c.map(v=> v / total);
    });
    return {counts:counters, probs};
  }

  // compute frequency/prob from ATAR DB
  function freqFromAtar(pool, includeE=false){
    const all = loadAtarDB();
    if(!all || !all[pool]) {
      const zeros = initPositionCounters(includeE);
      const probs = {}; Object.keys(zeros).forEach(p=> probs[p] = zeros[p].map(_=>0));
      return {counts:zeros, probs};
    }
    const poolData = all[pool];
    const counters = initPositionCounters(includeE);
    Object.keys(poolData).forEach(k=>{
      if(k === &apos;_timestamp&apos;) return;
      const dayObj = poolData[k];
      [&apos;ATAR1&apos;,&apos;ATAR2&apos;,&apos;ATAR3&apos;].forEach(atarKey=>{
        const sets = dayObj[atarKey] || {};
        Object.keys(sets).forEach(pos=>{
          (sets[pos]||[]).forEach(num=>{
            const s = String(num).replace(/\D/g,&apos;&apos;);
            if(s.length===1) incrementCounter(counters,pos,s);
            else s.split(&apos;&apos;).forEach(d=>{ if(d.match(/^[0-9]$/)) incrementCounter(counters,pos,d); });
          });
        });
      });
    });
    const probs = {};
    Object.keys(counters).forEach(pos=>{
      const total = sum(counters[pos]) || 1;
      probs[pos] = counters[pos].map(v=> v / total);
    });
    return {counts:counters, probs};
  }

  // --- Fusion Engine: combine prob distributions ---
  function fuseProbs(probsHist, probsAtar, wHist=0.7, wAtar=0.3){
    const fused = {};
    Object.keys(probsAtar).forEach(pos=>{
      const ph = probsHist[pos] || Array.from({length:10},()=>0);
      const pa = probsAtar[pos] || Array.from({length:10},()=>0);
      fused[pos] = ph.map((v,i)=> (wHist * v) + (wAtar * pa[i]));
      // normalize to sum 1 (safety)
      const s = sum(fused[pos]) || 1;
      fused[pos] = fused[pos].map(v=> v / s);
    });
    return fused;
  }

  // --- Markov first-order probabilities from sequence of results ---
  // returns {pos: matrix[10][10]} of probabilities P(next = j | cur = i)
  function markovFromSeq(seq, includeE=false){
    const positions = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]; if(includeE) positions.push(&apos;E&apos;);
    const matrices = {}; positions.forEach(p=> matrices[p] = Array.from({length:10}, ()=>Array.from({length:10}, ()=>0)));
    for(let i=0;i<seq.length-1;i++){
      const cur = seq[i], nxt = seq[i+1];
      if(!cur || !nxt) continue;
      for(let j=0;j<positions.length;j++){
        const a = parseInt(cur[j],10), b = parseInt(nxt[j],10);
        if(!Number.isNaN(a) && !Number.isNaN(b) && a>=0 && a<=9 && b>=0 && b<=9){
          matrices[positions[j]][a][b] += 1;
        }
      }
    }
    // normalize rows to probabilities
    const probs = {};
    positions.forEach(p=>{
      probs[p] = matrices[p].map(row=>{
        const s = sum(row) || 0;
        return s === 0 ? row.map(()=>0) : row.map(v=> v / s);
      });
    });
    return probs;
  }

  // --- Delta (direction) model: distribution of differences (next - current) mod 10)
  // We&apos;ll compute P(delta = d) for d in 0..9 meaning shift by d (0=no change, 1=+1 mod10, ...).
  function deltaDistributionFromSeq(seq, includeE=false){
    const positions = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]; if(includeE) positions.push(&apos;E&apos;);
    const deltaDist = {}; positions.forEach(p=> deltaDist[p] = Array.from({length:10}, ()=>0));
    for(let i=0;i<seq.length-1;i++){
      const cur = seq[i], nxt = seq[i+1];
      if(!cur || !nxt) continue;
      for(let j=0;j<positions.length;j++){
        const a = parseInt(cur[j],10), b = parseInt(nxt[j],10);
        if(!Number.isNaN(a) && !Number.isNaN(b) && a>=0 && a<=9 && b>=0 && b<=9){
          const d = ( (b - a) + 10 ) % 10; // 0..9
          deltaDist[positions[j]][d] += 1;
        }
      }
    }
    // normalize per position
    Object.keys(deltaDist).forEach(p=>{
      const s = sum(deltaDist[p]) || 1;
      deltaDist[p] = deltaDist[p].map(v=> v / s);
    });
    return deltaDist; // P(delta=d)
  }

  // --- Adaptive Markov: combine markov_probs and delta-based shift probabilities ---
  // For each position and for each current digit a, we produce combined P(next=b | cur=a)
  // where combined = alpha * markov[a][b] + (1-alpha) * delta_shifts_mapped_to_digits
  function adaptiveMarkov(markovProbs, deltaDist, alpha=0.6){
    const out = {};
    Object.keys(markovProbs).forEach(pos=>{
      const mat = markovProbs[pos]; // 10x10
      const deltas = deltaDist[pos] || Array.from({length:10},()=>0); // length 10 (shift probs)
      // for each current digit a, build distribution over b
      out[pos] = Array.from({length:10}, (_,a)=> {
        const markovRow = mat[a] || Array.from({length:10}, ()=>0);
        const deltaBased = Array.from({length:10}, (_,b)=> {
          // To get P(next=b | cur=a) from deltaDist: probability of delta d where b == (a + d) mod10
          const d = ( (b - a) + 10 ) % 10;
          return deltas[d] || 0;
        });
        // combine
        const combined = markovRow.map((mv,idx)=> alpha * mv + (1 - alpha) * deltaBased[idx]);
        // normalize
        const s = sum(combined) || 1;
        return combined.map(v=> v / s);
      });
    });
    return out;
  }

  // --- Predict top-N per position from fused probs and adaptive markov ---
  // Approach:
  // 1) Use fused marginal probs per position as baseline P(d).
  // 2) Use adaptiveMarkov to compute for each current digit a -> distribution of next digits.
  // 3) If history has a most recent result, use that as current state to compute a Markov-informed next-digit distribution.
  // 4) Combine baseline fused probs and markov-informed next-probs into final score.
  function predictTopN(fusedProbs, adaptiveMarkovProbs, lastResultStr, topN=3, betaMarkov=0.6){
    // betaMarkov: weight for Markov-informed next-probs vs fused marginal
    const positions = Object.keys(fusedProbs);
    const prediction = {};
    const confidencePerPosition = {};
    positions.forEach(pos=>{
      const baseline = fusedProbs[pos]; // array length 10
      let markovNext = Array.from({length:10}, ()=>0);
      if(lastResultStr && lastResultStr.length >= 1){
        // determine current digit for this position based on index of pos
        const posIndex = positions.indexOf(pos);
        const curDigitChar = lastResultStr[posIndex];
        if(curDigitChar !== undefined && curDigitChar.match(/^[0-9]$/)){
          const a = parseInt(curDigitChar,10);
          const row = (adaptiveMarkovProbs && adaptiveMarkovProbs[pos] && adaptiveMarkovProbs[pos][a]) || Array.from({length:10},()=>0);
          markovNext = row;
        }
      }
      // combine baseline and markovNext
      const finalScores = baseline.map((b,i)=> ( (1 - betaMarkov) * b ) + ( betaMarkov * markovNext[i] ));
      // sort topN
      const arr = finalScores.map((v,i)=>({digit:i,score:v}));
      arr.sort((x,y)=> y.score - x.score || x.digit - y.digit);
      prediction[pos] = arr.slice(0, topN).map(it=> ({digit:it.digit, score: it.score}) );
      // confidence as sum of topN scores (rough)
      confidencePerPosition[pos] = arr.slice(0, topN).reduce((a,b)=>a+b.score,0);
    });
    return {prediction, confidencePerPosition};
  }

  // --- Rendering utilities (re-use elements if exist) ---
  function renderPredictions(predObj, confidences){
    const el = document.getElementById(&apos;predictionsContainer&apos;) || document.getElementById(&apos;analysisResults&apos;);
    if(!el) return;
    let html = &apos;<div style="padding:8px"><h4> Prediksi Pola Dominan (V2.0)</h4></div>&apos;;
    Object.keys(predObj).forEach(pos=>{
      const items = predObj[pos].map(it=> `${it.digit} (${(it.score*100).toFixed(1)}%)`).join(&apos;  &apos;);
      const conf = (confidences[pos]||0);
      html += `<div style="padding:6px 10px"><strong>Posisi ${pos}</strong>: ${items} <span style="color:var(--neon-yellow)">| Confidence: ${(conf*100).toFixed(1)}%</span></div>`;
    });
    // append or replace a pred section (keep below main analysis)
    const existing = document.getElementById(&apos;predSectionV2&apos;);
    if(existing) existing.innerHTML = html;
    else el.insertAdjacentHTML(&apos;beforeend&apos;, `<div id="predSectionV2" class="analysis-card">${html}</div>`);
  }

  // --- Render fused distribution chart (reuse frequencyChart canvas if present) ---
  let currentChartV2 = null;
  function renderFusedChart(fusedProbs, sourceLabel){
    ensureChartJs(()=>{
      const ctx = document.getElementById(&apos;frequencyChart&apos;);
      if(!ctx) return;
      const positions = Object.keys(fusedProbs);
      const labels = Array.from({length:10}, (_,i)=>String(i));
      const datasets = positions.map((pos,idx)=>({ label:`Posisi ${pos}`, data: fusedProbs[pos], barThickness:8 }));
      if(currentChartV2){ try{ currentChartV2.destroy(); }catch(e){} }
      currentChartV2 = new Chart(ctx.getContext(&apos;2d&apos;), {
        type: &apos;bar&apos;,
        data: { labels, datasets },
        options: { responsive:true, maintainAspectRatio:false, scales:{ x:{ stacked:false }, y:{ beginAtZero:true } }, plugins:{ legend:{ position:&apos;top&apos; }, title:{ display:true, text: &apos;Frekuensi (Fused) per Posisi (&apos; + sourceLabel + &apos;)&apos; } } }
      });
    });
  }

  // --- High-level runner exposed publicly ---
  // options: { pool, days, wHistory, wAtar, alphaMarkovDelta, topN, betaMarkov }
  window.runAnalysisV2 = function(options = {}){
    try{
      const pool = options.pool || (document.getElementById(&apos;analPoolSelect&apos;) && document.getElementById(&apos;analPoolSelect&apos;).value) || &apos;&apos;;
      const days = options.days || (document.getElementById(&apos;analDays&apos;) && parseInt(document.getElementById(&apos;analDays&apos;).value,10)) || DEFAULTS.days;
      const wHist = (typeof options.wHistory === &apos;number&apos;)? options.wHistory : DEFAULTS.wHistory;
      const wAtar = (typeof options.wAtar === &apos;number&apos;)? options.wAtar : DEFAULTS.wAtar;
      const alpha = (typeof options.alphaMarkovDelta === &apos;number&apos;)? options.alphaMarkovDelta : DEFAULTS.alphaMarkovDelta;
      const topN = options.topN || DEFAULTS.topN;
      const betaMarkov = (typeof options.betaMarkov === &apos;number&apos;)? options.betaMarkov : 0.6;

      if(!pool){ alert(&apos;Pilih Pool sebelum menjalankan ANALYSIS V2.0&apos;); return; }
      // show loading if exists
      const loading = document.getElementById(&apos;analLoading&apos;); if(loading) loading.style.display = &apos;block&apos;;

      // 1) detect uploadedHistoryData if present (from V1.7 feature) else use localStorage history, else ATAR
      const uploaded = window.uploadedHistoryData && Array.isArray(window.uploadedHistoryData) && window.uploadedHistoryData.length>0 ? window.uploadedHistoryData : null;
      let historyArr = null;
      if(uploaded) historyArr = uploaded;
      else {
        const localHist = loadHistoryForPool(pool, days);
        if(localHist && localHist.length>0) historyArr = localHist.map(h=> ({ date: h.date, result: String(h.result || h.resultString || &apos;&apos;) }));
      }
      const includeE = (pool === &apos;T15&apos; || pool === &apos;T21&apos;);

      // 2) prepare marginals
      let probsHist = {};
      if(historyArr && historyArr.length>0){
        probsHist = freqFromHistoryArr(historyArr, includeE).probs;
      } else {
        // zero hist
        const zeros = initPositionCounters(includeE);
        Object.keys(zeros).forEach(p=> zeros[p] = zeros[p].map(_=>0));
        probsHist = zeros;
      }
      const atar = freqFromAtar(pool, includeE);
      const probsAtar = atar.probs;

      // 3) fused marginals
      const fused = fuseProbs(probsHist, probsAtar, wHist, wAtar);

      // 4) Markov & delta models - prefer history sequence if available, else try ATAR-derived pseudo-sequence
      let seq = [];
      if(historyArr && historyArr.length>0){
        seq = historyArr.map(it=> normalizeResultString(it.result || &apos;&apos;)).filter(s=>s.length>0);
      } else {
        // build pseudo-sequence from atar DB (take one representative per day/ATAR entry)
        const all = loadAtarDB();
        if(all && all[pool]){
          Object.keys(all[pool]).forEach(k=>{
            if(k === &apos;_timestamp&apos;) return;
            const dayObj = all[pool][k];
            [&apos;ATAR1&apos;,&apos;ATAR2&apos;,&apos;ATAR3&apos;].forEach(atarKey=>{
              const sets = dayObj[atarKey] || {};
              const positions = includeE? [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;] : [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;];
              const digits = positions.map(pos=>{
                const arr = sets[pos] || [];
                if(arr.length===0) return &apos;&apos;;
                const v = String(arr[0]).replace(/\D/g,&apos;&apos;);
                return v.length? v[0] : &apos;&apos;;
              }).join(&apos;&apos;);
              if(digits.length >= (includeE?5:4)) seq.push(digits);
            });
          });
        }
      }

      const mk = markovFromSeq(seq, includeE);
      const deltas = deltaDistributionFromSeq(seq, includeE);
      const adaptive = adaptiveMarkov(mk, deltas, alpha);

      // 5) Prediction: use last available result if history exists, else try last of pseudo seq, else use fused only
      const lastResultStr = (historyArr && historyArr.length>0) ? normalizeResultString(historyArr[historyArr.length-1].result || &apos;&apos;) : (seq.length>0? seq[seq.length-1] : null);
      const pred = predictTopN(fused, adaptive, lastResultStr, topN, betaMarkov);

      // 6) render outputs: fused chart, predictions, markov summary
      renderFusedChart(fused, (uploaded? `File Upload: ${window.uploadedHistoryFilename || &apos;uploaded&apos;}` : (historyArr? &apos;History (localStorage)&apos; : &apos;Database ATAR (estimasi)&apos;)));
      renderPredictions(pred.prediction, pred.confidencePerPosition);

      // markov summary (reuse previous function idea)
      // Build a short summary of adaptive markov: for each pos, for current digit show top next digits
      const markovSummary = {};
      Object.keys(adaptive).forEach(pos=>{
        markovSummary[pos] = [];
        for(let a=0;a<10;a++){
          const row = adaptive[pos][a];
          const max = Math.max(...row);
          if(max <= 0) continue;
          const best = row.map((v,i)=>({i,v})).sort((x,y)=> y.v - x.v).slice(0,3).map(x=> `${x.i}(${(x.v*100).toFixed(1)}%)`);
          markovSummary[pos].push(`${a}${best.join(&apos;,&apos;)}`);
        }
      });
      // render markov summary
      const cards = document.getElementById(&apos;analysisResults&apos;);
      if(cards){
        const html = [&apos;<h4> Adaptive Markov (ringkasan)</h4>&apos;];
        Object.keys(markovSummary).forEach(p=>{
          html.push(`<div style="padding:6px 10px"><strong>Posisi ${p}</strong>: ${markovSummary[p].slice(0,8).join(&apos;  &apos;) || &apos;&apos;}</div>`);
        });
        // place in 2nd card or append
        const existingCards = cards.querySelectorAll(&apos;.analysis-card&apos;);
        if(existingCards[1]) existingCards[1].innerHTML = html.join(&apos;&apos;);
        else cards.insertAdjacentHTML(&apos;beforeend&apos;, `<div class="analysis-card">${html.join(&apos;&apos;)}</div>`);
      }

      if(loading) loading.style.display = &apos;none&apos;;
      console.log(&apos;ANALYSIS V2.0 finished&apos;, { fused, pred, adaptive });
      return { fused, prediction: pred, adaptiveMarkov: adaptive };
    }catch(err){
      console.error(&apos;runAnalysisV2 error&apos;, err);
      alert(&apos;Error saat menjalankan ANALYSIS V2.0  lihat console untuk detail&apos;);
    }
  };

  // Expose helper to get fused distribution without running UI
  window.getFusedDistribution = function(pool, opts){
    opts = opts || {};
    return (window.runAnalysisV2 && window.runAnalysisV2(Object.assign({pool:pool}, opts))) || null;
  };

  // Auto-attach: if there&apos;s an element #analRunV2 attach click
  document.addEventListener(&apos;DOMContentLoaded&apos;, function(){
    const btn = document.getElementById(&apos;analRunV2&apos;);
    if(btn) btn.addEventListener(&apos;click&apos;, ()=> runAnalysisV2());
  });

})();
</script>
<script>
// ======== FULL SHIO FUNCTIONALITY RESTORED ========

let shio_currentData = [];
let shio_currentPool = &apos;&apos;;
const shio_SHIO_NAMES = ["Tikus","Kerbau","Macan","Kelinci","Naga","Ular","Kuda","Kambing","Monyet","Ayam","Anjing","Babi"];


// Robust file handler for SHIO input (patched)
function shio_handleFile(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const content = event.target.result;
            const poolName = prompt("Masukkan nama Pool (cth: HKG_4D):", file.name.replace(/\.[^/.]+$/, ""));
            if (!poolName) return;
            const lines = content.split(/
?
/).map(line => line.trim()).filter(line => line.length > 0);
            const parsed = [];
            lines.forEach(line => {
                // Accept formats: "DD/MM/YYYY,1,2,3,4" or "YYYY-MM-DD 1 2 3 4" or "DD/MM/YYYY 1234"
                let parts = line.split(/[,\s]+/).map(p => p.trim()).filter(p => p !== &apos;&apos;);
                if (parts.length >= 5) {
                    // date + digits separated
                    const date = parts[0];
                    const nums = parts.slice(1);
                    parsed.push({ date: date, nums: nums, raw: line });
                } else if (parts.length === 2 && /^[0-9]{4,5}$/.test(parts[1])) {
                    // date + continuous digits like "DD/MM/YYYY 1234"
                    const date = parts[0];
                    const digits = parts[1].split(&apos;&apos;);
                    parsed.push({ date: date, nums: digits, raw: line });
                } else {
                    // try comma split as fallback
                    const cparts = line.split(&apos;,&apos;);
                    if (cparts.length >= 5) {
                        const date = cparts[0].trim();
                        const nums = cparts.slice(1).map(x => x.trim()).filter(x=>x!==&apos;&apos;);
                        parsed.push({ date: date, nums: nums, raw: line });
                    }
                }
            });
            if (parsed.length === 0) {
                alert(&apos;Gagal memproses data. Pastikan format file benar (DD/MM/YYYY,A,B,C,D atau DD/MM/YYYY 1234).&apos;);
                return;
            }
            shio_currentData = parsed;
            shio_currentPool = poolName.toUpperCase();
            document.getElementById(&apos;shio_dataStatus&apos;).textContent = `${shio_currentData.length} baris dimuat dari ${shio_currentPool}.`;
            // Add to select if not exists
            const select = document.getElementById(&apos;shio_poolSelect&apos;);
            if (select && !Array.from(select.options).some(opt => opt.value === shio_currentPool)) {
                const opt = document.createElement(&apos;option&apos;);
                opt.value = shio_currentPool;
                opt.textContent = shio_currentPool;
                select.appendChild(opt);
            } else if (select) {
                select.value = shio_currentPool;
            }
            alert(`Data ${shio_currentPool} berhasil dimuat. Jangan lupa Simpan Data!`);
        } catch (err) {
            console.error(&apos;Error saat membaca file SHIO:&apos;, err);
            alert(&apos;Terjadi kesalahan saat memproses file SHIO. Periksa format file.&apos;);
        }
    };
    reader.readAsText(file);
}

function shio_saveCurrentData() {
    if (!shio_currentPool || !shio_currentData.length) return alert("Tidak ada data!");
    localStorage.setItem(`shio_${shio_currentPool}`, JSON.stringify({pool: shio_currentPool, data: shio_currentData.map(d => d.raw)}));
    shio_loadSavedPools();
    alert("Data disimpan.");
}

function shio_loadSavedPools() {
    const s = document.getElementById(&apos;shio_poolSelect&apos;);
    if (!s) return;
    const p = [];
    for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k.startsWith(&apos;shio_&apos;)) p.push(k.replace(&apos;shio_&apos;, &apos;&apos;));
    }
    s.innerHTML = p.map(x => `<option value="${x}">${x}</option>`).join(&apos;&apos;);
    const sp = document.getElementById(&apos;shio_savedPools&apos;);
    if (sp) sp.classList.toggle(&apos;hidden&apos;, p.length === 0);
}

function shio_loadSelectedPool() {
    const s = document.getElementById(&apos;shio_poolSelect&apos;);
    const pool = s.value;
    if (!pool) return;
    const data = localStorage.getItem(`shio_${pool}`);
    if (!data) return;
    const parsed = JSON.parse(data);
    shio_currentPool = pool;
    shio_currentData = parsed.data.map(line => {
        const [date, a, b, c, d] = line.split(&apos;,&apos;).map(x => x.trim());
        return { date, nums: [a, b, c, d], raw: line };
    });
    document.getElementById(&apos;shio_dataStatus&apos;).textContent = `${shio_currentData.length} baris dimuat dari ${pool}.`;
}

function shio_clearAllData() {
    if (confirm("Hapus semua data SHIO?")) {
        for (let i = 0; i < localStorage.length; i++) {
            const k = localStorage.key(i);
            if (k.startsWith(&apos;shio_&apos;)) localStorage.removeItem(k);
        }
        shio_currentData = [];
        document.getElementById(&apos;shio_dataStatus&apos;).textContent = &apos;Semua data dihapus.&apos;;
        shio_loadSavedPools();
    }
}

function shio_getShio(num) {
    const n = parseInt(num);
    if (isNaN(n)) return &apos;&apos;;
    return shio_SHIO_NAMES[n % 12];
}

function shio_runPrediction() {
    if (!shio_currentData.length) return alert("Tidak ada data untuk analisis.");
    const lastEntry = shio_currentData[shio_currentData.length - 1];
    const nums = lastEntry.nums;
    const ab = (nums[0] + nums[1]).slice(-2);
    const cd = (nums[2] + nums[3]).slice(-2);
    const abPreds = [ab, (parseInt(ab) + 5) % 100].map(n => n.toString().padStart(2,&apos;0&apos;));
    const cdPreds = [cd, (parseInt(cd) + 5) % 100].map(n => n.toString().padStart(2,&apos;0&apos;));
    document.getElementById(&apos;shio_predABNumbers&apos;).innerHTML = abPreds.join(&apos; * &apos;);
    document.getElementById(&apos;shio_predCDNumbers&apos;).innerHTML = cdPreds.join(&apos; * &apos;);
    document.getElementById(&apos;shio_predABShio&apos;).textContent = shio_getShio(abPreds[0]);
    document.getElementById(&apos;shio_predCDShio&apos;).textContent = shio_getShio(cdPreds[0]);
}

document.addEventListener(&apos;DOMContentLoaded&apos;, () => {
    shio_loadSavedPools();
    document.getElementById(&apos;shio_fileInput&apos;).addEventListener(&apos;change&apos;, shio_handleFile);
    document.getElementById(&apos;shio_saveData&apos;).addEventListener(&apos;click&apos;, shio_saveCurrentData);
    document.getElementById(&apos;shio_loadData&apos;).addEventListener(&apos;click&apos;, shio_loadSelectedPool);
    document.getElementById(&apos;shio_clearData&apos;).addEventListener(&apos;click&apos;, shio_clearAllData);
    document.getElementById(&apos;shio_runPrediction&apos;).addEventListener(&apos;click&apos;, shio_runPrediction);
});
</script>
<!-- SHIO final upload & render script (added by assistant) -->
<script>
// Ensure globals
window.shio_currentData = window.shio_currentData || [];
window.shio_currentPool = window.shio_currentPool || null;
window.shio_SHIO_NAMES_ORIGINAL = window.shio_SHIO_NAMES_ORIGINAL || [
    &apos;Tikus&apos;, &apos;Kerbau&apos;, &apos;Macan&apos;, &apos;Kelinci&apos;, &apos;Naga&apos;, &apos;Ular&apos;,
    &apos;Kuda&apos;, &apos;Kambing&apos;, &apos;Monyet&apos;, &apos;Ayam&apos;, &apos;Anjing&apos;, &apos;Babi&apos;
];
window.shio_DAYS = window.shio_DAYS || [&apos;Minggu&apos;, &apos;Senin&apos;, &apos;Selasa&apos;, &apos;Rabu&apos;, &apos;Kamis&apos;, &apos;Jumat&apos;, &apos;Sabtu&apos;];

// Utility: parse date string (supports DD/MM/YYYY and YYYY-MM-DD)
function shio_parseDate_final(dateString) {
    if (!dateString) return null;
    if (dateString.includes(&apos;/&apos;)) {
        const parts = dateString.split(&apos;/&apos;).map(p=>p.trim());
        if (parts.length === 3) return new Date(parts[2], parts[1]-1, parts[0]);
    }
    // ISO-like
    try { return new Date(dateString); } catch(e){ return null; }
}

// Robust file handler for SHIO input (final)
function shio_handleFile_final(e) {
    const file = (e.target && e.target.files && e.target.files[0]) ? e.target.files[0] : null;
    if (!file) {
        alert(&apos;Tidak ada file dipilih.&apos;);
        return;
    }
    const reader = new FileReader();
    reader.onload = function(evt) {
        const content = evt.target.result || &apos;&apos;;
        if (!content.trim()) {
            alert(&apos;File kosong atau tidak dapat dibaca.&apos;);
            return;
        }
        const lines = content.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
        const parsed = [];
        for (let line of lines) {
            // Normalize separators
            let parts = line.split(/[,;\t]+/).map(p=>p.trim()).filter(p=>p!==&apos;&apos;);
            if (parts.length === 1) {
                // maybe "DD/MM/YYYY 1234" (space separated)
                parts = line.split(/\s+/).map(p=>p.trim()).filter(p=>p!==&apos;&apos;);
            }
            if (parts.length >= 2) {
                const datePart = parts[0];
                const rest = parts.slice(1).join(&apos; &apos;);
                // If rest is continuous digits like 1234 or 12345 -> split into digits
                const continuousMatch = rest.match(/^\d{4,5}$/);
                let nums = [];
                if (continuousMatch) {
                    nums = rest.split(&apos;&apos;);
                } else {
                    // split by non-digit to get numbers
                    nums = rest.split(/[^0-9]+/).map(s=>s.trim()).filter(s=>s!==&apos;&apos;).join(&apos;&apos;).split(&apos;&apos;);
                    // If that yields empty, try splitting original parts
                    if (nums.length === 0) {
                        nums = parts.slice(1).map(s=>s.replace(/[^0-9]/g,&apos;&apos;)).join(&apos;&apos;).split(&apos;&apos;);
                    }
                }
                // Basic validation: need at least 4 digits
                if (nums.length >= 4) {
                    parsed.push({ date: datePart, nums: nums, raw: line });
                } else {
                    // try CSV style: parts might be [date, A, B, C, D]
                    if (parts.length >= 5) {
                        const nums2 = parts.slice(1,5).map(p=>p.replace(/[^0-9]/g,&apos;&apos;));
                        if (nums2.join(&apos;&apos;).length >= 4) {
                            const flat = nums2.join(&apos;&apos;).split(&apos;&apos;);
                            parsed.push({ date: datePart, nums: flat, raw: line });
                        }
                    }
                }
            }
        }

        if (parsed.length === 0) {
            alert(&apos;Gagal memproses file. Pastikan format DD/MM/YYYY,1,2,3,4 atau DD/MM/YYYY 1234.&apos;);
            return;
        }

        // Ask pool name once (default from filename)
        const suggested = file.name.replace(/\.[^/.]+$/,&apos;&apos;).toUpperCase();
        const poolName = (prompt("Masukkan nama Pool (cth: HKG_4D):", suggested) || suggested).toUpperCase();
        window.shio_currentPool = poolName;
        window.shio_currentData = parsed;

        // Show status
        const statusEl = document.getElementById(&apos;shio_dataStatus&apos;);
        if (statusEl) {
            statusEl.textContent = ` ${parsed.length} baris dimuat dari POOL ${poolName}`;
        }

        // Add to select
        const sel = document.getElementById(&apos;shio_poolSelect&apos;);
        if (sel) {
            if (!Array.from(sel.options).some(o=>o.value === poolName)) {
                const opt = document.createElement(&apos;option&apos;);
                opt.value = poolName; opt.text = poolName;
                sel.appendChild(opt);
            }
            sel.value = poolName;
        }

        // Immediately render 2D horizontal
        shio_render2D_horizontal();

        // Auto-save to localStorage (but do not overwrite other pools)
        try {
            const pools = JSON.parse(localStorage.getItem(&apos;shio_pools&apos;) || &apos;{}&apos;);
            pools[poolName] = parsed.map(d=>d.raw).join(&apos;\n&apos;);
            localStorage.setItem(&apos;shio_pools&apos;, JSON.stringify(pools));
        } catch(e) {
            console.warn(&apos;Gagal menyimpan ke localStorage:&apos;, e);
        }

        alert(`Data ${poolName} berhasil dimuat dan ditampilkan.`);
    };
    reader.onerror = function() {
        alert(&apos;Gagal membaca file.&apos;);
    };
    reader.readAsText(file);
}

// Render function: show 2D horizontal with &apos;*&apos; separator
function shio_render2D_horizontal() {
    const target = document.getElementById(&apos;shio_2d_rekomendasi&apos;);
    if (!target) return;

    if (!window.shio_currentData || window.shio_currentData.length === 0) {
        target.innerHTML = &apos;<span style="color:var(--neon-yellow)">--- Angka 2D akan muncul di sini ---</span>&apos;;
        return;
    }

    // Extract 2D from each entry: last two digits as string (if nums length >=2)
    const results2D = window.shio_currentData.map(entry => {
        const n = entry.nums;
        if (n.length >= 2) {
            const lastTwo = n.slice(-2).join(&apos;&apos;);
            return lastTwo.padStart(2,&apos;0&apos;);
        } else {
            return null;
        }
    }).filter(x=>x);

    // Unique preserve order
    const seen = new Set();
    const unique2D = [];
    for (let v of results2D) {
        if (!seen.has(v)) { seen.add(v); unique2D.push(v); }
    }

    // Build horizontal string with &apos; * &apos; separator, wrap each in span.neon-num
    const html = unique2D.map(v => `<span class="neon-num">${v}</span>`).join(&apos; * &apos;);
    target.innerHTML = html || &apos;<span style="color:var(--neon-yellow)">--- Tidak ada 2D valid ---</span>&apos;;

    // Also fill shio_predABNumbers and shio_predCDNumbers if they exist: split half for AB/CD
    const abEl = document.getElementById(&apos;shio_predABNumbers&apos;);
    const cdEl = document.getElementById(&apos;shio_predCDNumbers&apos;);
    if (abEl && cdEl) {
        const half = Math.ceil(unique2D.length / 2);
        const ab = unique2D.slice(0, half).map(v => `<span class="neon-num">${v}</span>`).join(&apos; * &apos;);
        const cd = unique2D.slice(half).map(v => `<span class="neon-num">${v}</span>`).join(&apos; * &apos;);
        abEl.innerHTML = ab || &apos;<span style="color:var(--neon-yellow)">-</span>&apos;;
        cdEl.innerHTML = cd || &apos;<span style="color:var(--neon-yellow)">-</span>&apos;;
    }
}

// Load pool from localStorage and render
function shio_loadDataForPool_final(pool) {
    if (!pool) return;
    try {
        const pools = JSON.parse(localStorage.getItem(&apos;shio_pools&apos;) || &apos;{}&apos;);
        const dataString = pools[pool];
        if (!dataString) {
            alert(&apos;Pool tidak ditemukan di localStorage.&apos;);
            return;
        }
        const lines = dataString.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
        const parsed = lines.map(line => {
            const parts = line.split(/[,;\s]+/).map(p=>p.trim()).filter(p=>p!==&apos;&apos;);
            const date = parts[0] || &apos;&apos;;
            const nums = parts.slice(1).join(&apos;&apos;).split(&apos;&apos;);
            return { date: date, nums: nums, raw: line };
        });
        window.shio_currentPool = pool;
        window.shio_currentData = parsed;
        const statusEl = document.getElementById(&apos;shio_dataStatus&apos;);
        if (statusEl) statusEl.textContent = ` ${parsed.length} baris dimuat dari POOL ${pool}`;
        shio_render2D_horizontal();
    } catch(e) {
        alert(&apos;Gagal memuat data pool: &apos; + e.message);
    }
}

// Save current buffer to localStorage under current pool
function shio_saveData_final() {
    if (!window.shio_currentPool || !window.shio_currentData || window.shio_currentData.length === 0) {
        alert(&apos;Tidak ada data untuk disimpan.&apos;);
        return;
    }
    try {
        const pools = JSON.parse(localStorage.getItem(&apos;shio_pools&apos;) || &apos;{}&apos;);
        pools[window.shio_currentPool] = window.shio_currentData.map(d=>d.raw).join(&apos;\n&apos;);
        localStorage.setItem(&apos;shio_pools&apos;, JSON.stringify(pools));
        alert(`Data ${window.shio_currentPool} disimpan ke localStorage.`);
    } catch(e) {
        alert(&apos;Gagal menyimpan: &apos; + e.message);
    }
}

// Wire up listeners (safe on DOMContentLoaded)
function shio_setup_listeners() {
    const input = document.getElementById(&apos;shio_fileInput&apos;);
    if (input && !input._shio_bound) {
        input.addEventListener(&apos;change&apos;, shio_handleFile_final);
        input._shio_bound = true;
    }
    const saveBtn = document.getElementById(&apos;shio_saveData&apos;);
    if (saveBtn && !saveBtn._shio_bound) {
        saveBtn.addEventListener(&apos;click&apos;, shio_saveData_final);
        saveBtn._shio_bound = true;
    }
    const sel = document.getElementById(&apos;shio_poolSelect&apos;);
    if (sel && !sel._shio_bound) {
        sel.addEventListener(&apos;change&apos;, function(){ shio_loadDataForPool_final(this.value); });
        sel._shio_bound = true;
    }
    // If there&apos;s an explicit "Load Pool" button, try to wire it (id shio_loadData maybe)
    const loadBtn = document.getElementById(&apos;shio_loadData&apos;);
    if (loadBtn && !loadBtn._shio_bound) {
        loadBtn.addEventListener(&apos;click&apos;, function(){
            const selv = document.getElementById(&apos;shio_poolSelect&apos;);
            if (selv) shio_loadDataForPool_final(selv.value);
        });
        loadBtn._shio_bound = true;
    }
}

// Run setup now and on DOMContentLoaded fallback
try { shio_setup_listeners(); } catch(e){ /*ignore*/ }
document.addEventListener(&apos;DOMContentLoaded&apos;, shio_setup_listeners);
</script>











<!-- SHIO integrated analysis FIX4 with auto 4D/5D detection -->
<script>
function shio_detectAndParseFile(lines){
    const data = [];
    let type = "Unknown";
    for (let line of lines){
        line = line.trim();
        if (!line) continue;
        const parts = line.split(/[\s,]+/);
        if (parts.length < 5) continue;
        const date = parts[0];
        const nums = parts.slice(1).map(n => parseInt(n));
        if (nums.length === 4) type = "4D";
        if (nums.length === 5) type = "5D";
        data.push({ date, nums });
    }
    return {data, type};
}

// === Analisis Otomatis SHIO ===
function shio_analyzeAndPredictIntegrated(){
    if (!window.shio_currentData || shio_currentData.length === 0){
        console.warn("Tidak ada data untuk dianalisis.");
        return;
    }

    const shioList = window.shio_SHIO_NAMES_ORIGINAL || [
        &apos;Tikus&apos;,&apos;Kerbau&apos;,&apos;Macan&apos;,&apos;Kelinci&apos;,&apos;Naga&apos;,&apos;Ular&apos;,
        &apos;Kuda&apos;,&apos;Kambing&apos;,&apos;Monyet&apos;,&apos;Ayam&apos;,&apos;Anjing&apos;,&apos;Babi&apos;
    ];

    // Hitung frekuensi SHIO dari dua digit terakhir
    const freq = {};
    shioList.forEach(s => freq[s] = 0);
    for (let entry of shio_currentData){
        let nums = entry.nums;
        if (!Array.isArray(nums)) continue;
        const num2D = parseInt(String(nums.slice(-2).join(&apos;&apos;)));
        const shio = shioList[num2D % 12];
        freq[shio]++;
    }

    // ===== POLA DOMINAN =====
    const sortedFreq = Object.entries(freq).sort((a,b)=>b[1]-a[1]);
    const top3 = sortedFreq.slice(0,3).map(([s,c])=>`${s} (${c})`).join(&apos;, &apos;);
    const domEl = document.getElementById("shio_dominan_pola");
    if (domEl) domEl.innerHTML = `<b style="color:var(--neon-green)">Top 3:</b> ${top3}`;

    // ===== POLA TRANSISI =====
    const transitions = {};
    for (let i=0;i<shio_currentData.length-1;i++){
        const a = parseInt(shio_currentData[i].nums.slice(-2).join(&apos;&apos;));
        const b = parseInt(shio_currentData[i+1].nums.slice(-2).join(&apos;&apos;));
        const s1 = shioList[a % 12], s2 = shioList[b % 12];
        const key = s1 + "" + s2;
        transitions[key] = (transitions[key]||0)+1;
    }
    const top2 = Object.entries(transitions).sort((a,b)=>b[1]-a[1]).slice(0,2);
    const transEl = document.getElementById("shio_transisi_pola");
    if (transEl){
        transEl.innerHTML = top2.length ? top2.map(([k,v])=>`<div style=&apos;color:var(--neon-yellow)&apos;>${k} (${v}x)</div>`).join(&apos;&apos;) :
        "<span style=&apos;color:var(--neon-red)&apos;>Tidak cukup data transisi</span>";
    }

    // ===== POLA SHIO MATI (Posisi 2D Terendah) =====
    const matiEl2D = document.getElementById("shio_mati_2d");
    if (matiEl2D){
        const lowest = sortedFreq.slice(-3).map(([s,c])=>`${s} (${c})`).join(&apos;, &apos;);
        matiEl2D.innerHTML = `<b style=&apos;color:var(--neon-red)&apos;>Posisi 2D Terendah:</b> ${lowest}`;
    }

    // ===== SHIO MATI HARI INI (TABEL) =====
    const sortedAsc = Object.entries(freq).sort((a,b)=>a[1]-b[1]);
    let tableHTML = "<table style=&apos;width:100%;border-collapse:collapse;font-size:0.9em;&apos;>";
    tableHTML += "<thead><tr><th style=&apos;border:1px solid var(--neon-green);color:var(--neon-yellow);padding:4px;&apos;>SHIO</th>";
    tableHTML += "<th style=&apos;border:1px solid var(--neon-green);color:var(--neon-yellow);padding:4px;&apos;>Jumlah Muncul</th></tr></thead><tbody>";
    sortedAsc.forEach(([s,c],i)=>{
        const color = i < 3 ? "var(--neon-red)" : "var(--neon-green)";
        tableHTML += `<tr><td style=&apos;border:1px solid var(--neon-green);padding:4px;color:${color}&apos;>${s}</td>`+
                     `<td style=&apos;border:1px solid var(--neon-green);padding:4px;color:${color};text-align:center;&apos;>${c}</td></tr>`;
    });
    tableHTML += "</tbody></table>";
    const matiEl = document.getElementById("shio_mati_pola");
    if (matiEl) matiEl.innerHTML = tableHTML;
}

// === Integrasi upload dan load dengan deteksi otomatis ===
(function(){
    const origUpload = window.shio_handleFile_final;
    const origLoad = window.shio_loadDataForPool_final;

    window.shio_handleFile_final = async function(e){
        const file = e.target.files[0];
        if (!file) return;
        const text = await file.text();
        const lines = text.split(/\r?\n/);
        const {data, type} = shio_detectAndParseFile(lines);
        window.shio_currentData = data;
        document.getElementById("shio_dataStatus").innerHTML =
            ` ${data.length} baris dimuat (${type})`;
        shio_analyzeAndPredictIntegrated();
    };

    if (origLoad){
        window.shio_loadDataForPool_final = function(pool){
            origLoad(pool);
            setTimeout(shio_analyzeAndPredictIntegrated, 600);
        };
    }
})();

document.addEventListener("DOMContentLoaded", ()=>{
    setTimeout(()=>{
        if (window.shio_currentData && shio_currentData.length>0){
            shio_analyzeAndPredictIntegrated();
        }
    },1000);
});
</script>


<!-- SHIO FIX5: Universal hooks to ensure analysis runs after any upload/load -->
<script>
(function(){
    function safeRunAnalysis() {
        try {
            if (typeof shio_analyzeAndPredictIntegrated === &apos;function&apos;) {
                shio_analyzeAndPredictIntegrated();
                return;
            }
            // fallback: try to call older function names if present
            if (typeof shio_analyzeDominantPatterns_final === &apos;function&apos;) {
                shio_analyzeDominantPatterns_final();
            }
            if (typeof shio_predictTodayShio_final === &apos;function&apos;) {
                shio_predictTodayShio_final();
            }
        } catch(err){
            console.error(&apos;Error running SHIO analysis:&apos;, err);
        }
    }

    // Wrap a function with after-hook that runs analysis
    function wrapFunction(obj, name) {
        if (!obj || !name || typeof obj[name] !== &apos;function&apos;) return false;
        if (obj[name]._shio_wrapped) return true;
        var orig = obj[name];
        obj[name] = function() {
            try {
                var res = orig.apply(this, arguments);
            } catch(e) {
                console.warn(&apos;Original function threw:&apos;, e);
            }
            // schedule analysis after a short delay to allow data to be set
            setTimeout(safeRunAnalysis, 700);
            return res;
        };
        obj[name]._shio_wrapped = true;
        return true;
    }

    // Try wrapping known function names
    var win = window;
    var candidates = [&apos;shio_handleFile&apos;, &apos;shio_handleFile_final&apos;, &apos;shio_loadDataForPool&apos;, &apos;shio_loadDataForPool_final&apos;, &apos;shio_saveData&apos;, &apos;shio_loadSavedPools&apos;, &apos;shio_loadSavedPools_final&apos;];
    candidates.forEach(function(fname){
        wrapFunction(win, fname);
    });

    // Also observe changes to shio_currentData variable periodically
    var lastLen = (window.shio_currentData && window.shio_currentData.length) || 0;
    setInterval(function(){
        var len = (window.shio_currentData && window.shio_currentData.length) || 0;
        if (len !== lastLen) {
            lastLen = len;
            console.log(&apos;shio_currentData length changed ->&apos;, len);
            setTimeout(safeRunAnalysis, 400);
        }
    }, 1000);

    // Listen for localStorage changes to &apos;shio_pools&apos; (from other tabs)
    window.addEventListener(&apos;storage&apos;, function(e){
        if (e.key && e.key.indexOf(&apos;shio_pools&apos;) !== -1) {
            console.log(&apos;storage event for shio_pools detected&apos;);
            setTimeout(safeRunAnalysis, 500);
        }
    });

    // Also attach to the file input onchange if present
    document.addEventListener(&apos;DOMContentLoaded&apos;, function(){
        var input = document.getElementById(&apos;shio_fileInput&apos;);
        if (input && !input._shio_listener) {
            input.addEventListener(&apos;change&apos;, function(evt){
                // give original handlers a chance to run first
                setTimeout(safeRunAnalysis, 800);
            });
            input._shio_listener = true;
        }
        // if there&apos;s a "Muat Pool" button or select, attach change
        var sel = document.getElementById(&apos;shio_poolSelect&apos;);
        if (sel && !sel._shio_listener) {
            sel.addEventListener(&apos;change&apos;, function(){ setTimeout(safeRunAnalysis, 600); });
            sel._shio_listener = true;
        }
    });
})();
</script>

</body>
</html>
' frameborder="0" style="width:100%;height:calc(100vh - 80px);border:none;"></iframe>
    </section>
    

    <script>
        function showPage(pageId, btn) {
            document.querySelectorAll('.spa-page').forEach(sec => sec.style.display = 'none');
            document.getElementById(pageId).style.display = 'block';
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }
        // default
        document.getElementById('pagePolaBK').style.display = 'block';
    </script>
	<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').then(reg => {
    console.log('SW registered', reg);
  }).catch(err => console.warn('SW error', err));
}
</script>

</body>
<div id="splash" style="
  position: fixed; top: 0; left: 0;
  width: 100%; height: 100%;
  background: radial-gradient(circle at center, #00fff7 0%, #000 80%);
  display: flex; align-items: center; justify-content: center;
  font-family: 'Orbitron', sans-serif;
  color: #00fff7; font-size: 2em;
  letter-spacing: 2px; z-index: 9999;
  transition: opacity 1.2s ease-out;">
  <span>Loading <span class='blink'></span></span>
</div>
<style>
  .blink { animation: blink 1s infinite; }
  @keyframes blink { 50% { opacity: 0; } }
</style>
<script>
  window.addEventListener('load', () => {
    setTimeout(() => {
      const s = document.getElementById('splash');
      s.style.opacity = '0';
      setTimeout(() => s.remove(), 1200);
    }, 1000);
  });
</script>

</html>
